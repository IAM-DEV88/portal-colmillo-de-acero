---
// Definir las props del componente
interface Props {
  initialRosterData?: any[];
  raidRegistrations?: any[];
}

// Obtener las props
const { initialRosterData: rosterDataFromProps = [], raidRegistrations = [] } = Astro.props;

// Define default class info with TypeScript type
const defaultClassInfo: Record<string, { name: string; color: string }> = {
  // English class names
  'Warrior': { color: 'C79C6E', name: 'Guerrero' },
  'Paladin': { color: 'F58CBA', name: 'Paladín' },
  'Hunter': { color: 'ABD473', name: 'Cazador' },
  'Rogue': { color: 'FFF569', name: 'Pícaro' },
  'Priest': { color: 'FFFFFF', name: 'Sacerdote' },
  'Death Knight': { color: 'C41F3B', name: 'Caballero de la Muerte' },
  'Shaman': { color: '0070DE', name: 'Chamán' },
  'Mage': { color: '69CCF0', name: 'Mago' },
  'Warlock': { color: '9482C9', name: 'Brujo' },
  'Druid': { color: 'FF7D0A', name: 'Druida' },
  // Keep Spanish class names for backward compatibility
  'Guerrero': { color: 'C79C6E', name: 'Guerrero' },
  'Paladín': { color: 'F58CBA', name: 'Paladín' },
  'Cazador': { color: 'ABD473', name: 'Cazador' },
  'Pícaro': { color: 'FFF569', name: 'Pícaro' },
  'Sacerdote': { color: 'FFFFFF', name: 'Sacerdote' },
  'Caballero de la Muerte': { color: 'C41F3B', name: 'Caballero de la Muerte' },
  'Chamán': { color: '0070DE', name: 'Chamán' },
  'Mago': { color: '69CCF0', name: 'Mago' },
  'Brujo': { color: '9482C9', name: 'Brujo' },
  'Druida': { color: 'FF7D0A', name: 'Druida' },
};

// Import types and constants from roster types
import type {
  RosterMember,
  RosterData,
  ClassInfo,
  ClassName as ClassNameType,
  Role as RosterRole,
  MainAlt as RosterMainAlt,
  ProfessionCode as RosterProfessionCode,
  RaidCode,
  DifficultyCode,
  PublicNoteValidation as RosterPublicNoteValidation,
  MainAltDistributionItem as MainAltDistItem,
  NoteBlock,
  Member as RosterMemberBase,
  RosterStats as BaseRosterStats,
  RaidInfo,
} from '../../types/roster';

// Local type extensions
interface RosterMemberType extends RosterMemberBase {
  leaderData?: Record<string, unknown>;
  validation?: {
    isValid: boolean;
    missingFields: string[];
  };
}

interface RosterStats extends BaseRosterStats {
  gearScoreStats: {
    min: number;
    max: number;
    avg: number;
    total: number;
    mainGearScore: number;
    dualGearScore: number | null;
  };
}

import featuredPlayersData from '../../data/featuredPlayers.json';

// Usar los tipos directamente desde la importación

// Import roster utilities
import {
  validatePublicNote as validateRosterNote,
  calculateRoleDistribution as calculateRoleDistro,
  calculateGearScoreStats as calculateGSStats,
  countRaidLeaders as countLeaders,
  calculateMainAltDistribution as calculateMainAlts,
  PROFESSION_CODES,
} from '../../utils/rosterUtils';

import rosterJson from '../../data/roster.json';
const globalLastUpdate = rosterJson.globalLastUpdate;

// Find the player who updated the roster
const lastUpdatedBy = Object.entries(rosterJson.players).find(
  ([_, player]: [string, any]) => player.leaderData?.lastUpdate === globalLastUpdate
)?.[0] || 'Desconocido';

type LocalProfessionCode = (typeof PROFESSION_CODES)[number];

// Variables para las estadísticas de Gear Score
let gearScoreStats = {
  min: 0,
  max: 0,
  avg: 0,
  total: 0,
  mainGearScore: 0,
  dualGearScore: null as number | null,
};
let averageGearScore = 'N/A';
let minGearScore = 'N/A';
let maxGearScore = 'N/A';
let mainGearScore = 'N/A';
let dualGearScore = 'N/A';

// Import constants
import {
  ROLES,
  PROFESSIONS,
  RAID_NAMES,
  DIFFICULTY_NAMES,
  DAY_NAMES,
  RAID_CODES,
  STATUS,
} from '../../types/roster';

// Define initial stats structure
const initialStats: RosterStats = {
  totalMembers: 0,
  roleDistribution: { tank: 0, healer: 0, melee: 0, ranged: 0 },
  gearScoreStats: {
    min: 0,
    max: 0,
    avg: 0,
    total: 0,
  },
  raidLeadersCount: 0,
  mainAltDistribution: { M: 0, A: 0 },
  professions: {},
  validNotesCount: 0,
};

// Define raid pattern for parsing
const raidPattern = /(.*?)(?:\s*\(([^)]+)\))?\s*\[(.*?)\](?:\s*\(([^)]+)\))?/;

// Define RAIDS constant with proper typing
const RAIDS: Array<{ code: RaidCode; name: string }> = Object.entries(RAID_NAMES).map(
  ([code, name]) => ({
    code: code as RaidCode,
    name: String(name),
  })
);

// Initialize stats with default values
let stats: RosterStats = {
  ...initialStats,
  gearScoreStats: {
    min: 0,
    max: 0,
    avg: 0,
    total: 0,
    mainGearScore: 0,
    dualGearScore: null,
  },
};

// Type definitions for the component
interface RoleInfo {
  name: string;
  color: string;
  icon: string;
}

// Component props interface
export interface RosterTableProps {
  rosterData: RosterData;
  status?: {
    isLoading: boolean;
    error: string | null;
  };
}

// Get props from Astro
const { rosterData: initialRosterData, status = { isLoading: false, error: null } } =
  Astro.props as RosterTableProps;

// Define default roster data structure
const defaultRosterData: RosterData = {
  members: [],
  classInfo: {},
  rankInfo: {},
  classes: [],
  totalMembers: 0,
  // guildInfo removed as it's not part of RosterData type
  stats: {
    ...initialStats,
    totalMembers: 0,
    raidLeadersCount: 0,
    mainAltDistribution: { M: 0, A: 0 },
    professions: {},
    validNotesCount: 0,
  },
} as const;

// Usar directamente las funciones importadas con sus alias

// Process members with proper typing
const processRosterMember = (member: any): RosterMemberType => {
  // Handle the case where member might be in the new format with nested data
  const memberData = member.leaderData
    ? {
        ...member,
        name: member.name || '',
        class: member.class || 'Desconocido',
        rank:
          member.rank &&
          (member.rank.toLowerCase().includes('guild master') ||
            member.rank.toLowerCase().includes('alter'))
            ? 'Administrador'
            : member.rank || 'Miembro',
        publicNote: member.publicNote || '',
        officerNote: member.officerNote || '',
        race: member.race || '',
        guildLeave: member.guildLeave || false,
        level: 80, // Default level for WoW Classic
        gearScore: 0, // Will be calculated from note validation
      }
    : {
        ...member,
        rank:
          member.rank &&
          (member.rank.toLowerCase().includes('guild master') ||
            member.rank.toLowerCase().includes('alter'))
            ? 'Administrador'
            : member.rank || 'Miembro',
      };

  // Normalize class name - handle both uppercase and mixed case
  const normalizeClassName = (name: string): string => {
    if (!name) return '';
    
    // First, try to find a direct match in defaultClassInfo (case insensitive)
    const directMatch = Object.keys(defaultClassInfo).find(
      key => key.toLowerCase() === name.trim().toLowerCase()
    );
    
    if (directMatch) return directMatch;
    
    // If no direct match, try to normalize the name
    const lowerName = name.trim().toLowerCase();
    
    // Special case for 'deathknight' (sometimes comes as one word)
    if (lowerName === 'deathknight' || lowerName === 'death knight') {
      return 'Death Knight';
    }
    
    // For other cases, capitalize first letter of each word
    return lowerName
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  };

  const normalizedClassName = normalizeClassName(memberData.class || '');
  
  // Find the class in defaultClassInfo (case insensitive)
  const className = (Object.keys(defaultClassInfo) as (keyof typeof defaultClassInfo)[]).find(
    key => key.toLowerCase() === normalizedClassName.toLowerCase()
  ) || 'Desconocido';
  
  // Debug log for troubleshooting
  if (memberData.class && className === 'Desconocido') {
    console.log('Unknown class:', memberData.class, 'Normalized:', normalizedClassName);
  }

  // Ensure mainAlt is either 'M' or 'A'
  const mainAlt =
    memberData.mainAlt === 'main'
      ? 'M'
      : memberData.mainAlt === 'alt'
        ? 'A'
        : memberData.mainAlt || 'A';

  // Validar la nota pública usando el alias importado
  const noteValidation = validateRosterNote(
    memberData.publicNote || '',
    memberData.name || '',
    memberData.officerNote || ''
  );

  // Asegurar que noteValidation cumpla con PublicNoteValidation
  const validNoteValidation: RosterPublicNoteValidation = {
    isValid: noteValidation.isValid || false,
    blocks: noteValidation.blocks || [],
    mainAlt: noteValidation.mainAlt || 'A', // Valor por defecto 'A' si no está definido
    role: noteValidation.role,
    dualRole: noteValidation.dualRole,
    gearScore: noteValidation.gearScore || 0,
    dualGearScore: noteValidation.dualGearScore,
    professions: noteValidation.professions || [],
    isRaidLeader: noteValidation.isRaidLeader || false,
    hasSchedule: noteValidation.hasSchedule || false,
    schedules: noteValidation.schedules || [],
    error: noteValidation.error,
    missingFields: noteValidation.missingFields || [],
  };

  // Deducir facción de la raza
  const allianceRaces = ['HU', 'NE', 'DW', 'GN', 'DR'] as const;
  const hordeRaces = ['OR', 'TA', 'UN', 'TR', 'BE'] as const;
  let deducedFaction = '';
  if (member.race) {
    if ((allianceRaces as readonly string[]).includes(member.race)) {
      deducedFaction = '1';
    } else if ((hordeRaces as readonly string[]).includes(member.race)) {
      deducedFaction = '2';
    }
  }

  // Recopilar reconocimientos de featuredPlayers.json
  const memberRecognitions: Array<{
    title: string;
    description: string;
    date: string;
    icon?: string;
  }> = [];
  const typedFeaturedData = featuredPlayersData as any;
  const recognitionsList = typedFeaturedData.recognitions || [];

  Object.entries(typedFeaturedData).forEach(([year, yearData]) => {
    if (year === 'recognitions') return;

    Object.entries(yearData as Record<string, any>).forEach(([month, monthData]) => {
      if (monthData.featuredPlayers) {
        (monthData.featuredPlayers || []).forEach((fp: any) => {
          // Robust name matching
          const fpName = String(fp.playerName || '')
            .trim()
            .toLowerCase();
          const targetName = String(memberData.name || '')
            .trim()
            .toLowerCase();

          if (fpName === targetName && fpName !== '') {
            (fp.recognitionIndices || []).forEach((idx: number) => {
              const rec = recognitionsList[idx];
              if (rec) {
                memberRecognitions.push({
                  ...rec,
                  date: `${year}-${month.padStart(2, '0')}-01`,
                });
              }
            });
          }
        });
      }
    });
  });

  // Ordenar por fecha descendente
  memberRecognitions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

  // Create a valid RosterMember object with required properties
  const processedMember: RosterMemberType = {
    ...memberData,
    name: memberData.name || 'Unknown',
    class: className,
    rank: memberData.rank || 'Miembro',
    publicNote: memberData.publicNote || '',
    officerNote: memberData.officerNote || '',
    race: memberData.race || '',
    guildLeave: memberData.guildLeave || false,
    level: memberData.level || 80,
    gearScore: noteValidation.gearScore || 0,
    mainAlt,
    noteValidation: validNoteValidation,
    leaderData: member.leaderData || {},
    validation: {
      isValid: noteValidation.isValid,
      missingFields: noteValidation.missingFields || [],
    },
    recognitions: memberRecognitions,
    faction: deducedFaction,
  };

  return processedMember;
};

// Las funciones de cálculo ahora se importan desde rosterUtils.ts

// Define the roster data with proper typing
// Procesar los miembros del roster
const members = rosterDataFromProps.map(processRosterMember).filter((m) => !m.guildLeave);
const totalMembers = members.length;
const validNotesCount = members.filter((m) => m.publicNote).length;

// Utility function to get role percentage
const getRolePercentage = (count: number, total: number = totalMembers) => {
  return total > 0 ? Math.round((count / total) * 100) : 0;
};

// Calcular las estadísticas de Gear Score
const updateGearScoreStats = () => {
  try {
    const stats = calculateGSStats(members as unknown as RosterMemberType[]);
    gearScoreStats = stats;
    averageGearScore = stats.avg > 0 ? stats.avg.toFixed(1) : 'N/A';
    minGearScore = stats.min > 0 ? stats.min.toFixed(1) : 'N/A';
    maxGearScore = stats.max > 0 ? stats.max.toFixed(1) : 'N/A';
    mainGearScore = stats.mainGearScore > 0 ? stats.mainGearScore.toFixed(1) : 'N/A';
    dualGearScore =
      stats.dualGearScore !== null && stats.dualGearScore > 0
        ? stats.dualGearScore.toFixed(1)
        : 'N/A';
  } catch (error) {
    gearScoreStats = { min: 0, max: 0, avg: 0, total: 0 };
    averageGearScore = 'N/A';
    minGearScore = 'N/A';
    maxGearScore = 'N/A';
  }
};

// Ejecutar el cálculo inicial
updateGearScoreStats();

// Function to ensure roster members have all required properties
function ensureRosterMember(member: Partial<RosterMember>): RosterMember {
  return {
    name: member.name || 'Unknown',
    class: member.class || 'Guerrero',
    rank: member.rank || 'Aspirante',
    publicNote: member.publicNote || '',
    officerNote: member.officerNote || '',
    race: member.race || '',
    faction: (() => {
      const allianceRaces = ['HU', 'NE', 'DW', 'GN', 'DR'];
      const hordeRaces = ['OR', 'TA', 'UN', 'TR', 'BE'];
      if (member.race) {
        if (allianceRaces.includes(member.race)) return '1';
        if (hordeRaces.includes(member.race)) return '2';
      }
      return member.faction || '';
    })(),
    noteValidation: member.noteValidation || {
      isValid: false,
      mainAlt: 'M',
      role: 'D',
      gearScore: 0,
      professions: [],
      schedules: [],
      missingFields: [],
      error: 'No note provided',
    },
    mainAlt: member.mainAlt || 'A',
    recognitions: Array.isArray(member.recognitions) ? member.recognitions : [],
    ...member,
  };
}

// Process members to ensure they have required properties
const processedMembers = members.map((member) =>
  ensureRosterMember(member as Partial<RosterMember>)
);

// Create the rosterData object with the expected structure
const rosterData: RosterDataWithRankInfo = {
  ...defaultRosterData,
  members: processedMembers,
  totalMembers,
  classInfo: {
    ...defaultClassInfo,
  },
  stats: {
    ...initialStats,
    totalMembers,
    validNotesCount,
    roleDistribution: calculateRoleDistro(processedMembers),
    gearScoreStats: calculateGSStats(processedMembers),
    raidLeadersCount: countLeaders(processedMembers),
    mainAltDistribution: calculateMainAlts(processedMembers),
    professions: {},
  },
  raids: [],
  raidDays: {},
  raidTimes: {},
  rankInfo: {},
} as unknown as RosterDataWithRankInfo;

// Calculate statistics - single implementation
const calculateStats = (members: RosterMember[]): RosterStats => {
  if (!members.length)
    return {
      ...initialStats,
      totalMembers: 0,
      roleDistribution: {},
      gearScoreStats: { min: 0, max: 0, avg: 0, total: 0, mainGearScore: 0, dualGearScore: null },
      raidLeadersCount: 0,
      mainAltDistribution: { M: 0, A: 0 },
      professions: {},
      validNotesCount: 0,
    } as RosterStats;

  // Initialize profession counts
  const professions: Record<string, number> = {};

  // Initialize profession counts to 0
  PROFESSION_CODES.forEach((code) => {
    professions[code] = 0;
  });

  // Use members directly with proper type
  const roleDistribution = calculateRoleDistro(members);
  const gearScoreStats = calculateGSStats(members);
  const raidLeadersCount = countLeaders(members);
  const mainAltDistribution = calculateMainAlts(members);
  const validNotesCount = members.filter((m) => m.noteValidation?.isValid).length;

  let totalProcessed = 0;
  let membersWithValidNotes = 0;
  // Initialize profession counts to 0
  PROFESSION_CODES.forEach((code) => {
    professions[code] = 0;
  });

  // Process each member's professions
  for (const member of members) {
    // Only process if the note is valid
    if (!member.noteValidation?.isValid) {
      continue;
    }

    membersWithValidNotes++;

    // Get professions from all possible sources
    const profSources: string[] = [];

    // 1. Get professions directly from noteValidation
    if (member.noteValidation?.professions?.length) {
      profSources.push(...member.noteValidation.professions);
    }

    // 2. Get professions from character blocks
    const characterBlocks = (member.noteValidation?.blocks || []).filter(
      (b) => b.type === 'character' && b.parsedData?.professions?.length
    );

    if (characterBlocks.length > 0) {
      characterBlocks.forEach((block) => {
        if (block.parsedData?.professions?.length) {
          profSources.push(...block.parsedData.professions);
        }
      });
    }

    // Filter and normalize profession codes
    const allProfs: string[] = [...new Set(profSources)]
      .filter((code): code is string => Boolean(code)) // Filter and ensure they are strings
      .map((code) => {
        const normalizedCode = code.trim().toUpperCase();
        // Ensure the code has exactly 2 characters
        return normalizedCode.length === 2 ? normalizedCode : null;
      })
      .filter((code): code is string => Boolean(code)) // Remove null codes after normalization
      .filter((code): code is LocalProfessionCode => {
        const isValid = PROFESSION_CODES.includes(code as LocalProfessionCode);
        if (!isValid && code) {
          console.warn(`  Unrecognized profession code: "${code}"`);
        }
        return isValid;
      }) as LocalProfessionCode[]; // Ensure TypeScript knows these are valid profession codes

    // Count the professions
    allProfs.forEach((profCode) => {
      if (profCode in professions) {
        professions[profCode]++;
        totalProcessed++;
      } else {
        console.warn(`  Unrecognized profession code: ${profCode}`);
      }
    });
  }

  // Verificar si hay alguna profesión con conteo > 0
  const hasProfessions = Object.values(professions).some((count) => count > 0);

  if (!hasProfessions) {
    console.warn('No se encontraron profesiones en ninguna nota. Revisar el formato de las notas.');
  }

  // Actualizar las estadísticas globales
  stats.validNotesCount = membersWithValidNotes;
  stats.professions = professions;

  return {
    totalMembers: members.length,
    roleDistribution,
    gearScoreStats,
    raidLeadersCount,
    mainAltDistribution,
    professions,
    validNotesCount: membersWithValidNotes,
  };
};

// mainAltStats se define más abajo con un cálculo más completo

// Calcular estadísticas completas del roster
const calculatedStats = calculateStats(rosterData.members);

// Actualizar las estadísticas del roster
stats = {
  ...stats,
  totalMembers: rosterData.totalMembers,
  validNotesCount: calculatedStats.validNotesCount || 0,
  professions: calculatedStats.professions || {},
};

// Asegurarse de que rosterData.stats tenga las estadísticas actualizadas
rosterData.stats = {
  ...rosterData.stats,
  ...calculatedStats,
};

// Inicializar roleStats contando cada rol (T, H, D) independientemente de si es rol principal o dual
// Un jugador puede contribuir a múltiples roles si tiene un rol dual
const roleStats = {
  T: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'T' || member.noteValidation?.dualRole === 'T'
  ).length,
  H: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'H' || member.noteValidation?.dualRole === 'H'
  ).length,
  D: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'D' || member.noteValidation?.dualRole === 'D'
  ).length,
};

// Contar roles duales por separado
const dualRoleStats = {
  TH: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'T' && member.noteValidation?.dualRole === 'H') ||
      (member.noteValidation?.role === 'H' && member.noteValidation?.dualRole === 'T')
  ).length,
  TD: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'T' && member.noteValidation?.dualRole === 'D') ||
      (member.noteValidation?.role === 'D' && member.noteValidation?.dualRole === 'T')
  ).length,
  HD: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'H' && member.noteValidation?.dualRole === 'D') ||
      (member.noteValidation?.role === 'D' && member.noteValidation?.dualRole === 'H')
  ).length,
};

// Format role distribution for display
const formattedRoleDistribution = Object.entries(rosterData.stats.roleDistribution || {})
  .filter(([_, count]) => count > 0)
  .map(([role, count]) => ({
    role,
    count: Number(count) || 0,
    percentage: getRolePercentage(Number(count) || 0, stats.totalMembers),
  }));

// Mapeo de roles a nombres completos y colores
interface RoleInfo {
  name: string;
  color: string;
  bgColor: string;
}

// Use the imported ROLES constant instead of redefining it

// Mapeo de colores para las profesiones
const professionColors: Record<string, string> = {
  AL: 'bg-green-500/20 text-green-300',
  HB: 'bg-green-500/20 text-green-300',
  TL: 'bg-pink-500/20 text-pink-300',
  EN: 'bg-purple-500/20 text-purple-300',
  EG: 'bg-blue-500/20 text-blue-300',
  JC: 'bg-yellow-500/20 text-yellow-300',
  BS: 'bg-gray-500/20 text-gray-300',
  IN: 'bg-indigo-500/20 text-indigo-300',
  MN: 'bg-gray-600/20 text-gray-400',
  SK: 'bg-orange-500/20 text-orange-300',
  LW: 'bg-amber-500/20 text-amber-300',
};

// Mapeo de colores para las dificultades
const difficultyColors: Record<string, string> = {
  '10N': 'bg-blue-500/20 text-blue-300',
  '10H': 'bg-blue-700/20 text-blue-400',
  '25N': 'bg-purple-500/20 text-purple-300',
  '25H': 'bg-red-500/20 text-red-300',
};

// Función para obtener el color de fondo basado en la clase del personaje
function getClassColor(className: string): string {
  const classColors: Record<string, string> = {
    Guerrero: 'bg-[#C79C6E]',
    Paladín: 'bg-[#F58CBA]',
    Cazador: 'bg-[#ABD473]',
    Pícaro: 'bg-[#FFF569]',
    Sacerdote: 'bg-[#FFFFFF]',
    'Caballero de la Muerte': 'bg-[#C41F3B]',
    Chamán: 'bg-[#0070DE]',
    Mago: 'bg-[#69CCF0]',
    Brujo: 'bg-[#9482C9]',
    Monje: 'bg-[#00FF96]',
    Druida: 'bg-[#FF7D0A]',
    'Cazador de demonios': 'bg-[#A330C9]',
  };
  return classColors[className] || 'bg-gray-500';
}

// Función para obtener el color de la profesión
function getProfessionColor(profCode: ProfessionCode): string {
  const professionColors = {
    JC: { light: 'bg-yellow-500/20', dark: 'text-yellow-300' },
    BS: { light: 'bg-gray-500/20', dark: 'text-gray-300' },
    EN: { light: 'bg-purple-500/20', dark: 'text-purple-300' },
    EG: { light: 'bg-blue-500/20', dark: 'text-blue-300' },
    LW: { light: 'bg-amber-500/20', dark: 'text-amber-300' },
    AL: { light: 'bg-green-500/20', dark: 'text-green-300' },
    TL: { light: 'bg-pink-500/20', dark: 'text-pink-300' },
    IN: { light: 'bg-indigo-500/20', dark: 'text-indigo-300' },
    HB: { light: 'bg-green-500/20', dark: 'text-green-300' },
    MN: { light: 'bg-gray-600/20', dark: 'text-gray-400' },
    SK: { light: 'bg-orange-500/20', dark: 'text-orange-300' },
  };

  const color = professionColors[profCode] || { light: 'bg-gray-500/20', dark: 'text-gray-400' };
  return `${color.light} ${color.dark}`;
}

// Extend RosterMemberType with additional properties
interface MainAltDistributionItem extends DistributionItem {
  type: 'M' | 'A';
  name: string;
  count: number;
  percentage: number;
  color?: string;
}

// Import types from the types file
import type {
  RosterMember as RosterMemberType,
  PublicNoteValidation as RosterPublicNoteValidation,
  RosterData as BaseRosterData,
  RosterStats,
  ClassName,
  Role,
  MainAlt,
  Member,
  PublicNoteValidation,
} from '../../types/roster';

// Define the default note validation object
const defaultNoteValidation: PublicNoteValidation = {
  isValid: false,
  blocks: [],
  isRaidLeader: false,
  hasSchedule: false,
  hasRaids: false,
};

// Define a type for the roster member with all required properties

// Type guard to check if a member has noteValidation
function hasNoteValidation(
  member: RosterMember
): member is RosterMember & { noteValidation: RosterPublicNoteValidation } {
  return member.noteValidation !== undefined;
}

// Type for the member parameter in array methods
type RosterDataWithRankInfo = Omit<RosterData, 'members' | 'stats' | 'rankInfo'> & {
  members: RosterMember[];
  stats: RosterStats;
  rankInfo: Record<string, { name: string; order: number }>;
  // Add missing properties from RosterData
  classInfo: Record<string, ClassInfo>;
  name: string;
  order: number;
  classes: string[];
  totalMembers: number;
  raids: any[];
  raidDays: Record<string, unknown>;
  raidTimes: Record<string, unknown>;
};

// Calculate main/alt distribution
const calculateMainAltDistribution = (members: Member[]): { M: number; A: number } => {
  const result = { M: 0, A: 0 };

  for (const member of members) {
    const mainAlt = member.noteValidation?.mainAlt || 'A'; // Default to 'A' if not specified
    if (mainAlt === 'M') {
      result.M++;
    } else {
      // Count as Alt if not explicitly marked as Main
      result.A++;
    }
  }

  return result;
};

// ==========================================
// TIPOS Y UTILIDADES
// ==========================================

type ClassName =
  | 'Guerrero'
  | 'Paladín'
  | 'Cazador'
  | 'Pícaro'
  | 'Sacerdote'
  | 'Caballero de la Muerte'
  | 'Chamán'
  | 'Mago'
  | 'Brujo'
  | 'Druida';

// Use imported types from roster.ts

// Validar nota pública según el formato requerido
function validatePublicNote(
  note: string | undefined,
  characterName: string = 'Desconocido',
  officerNote: string = ''
): RosterPublicNoteValidation {
  // Usar la función importada que combina notas públicas y oficiales
  const result = validateRosterNote(note, characterName, officerNote);

  // Crear un objeto con los valores por defecto según la interfaz
  const validated: RosterPublicNoteValidation = {
    isValid: result.isValid || false,
    blocks: result.blocks || [],
    isRaidLeader: result.isRaidLeader || false,
    hasSchedule: result.hasSchedule || false,
    hasRaids: result.hasRaids || false,
    missingFields: result.missingFields || [],
    // Propiedades opcionales
    mainAlt: result.mainAlt,
    role: result.role,
    dualRole: result.dualRole,
    gearScore: result.gearScore,
    professions: result.professions,
    schedules: result.schedules,
    raids: result.raids,
    error: result.error,
  };

  return validated;
}

// Función auxiliar para validar notas (mantener para compatibilidad)
function validateNoteLegacy(
  note: string | undefined,
  characterName: string = 'Desconocido'
): RosterPublicNoteValidation {
  const errors: string[] = [];
  const missingFields: string[] = [];
  const result: RosterPublicNoteValidation & { blocks?: Array<{ type: string; parsedData: any }> } =
    {
      isValid: false,
      blocks: [],
    };

  if (!note?.trim()) {
    return { ...result, error: 'La nota pública no puede estar vacía' };
  }

  const trimmedNote = note.trim();
  const parts = trimmedNote.split(/\s+/); // Dividir por cualquier espacio en blanco

  // 1. Detección de Main/Alt (M/A) - Prioridad a patrones con roles

  // Patrón 1: M o A seguido de rol (ej: 'MT', 'AD', 'MH', 'AH', 'at', 'md')
  const mainAltWithRole = trimmedNote.match(/^([MA])([THD])(?![a-zA-Z])/i);

  // Patrón para notas con gear score (ej: 'AD5.9', 'at5.7')
  const gearScorePattern = trimmedNote.match(/^([MA])([THD])(\d+(?:\.\d+)?)/i);

  // Patrón para notas con profesiones (ej: 'adALHB', 'ad6.6TLBS')
  const professionPattern = trimmedNote.match(/^([MA])([THD])(\d+(?:\.\d+)?)?([A-Za-z]{2,})/i);

  // Patrón para notas de raid (ej: 'AT5.9 M20RLTOC25N')
  const raidPatternMatch = trimmedNote.match(
    /^([MA])([THD])(\d+(?:\.\d+)?)?(?:\s+([A-Za-z0-9]+))?/i
  );

  if (mainAltWithRole || gearScorePattern || professionPattern || raidPatternMatch) {
    // Extraer la información del patrón coincidente
    let mainAlt,
      role,
      gearScore = 0,
      professions = [];
    let raidInfo = null;

    if (mainAltWithRole) {
      mainAlt = mainAltWithRole[1].toUpperCase() as MainAlt;
      role = mainAltWithRole[2].toUpperCase() as Role;
    } else if (gearScorePattern) {
      mainAlt = gearScorePattern[1].toUpperCase() as MainAlt;
      role = gearScorePattern[2].toUpperCase() as Role;
      gearScore = parseFloat(gearScorePattern[3]);
    } else if (professionPattern) {
      mainAlt = professionPattern[1].toUpperCase() as MainAlt;
      role = professionPattern[2].toUpperCase() as Role;
      if (professionPattern[3]) {
        gearScore = parseFloat(professionPattern[3]);
      }
      // Extraer códigos de profesión (2 letras cada uno)
      const profCodes = (professionPattern[4] || '').match(/[A-Za-z]{2}/g) || [];
      professions = profCodes.map((p) => p.toUpperCase() as ProfessionCode);
    } else if (raidPatternMatch) {
      mainAlt = raidPatternMatch[1].toUpperCase() as MainAlt;
      role = raidPatternMatch[2].toUpperCase() as Role;
      if (raidPatternMatch[3]) {
        gearScore = parseFloat(raidPatternMatch[3]);
      }
      // Procesar información de raid si está presente
      if (raidPatternMatch[4]) {
        const raidMatch = raidPatternMatch[4].match(/([A-Za-z]+)(\d+)([NH])?/i);
        if (raidMatch) {
          raidInfo = {
            code: raidMatch[1].toUpperCase(),
            difficulty: raidMatch[3] ? `${raidMatch[2]}${raidMatch[3]}` : undefined,
            isRaidLeader: raidPattern[4].toLowerCase().includes('rl'),
          };
        }
      }
    }

    // Crear el bloque de personaje
    const characterBlock: NoteBlock = {
      type: 'character',
      content: trimmedNote,
      isValid: true,
      parsedData: {
        mainAlt,
        role,
        mainRole: role,
        mainGearScore: gearScore,
        professions: professions,
      },
    };

    // Crear el objeto de resultado
    const validationResult: RosterPublicNoteValidation = {
      isValid: true,
      blocks: [characterBlock],
      mainAlt,
      role,
      mainRole: role,
      gearScore: gearScore,
      professions: professions,
      schedules: [],
      isRaidLeader: raidInfo?.isRaidLeader || false,
      hasSchedule: false,
      missingFields: [],
    };

    // Si es un patrón simple (AD, AT, etc.), marcar como válido y salir
    if (trimmedNote.length === 2 || (gearScore && trimmedNote.length <= 10)) {
      // Asegurarse de que el bloque de personaje tenga toda la información necesaria
      const charBlock: NoteBlock = {
        type: 'character',
        content: trimmedNote,
        isValid: true,
        parsedData: {
          mainAlt,
          role,
          mainRole: role,
          mainGearScore: 0,
          professions: [],
        },
      };

      // Crear el resultado final
      const finalResult: RosterPublicNoteValidation = {
        isValid: true,
        blocks: [charBlock],
        mainAlt,
        role,
        mainRole: role,
        gearScore: 0,
        professions: [],
        schedules: [],
        isRaidLeader: false,
        hasSchedule: false,
        missingFields: [],
      };

      return finalResult;
    }

    // Actualizar el resultado actual
    Object.assign(result, validationResult);
  } else {
    // Si no coincide el primer patrón, intentar con el patrón de dos letras
    const twoLetterPattern = trimmedNote.match(/^([a-zA-Z]{2})(?:\s|$)/i);
    if (twoLetterPattern) {
      const code = twoLetterPattern[1].toUpperCase();

      // Verificar si el código es un patrón de rol (primera letra M/A, segunda T/H/D)
      const roleMatch = code.match(/^([MA])([THD])$/i);
      if (roleMatch) {
        const mainAlt = roleMatch[1].toUpperCase() as MainAlt;
        const role = roleMatch[2].toUpperCase() as Role;

        const charBlock: NoteBlock = {
          type: 'character',
          content: code,
          isValid: true,
          parsedData: {
            mainAlt,
            role,
            mainRole: role,
            mainGearScore: 0,
            professions: [],
          },
        };

        return {
          isValid: true,
          blocks: [charBlock],
          mainAlt,
          role,
          mainRole: role,
          gearScore: 0,
          professions: [],
          schedules: [],
          isRaidLeader: false,
          hasSchedule: false,
          missingFields: [],
        };
      }
    }
  }

  // Patrones adicionales...
  if (!result.role) {
    const twoLetterPattern = trimmedNote.match(/^([a-zA-Z]{2})(?:\s|$)/i);
    if (twoLetterPattern) {
      const [_, code] = twoLetterPattern;
      const upperCode = code.toUpperCase();
      const validRoles = ['T', 'H', 'D'];
      const validMains = ['M', 'A'];

      const firstChar = upperCode[0];
      const secondChar = upperCode[1];

      // Caso 1: Primera letra es M/A y segunda es T/H/D (ej: MT, AD, MH, MD)
      if (validMains.includes(firstChar) && validRoles.includes(secondChar)) {
        result.mainAlt = firstChar as MainAlt;
        result.role = secondChar as Role;
        result.mainRole = secondChar as Role;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              role: result.role,
              mainRole: result.role,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 2: Primera letra es T/H/D y segunda es M/A (ej: TM, HA, DM)
      else if (validRoles.includes(firstChar) && validMains.includes(secondChar)) {
        result.role = firstChar as Role;
        result.mainRole = firstChar as Role;
        result.mainAlt = secondChar as MainAlt;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              role: result.role,
              mainRole: result.role,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 3: Cualquier combinación de dos letras de rol (ej: TH, HD, DT)
      else if (validRoles.includes(firstChar) && validRoles.includes(secondChar)) {
        result.role = firstChar as Role;
        result.mainRole = firstChar as Role;
        result.dualRole = secondChar as Role;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              role: result.role,
              mainRole: result.role,
              dualRole: result.dualRole,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 4: Primera letra es M/A y segunda es M/A (ej: MA, AM)
      else if (validMains.includes(firstChar) && validMains.includes(secondChar)) {
        result.mainAlt = firstChar as MainAlt;
        result.isValid = true;

        // Crear bloque de personaje mínimo
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }

      // Si encontramos un patrón válido de dos letras, asegurar que los campos requeridos estén establecidos
      if (result.isValid) {
        // Asegurar que siempre haya un valor para mainRole
        result.mainRole = result.mainRole || result.role;
        return result;
      }
    }
  }

  // Patrón 2: M o A al inicio de la nota (ej: 'M 5.9', 'A TL/EN', 'a')
  if (!result.mainAlt) {
    const startWithMainAlt = trimmedNote.match(/^([MA])(?:\s+|$)/i);
    if (startWithMainAlt) {
      result.mainAlt = startWithMainAlt[1].toUpperCase() as MainAlt;

      // Si es solo 'a' o 'm', marcar como válido
      if (trimmedNote.match(/^[ma]$/i)) {
        result.isValid = true;
      }
    }
  }

  // Patrón 3: M o A con separador (ej: 'M/Tank', 'A-Healer')
  if (!result.mainAlt) {
    const mainAltWithSeparator = trimmedNote.match(/(?:^|[\s/\-|])([MA])(?=$|[\s/\-|])/i);
    if (mainAltWithSeparator) {
      result.mainAlt = mainAltWithSeparator[1].toUpperCase() as MainAlt;
    }
  }

  // Patrón 4: M o A en cualquier parte como palabra completa (último recurso)
  if (!result.mainAlt) {
    const mainAltAnywhere = trimmedNote.match(/(?:^|\s)([MA])(?:\s|$)/i);
    if (mainAltAnywhere) {
      result.mainAlt = mainAltAnywhere[1].toUpperCase() as MainAlt;
    }
  }

  // 2. Buscar si es Raid Leader (RL o rl)
  // Primero buscar el formato específico '20:00xRLICC25N' o similar
  result.isRaidLeader = /\d{1,2}[:.]?\d{0,2}xRL/.test(trimmedNote);

  // Si no se encontró, buscar otros patrones comunes
  if (!result.isRaidLeader) {
    // Buscar patrones como 'RL', 'rl', 'RaidLeader', 'raid leader', etc.
    result.isRaidLeader = /(?:^|\s|\d*[xX]?\s*)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl)\b/i.test(
      trimmedNote
    );
  }

  // 3. Buscar roles (T, H, D) y rol dual
  // Primero buscar formato de rol con GS (ej: d5.8, t6.2, D5.8, T6.2)
  const roleWithGS = trimmedNote.match(/^([thdTHD])(\d\.?\d?\d?)$/);
  if (roleWithGS && !result.role) {
    result.role = roleWithGS[1].toUpperCase() as Role;
    result.gearScore = roleWithGS[2];
    result.isValid = true;
  }

  // Buscar formato de 3 letras que comience con A o M (ej: MDT, AHT, etc.)
  const threeLetterRoleMatch = trimmedNote.match(/\b([MA]?)([THD])([THD]?)\b/i);

  if (threeLetterRoleMatch) {
    const [, mainAlt, primaryRole, dualRole] = threeLetterRoleMatch;

    // Si hay un prefijo M o A, establecer mainAlt
    if (mainAlt) {
      result.mainAlt = mainAlt.toUpperCase() as MainAlt;
    } else if (!result.mainAlt && threeLetterRoleMatch[0].startsWith('M')) {
      // Si no hay mainAlt pero el match empieza con M, asumir que es Main
      result.mainAlt = 'M';
    }

    // Establecer rol principal
    result.role = primaryRole.toUpperCase() as Role;

    // Si hay un rol dual, establecerlo
    if (dualRole) {
      const dual = dualRole.toUpperCase() as Role;
      if (dual !== result.role) {
        result.dualRole = dual;
      } else {
        errors.push('El rol secundario no puede ser igual al principal');
      }
    }
  }

  // Si no se encontró un rol dual, buscar cualquier otro rol en la nota
  if (!result.dualRole) {
    // Buscar cualquier letra T, H o D que no sea parte de otra palabra
    const roleMatches = [...trimmedNote.matchAll(/\b([THD])\b/gi)];
    const roles = Array.from(new Set(roleMatches.map((m) => m[1].toUpperCase())));

    // Si hay más de un rol, establecer el segundo como dual
    if (roles.length > 1) {
      const primary = result.role || roles[0];
      const secondary = roles.find((r) => r !== primary) as Role;

      if (secondary) {
        if (!result.role) result.role = primary as Role;
        result.dualRole = secondary;
      }
    } else if (roles.length === 1 && !result.role) {
      // Si solo hay un rol y no se ha establecido, usarlo como principal
      result.role = roles[0] as Role;
    }
  }

  // Si aún no se ha encontrado un rol, buscar en otros formatos
  if (!result.role) {
    // Último intento: buscar cualquier combinación de roles (ej: TH, HD, DT, etc.)
    const dualRoleMatch = trimmedNote.match(/\b([THD]{2,})\b/i);
    if (dualRoleMatch) {
      const rolesStr = dualRoleMatch[1].toUpperCase();
      result.role = rolesStr[0] as Role;
      if (rolesStr.length > 1 && rolesStr[1] !== rolesStr[0]) {
        result.dualRole = rolesStr[1] as Role;
      }
    }
  }

  if (!result.role) {
    missingFields.push(`Rol principal (${Object.keys(ROLES).join(', ')})`);
  }

  // 2. Extraer Gear Score - Múltiples formatos soportados:
  //    - Números de 4 dígitos (ej: 5585 -> 5.5)
  //    - Números decimales con punto o coma (ej: 5.9, 6,2)
  //    - Números después de rol (ej: d5.8, t6.2)
  //    - Números rodeados de cualquier carácter
  //    - Prefijos comunes como 'GS', 'gs', 'ilvl', 'iLvl', etc.
  let gsValue: string | null = null;

  // Patrón 1: Buscar formato XXXX (4 dígitos) en cualquier parte
  const fourDigitMatch = trimmedNote.match(/\b(\d{4})\b/);
  if (fourDigitMatch) {
    const num = parseInt(fourDigitMatch[1]);
    gsValue = (num / 1000).toFixed(1);
  }
  // Patrón 2: Buscar números decimales con punto o coma
  else {
    const decimalMatch = trimmedNote.match(/(\d[\.,]\d\d?)/);
    if (decimalMatch) {
      gsValue = decimalMatch[1].replace(',', '.');
    }
  }

  // Patrón 3: Buscar después de prefijos comunes (GS, ilvl, etc.)
  if (!gsValue) {
    const prefixMatch = trimmedNote.match(
      /(?:GS|gs|ilvl|iLvl|gear|Gear|gs:?\s*)(?:\s*[:=]?\s*)(\d[\.,]?\d?\d?)/i
    );
    if (prefixMatch) {
      gsValue = prefixMatch[1].replace(',', '.');
      // Asegurar formato decimal correcto
      if (!gsValue.includes('.')) {
        gsValue = gsValue + '.0';
      }
    }
  }

  // Validar y guardar el Gear Score encontrado
  if (gsValue) {
    const gsNumber = parseFloat(gsValue);
    if (!isNaN(gsNumber) && gsNumber >= 0.1 && gsNumber <= 10) {
      result.gearScore = gsNumber.toFixed(1);
    } else {
      errors.push('El Gear Score debe estar entre 0.1 y 10');
    }
  } else if (!trimmedNote.match(/GS|gs|ilvl|iLvl|gear|Gear|\d[\.,]\d|\d{4}/i)) {
    // Solo marcar como faltante si no hay ningún indicio de GS en la nota
    missingFields.push('Gear Score (ej: 5.9, 6.2, 5585)');
  }

  // 3. Extraer días de la semana (formato L-V, LMXJV, etc.)
  const dayPattern = /([LMXJVSD])(?:-([LMXJVSD]))?/g;
  const daysSet = new Set<string>();
  let dayMatch;

  while ((dayMatch = dayPattern.exec(trimmedNote)) !== null) {
    const startDay = dayMatch[1];
    const endDay = dayMatch[2];

    if (endDay) {
      // Es un rango de días (ej: L-V)
      const dayOrder = ['L', 'M', 'X', 'J', 'V', 'S', 'D'];
      const startIndex = dayOrder.indexOf(startDay);
      const endIndex = dayOrder.indexOf(endDay);

      if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {
        for (let i = startIndex; i <= endIndex; i++) {
          daysSet.add(dayOrder[i]);
        }
      } else {
        // Si el rango no es válido, agregar solo los días individuales
        daysSet.add(startDay);
        daysSet.add(endDay);
      }
    } else {
      // Es un día individual
      daysSet.add(startDay);
    }
  }

  // Convertir a array y ordenar según el orden de la semana
  const daysArray = Array.from(daysSet).sort((a, b) => {
    const order = { L: 1, M: 2, X: 3, J: 4, V: 5, S: 6, D: 7 };
    return (order[a as keyof typeof order] || 0) - (order[b as keyof typeof order] || 0);
  });

  // Agregar los días al resultado
  if (daysArray.length > 0) {
    result.days = daysArray;
  }

  // 4. Extraer Profesiones - Opcionales pero recomendadas
  const profCodes = Object.keys(PROFESSIONS);
  const profCodesStr = profCodes.join('|');

  const foundProfs = new Set<string>();

  // Caso especial para 'ALMN' (Alquimia + Minería)
  if (trimmedNote.includes('ALMN')) {
    foundProfs.add('AL');
    foundProfs.add('MN');
  } else {
    // Búsqueda normal de códigos de profesión
    const singleProfRegex = new RegExp(
      `(?:^|[^a-zA-Z])(${profCodesStr})(?![a-zA-Z])|(${profCodesStr})$`,
      'gi'
    );
    let singleMatch;

    singleProfRegex.lastIndex = 0;

    while ((singleMatch = singleProfRegex.exec(trimmedNote)) !== null) {
      const code = (singleMatch[1] || singleMatch[2]).toUpperCase() as ProfessionCode;

      if (profCodes.includes(code) && !foundProfs.has(code)) {
        foundProfs.add(code);
        if (foundProfs.size >= 2) break;
      }
    }
  }

  // Si no encontramos códigos individuales, buscar códigos juntos sin separador
  if (foundProfs.size < 2) {
    const combinedProfRegex = /[A-Z]{4,6}/g;
    let combinedMatch;

    while ((combinedMatch = combinedProfRegex.exec(trimmedNote.toUpperCase())) !== null) {
      const combinedText = combinedMatch[0];

      // Buscar códigos de profesión dentro del texto combinado
      let index = 0;
      while (index < combinedText.length) {
        let found = false;

        // Probar con códigos de 2 caracteres primero (más comunes)
        if (index + 2 <= combinedText.length) {
          const possibleCode = combinedText.substring(index, index + 2);
          if (profCodes.includes(possibleCode) && !foundProfs.has(possibleCode)) {
            foundProfs.add(possibleCode as ProfessionCode);
            index += 2;
            found = true;
          }
        }

        // Si no se encontró un código de 2 caracteres, probar con 3
        if (!found && index + 3 <= combinedText.length) {
          const possibleCode = combinedText.substring(index, index + 3);
          if (profCodes.includes(possibleCode) && !foundProfs.has(possibleCode)) {
            foundProfs.add(possibleCode as ProfessionCode);
            index += 3;
            found = true;
          }
        }

        // Si no se encontró ningún código, avanzar un carácter
        if (!found) {
          index++;
        }

        // No buscar más de 2 profesiones (máximo razonable)
        if (foundProfs.size >= 2) break;
      }

      // Si ya encontramos 2 profesiones, no es necesario seguir buscando
      if (foundProfs.size >= 2) break;
    }
  }

  // Si no encontramos códigos juntos, buscar otros patrones
  if (foundProfs.size < 2) {
    // Patrón 2: Buscar el patrón específico 'TL/en' o similar
    const directProfRegex = new RegExp(
      `(?:^|[^a-zA-Z])(${profCodesStr})[/,\s-](${profCodesStr})(?![a-zA-Z])`,
      'gi'
    );
    let directMatch;

    while ((directMatch = directProfRegex.exec(trimmedNote)) !== null) {
      const code1 = directMatch[1].toUpperCase() as ProfessionCode;
      const code2 = directMatch[2].toUpperCase() as ProfessionCode;
      if (profCodes.includes(code1)) foundProfs.add(code1);
      if (profCodes.includes(code2)) foundProfs.add(code2);
      if (foundProfs.size >= 2) break;
    }

    // Patrón 3: Buscar códigos individuales
    if (foundProfs.size < 2) {
      const singleProfRegex = new RegExp(`(?:^|[^a-zA-Z])(${profCodesStr})(?![a-zA-Z])`, 'gi');
      let singleMatch;

      while ((singleMatch = singleProfRegex.exec(trimmedNote)) !== null) {
        const code = singleMatch[1].toUpperCase() as ProfessionCode;
        if (profCodes.includes(code)) {
          foundProfs.add(code);
          if (foundProfs.size >= 2) break;
        }
      }
    }
  }

  // Si encontramos al menos una profesión, actualizar el resultado
  if (foundProfs.size > 0) {
    // Guardamos los códigos de profesión directamente
    result.professions = Array.from(foundProfs);

    // Si solo hay una profesión y es una abreviatura de 2 letras (ej: 'EN'), marcar como válido
    if (foundProfs.size === 1 && Array.from(foundProfs)[0].length === 2) {
      result.isValid = true;
    }
  }

  // La extracción de días ya se realizó anteriormente en la sección 3 del código
  // y ya está disponible en result.days

  // 5. Extraer horarios (pueden ser individuales o rangos con formato HHX-HHX)
  const uniqueHours = new Set<string>();

  // Primero buscamos rangos de días con horario (ej: L-V20:00x, L-V20:00, L-V20x, etc.)
  const dayRangeWithTimeRegex = /([LMXJVS])(?:-([LMXJVS]))?(\d{1,2}:?\d{0,2})X?/gi;
  let dayRangeMatch;

  // Buscar rangos de días con horario
  while ((dayRangeMatch = dayRangeWithTimeRegex.exec(trimmedNote)) !== null) {
    const startDay = dayRangeMatch[1];
    const endDay = dayRangeMatch[2] || startDay; // Si no hay día final, usamos el día inicial
    const timePart = dayRangeMatch[3] || '';

    // Formatear la hora correctamente
    let formattedTime = '';
    if (timePart.includes(':')) {
      const [hours, minutes = '00'] = timePart.split(':');
      formattedTime = `${hours.padStart(2, '0')}:${minutes.padEnd(2, '0')}`;
    } else if (timePart) {
      formattedTime = `${timePart.padStart(2, '0')}:00`;
    }

    if (formattedTime) {
      // Si hay un rango de días (ej: L-V)
      if (startDay && endDay && startDay !== endDay) {
        uniqueHours.add(`${startDay}-${endDay} ${formattedTime}`);
      } else {
        // Si es un solo día (ej: L20:00)
        uniqueHours.add(`${startDay} ${formattedTime}`);
      }
    }
  }

  // Luego buscamos rangos de horas (ej: 20X-23X, 20-23X, 20X-23, 20-23)
  const rangeRegex =
    /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X?\s*-\s*(\d{1,2})(?::(\d{2}))?X(?:$|[^\d])/gi;
  const rangeMatches = [];
  let rangeMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((rangeMatch = rangeRegex.exec(trimmedNote)) !== null) {
    rangeMatches.push(rangeMatch);
  }

  // Procesar rangos de horas (ej: 20X-23X, 20-23X, 20X-23, 20-23)
  rangeMatches.forEach((match) => {
    const startHour = parseInt(match[1], 10);
    const startMinutes = match[2] ? parseInt(match[2], 10) : 0;
    const endHour = parseInt(match[3], 10);
    const endMinutes = match[4] ? parseInt(match[4], 10) : 0;

    // Validar que las horas y minutos estén en rango
    if (
      startHour >= 0 &&
      startHour <= 23 &&
      endHour >= 0 &&
      endHour <= 23 &&
      startMinutes >= 0 &&
      startMinutes <= 59 &&
      endMinutes >= 0 &&
      endMinutes <= 59
    ) {
      const formattedStart = `${startHour.toString().padStart(2, '0')}${startMinutes > 0 ? ':' + startMinutes.toString().padStart(2, '0') : ''}X`;
      const formattedEnd = `${endHour.toString().padStart(2, '0')}${endMinutes > 0 ? ':' + endMinutes.toString().padStart(2, '0') : ''}X`;

      uniqueHours.add(formattedStart);
      uniqueHours.add(formattedEnd);
    }
  });

  // Luego buscamos horas individuales (que no sean parte de un rango)
  // Ahora detecta con o sin espacios alrededor de la X, pero evita falsos positivos
  const hourRegex = /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X(?:$|[^\d-])/gi;
  const hourMatches = [];
  let hourMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((hourMatch = hourRegex.exec(trimmedNote)) !== null) {
    hourMatches.push(hourMatch);
  }

  hourMatches.forEach((match) => {
    const hour = parseInt(match[1], 10);
    const minutes = match[2] ? parseInt(match[2], 10) : 0;

    if (hour >= 0 && hour <= 23 && minutes >= 0 && minutes <= 59) {
      const formattedHour = hour.toString().padStart(2, '0');
      const formattedMinutes = minutes > 0 ? `:${minutes.toString().padStart(2, '0')}` : '';
      uniqueHours.add(`${formattedHour}${formattedMinutes}X`);
    }
  });

  if (uniqueHours.size > 0) {
    result.schedules = Array.from(uniqueHours).sort();
  } else if (!trimmedNote.match(/\d{1,2}(?::\d{2})?X/)) {
    // Solo agregar el mensaje si no hay ningún formato de horario en la nota
    missingFields.push('Horario de conexión (ej: 18X, 21:30X)');
  }

  // 5. Extraer raids y dificultades por separado
  const allRaidCodes = Object.keys(RAID_NAMES) as RaidCode[];
  const raidCodesPattern = allRaidCodes
    .map((rc) => rc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join('|');

  // Inicializar el conjunto de raids encontradas
  result.raids = [];
  const usedRaids = new Set<string>();
  const usedIndices = new Set<string>();

  // 1. Buscar menciones directas de raids
  const raidPattern = new RegExp(`\\b(${raidCodesPattern})\\b`, 'gi');
  let raidMatch;

  while ((raidMatch = raidPattern.exec(trimmedNote)) !== null) {
    const raidCode = raidMatch[1].toUpperCase();

    if (raidCode in RAID_NAMES && !usedRaids.has(raidCode)) {
      result.raids.push({
        code: raidCode as RaidCode,
        difficultyCode: undefined, // Sin dificultad específica
        difficulty: undefined,
        name: RAID_NAMES[raidCode as RaidCode],
      });
      usedRaids.add(raidCode);
    }
  }

  // 2. Buscar dificultades (10n, 25h, etc.)
  const difficultyPattern = /\b(10|25)([hn])\b/gi;
  const foundDifficulties = new Set<string>();
  let diffMatch;

  while ((diffMatch = difficultyPattern.exec(trimmedNote)) !== null) {
    const number = diffMatch[1];
    const difficulty = diffMatch[2].toUpperCase() as 'N' | 'H';
    const difficultyCode = `${number}${difficulty}` as DifficultyCode;
    foundDifficulties.add(difficultyCode);
  }

  // Si no encontramos raids con los patrones anteriores, buscar solo los códigos de raid
  if (result.raids.length === 0) {
    const raidCodePattern = new RegExp(
      `(?:^|[^a-zA-Z])(${raidCodesPattern})(?=$|[^a-zA-Z0-9])`,
      'gi'
    );
    const raidCodeMatches = Array.from(trimmedNote.matchAll(raidCodePattern));

    for (const match of raidCodeMatches) {
      const raidCodeStr = match[0].toUpperCase();
      // Verificar que el código de raid sea uno de los permitidos
      const validRaidCodes: RaidCode[] = [
        'ICC',
        'TOC',
        'ULD',
        'NAX',
        'OS',
        'VOA',
        'EOE',
        'ONY',
        'RS',
      ];
      if (validRaidCodes.includes(raidCodeStr as RaidCode)) {
        const raidCode = raidCodeStr as RaidCode;
        if (!usedRaids.has(raidCode)) {
          // Buscar el raid en el array RAIDS
          const raidInfo = RAIDS.find((r) => r.code === raidCode);
          const raidName = raidInfo ? raidInfo.name : raidCode;

          const raidData: RaidInfo = {
            code: raidCode,
            difficulty: 'Normal', // Valor por defecto
            name: raidName,
            difficultyCode: '10N' as DifficultyCode, // Valor por defecto
            isRaidLeader: false, // Propiedad opcional
          };
          result.raids.push(raidData);
          usedRaids.add(raidCode);
        }
      }
    }
  }

  // Si no encontramos raids aún, intentar con un patrón más flexible
  if (result.raids.length === 0) {
    const escapedRaidCodes = allRaidCodes
      .map((raid) => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
      .join('|');
    const raidPatterns = [
      // Patrón para 'icc10n' o 'voa25h' (sin espacios)
      new RegExp(`(${escapedRaidCodes})(\\d+)([NH])`, 'gi'),
      // Patrón para 'icc 10n' o 'voa 25h' (con espacios)
      new RegExp(`(${escapedRaidCodes})\\s*(\\d+)([NH])`, 'gi'),
      // Patrón para solo el código de raid
      new RegExp(`\\b(${escapedRaidCodes})\\b`, 'gi'),
    ];

    for (const pattern of raidPatterns) {
      let match;
      while ((match = pattern.exec(trimmedNote)) !== null) {
        const raidCode = match[1]?.toUpperCase() as RaidCode;
        if (!raidCode) continue;

        // Type assertion to handle the indexing
        const raidName = raidCode in RAIDS ? RAIDS[raidCode as keyof typeof RAIDS] : raidCode;

        // Si es un patrón con dificultad (ej: 'icc10n' o 'icc 10n')
        if (match[2] && match[3]) {
          const difficultyNumber = match[2];
          const difficultyLetter = match[3].toUpperCase();
          const difficultyCode = `${difficultyNumber}${difficultyLetter}` as DifficultyCode;

          if (['10N', '10H', '25N', '25H'].includes(difficultyCode)) {
            const raidKey = `${raidCode}${difficultyCode}`;
            if (!usedRaids.has(raidKey)) {
              result.raids.push({
                code: raidCode,
                difficultyCode,
                difficulty: difficultyLetter === 'N' ? 'Normal' : 'Heroic',
                name: raidName,
              });
              usedRaids.add(raidKey);
            }
          }
        } else if (!usedRaids.has(raidCode)) {
          // Si es solo el código de raid sin dificultad
          result.raids.push({
            code: raidCode,
            difficultyCode: undefined,
            difficulty: undefined,
            name: raidName,
          });
          usedRaids.add(raidCode);
        }

        if (match.index === pattern.lastIndex) {
          pattern.lastIndex++; // Evitar bucle infinito
        }
      }
    }
  }

  // Verificar si faltan raids o su dificultad (solo como advertencia, no invalida)
  if (result.raids.length === 0) {
    // Verificar si hay algún código de raid sin dificultad
    const raidPatterns = [
      // Patrones para detectar menciones de raid con o sin dificultad
      new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodesPattern})(?![a-z0-9])(?:$|\\s|\\)|\\]|\/)`, 'i'),
      new RegExp(`(${raidCodesPattern})\\s*\\d+[NH]`, 'i'),
      new RegExp(`(${raidCodesPattern})\\d+[NH]`, 'i'),
      new RegExp(`(10|25)[NH](${raidCodesPattern})`, 'i'), // Para formato 10Nicc, 25Hvoa
    ];

    const hasAnyRaidMention = raidPatterns.some((pattern) => pattern.test(trimmedNote));
    const hasRaidWithDifficulty = new RegExp(
      `(?:${raidCodesPattern})(?:\\s*\\d+[NH]|\\d+[NH]|(?:10|25)[NH](?=${raidCodesPattern}))`,
      'i'
    ).test(trimmedNote);

    if (hasAnyRaidMention && !hasRaidWithDifficulty) {
      // Solo agregar el mensaje de dificultad faltante si no está ya en el array
      if (!missingFields.some((mf) => mf.includes('Dificultad'))) {
        missingFields.push('Dificultad (ej: 10N, 25H)');
      }
    } else if (!hasAnyRaidMention) {
      // Verificar si hay menciones de raid en el texto sin formato específico
      const raidMentionPattern = new RegExp(
        `(?:^|\\s|\\(|\\[)(${allRaidCodes.join('|')})(?=$|[^a-zA-Z0-9])`,
        'i'
      );
      if (!raidMentionPattern.test(trimmedNote)) {
        missingFields.push('Raids que busca/arma (ej: ICC, TOC)');
      }
    }
  } else if (result.raids.some((raid) => !raid.difficultyCode)) {
    // Verificar si hay alguna mención de dificultad en la nota
    const hasDifficultyMention = /(?:^|\s)(\d+[NH])(?:\s|$)/i.test(trimmedNote);
    if (!hasDifficultyMention && !missingFields.some((mf) => mf.includes('Dificultad'))) {
      missingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 6. Verificar campos faltantes en el orden especificado
  const orderedMissingFields: string[] = [];

  // 1. Main/Alt
  if (!result.mainAlt) {
    orderedMissingFields.push('Main/Alt (M/A)');
  }

  // 2. Rol principal
  if (!result.role) {
    orderedMissingFields.push('Rol (T/H/D)');
  }

  // 3. Dual - Solo mostrar si no se ha detectado un rol dual
  if (!result.dualRole) {
    orderedMissingFields.push('Dual (T/H/D)');
  }

  // 4. Gear Score
  if (!result.gearScore) {
    orderedMissingFields.push('Gear Score (ej: 6.2)');
  }

  // 5. Profesiones
  if (!result.professions || result.professions.length === 0) {
    orderedMissingFields.push('Profesiones (ej: JC/BS)');
  }

  // 6. Horario de juego
  if (!result.schedules || result.schedules.length === 0) {
    orderedMissingFields.push('Horario de juego (ej: 18X, 21:30X)');
  }

  // 7. Verificar raids en la nota
  const raidCodes = Object.keys(RAID_NAMES)
    .map((raid) => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join('|');

  // Buscar cualquier mención de raid, con o sin dificultad
  const raidSearchPattern = new RegExp(
    `(?:^|\\s|\\(|\\[)(${raidCodes})(?![a-z0-9])(?:$|\\s|\\)|\\]|\\/|\\d|\\s*\\d*[NH])`,
    'i'
  );
  const hasAnyRaid = raidSearchPattern.test(trimmedNote);

  // Buscar específicamente patrones como 'icc10n' o 'voa25h'
  const raidWithNumberPattern = new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodes})\\s*\\d+[NH]`, 'i');
  const hasAnyRaidWithNumber = raidWithNumberPattern.test(trimmedNote);

  if (!hasAnyRaid && !hasAnyRaidWithNumber) {
    orderedMissingFields.push('Raids que busca (ej: ICC 25H)');
  } else if (!result.raids || result.raids.length === 0) {
    // Si no se detectaron raids pero hay menciones de raids con números, asumir que el formato es correcto
    if (!hasAnyRaidWithNumber) {
      orderedMissingFields.push('Formato de raid (ej: ICC 25H)');
    }
  } else {
    // Verificar dificultad para cada raid
    const raidsWithoutDifficulty = result.raids.filter((raid) => !raid.difficultyCode);
    if (raidsWithoutDifficulty.length > 0 && !hasAnyRaidWithNumber) {
      orderedMissingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 8. Raid Leader (opcional, solo si se especifica RL pero no está marcado)
  const hasRLNotation = /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl|\d*[xX]\s*rl)\b/i.test(
    trimmedNote
  );
  if (hasRLNotation && !result.isRaidLeader) {
    // Verificar si el formato es válido pero no se pudo marcar
    orderedMissingFields.push(
      'RaidLeader (RL) - Verificar formato (ej: RL, rl, RaidLeader, 18xrl)'
    );
  }

  // 2. Rol principal
  if (!result.role) {
    orderedMissingFields.push('Rol (T/H/D)');
  }

  // 3. Dual - Solo mostrar si no se ha detectado un rol dual
  if (!result.dualRole) {
    orderedMissingFields.push('Dual (T/H/D)');
  }

  // 4. Gear Score
  if (!result.gearScore) {
    orderedMissingFields.push('Gear Score (ej: 6.2)');
  }

  // 5. Profesiones
  if (!result.professions || result.professions.length === 0) {
    orderedMissingFields.push('Profesiones (ej: JC/BS)');
  }

  // 6. Horario de juego
  if (!result.schedules || result.schedules.length === 0) {
    orderedMissingFields.push('Horario de juego (ej: 18X, 21:30X)');
  }

  // 8. Raid Leader (opcional, solo si se especifica RL pero no está marcado)
  const hasRLNotationFlag =
    /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl|\d*[xX]\s*rl)\b/i.test(trimmedNote);
  if (hasRLNotationFlag && !result.isRaidLeader) {
    // Verificar si el formato es válido pero no se pudo marcar
    orderedMissingFields.push(
      'RaidLeader (RL) - Verificar formato (ej: RL, rl, RaidLeader, 18xrl)'
    );
  }

  // Agregar cualquier otro campo faltante que no esté en la lista ordenada
  const otherMissingFields = missingFields.filter(
    (field: string) =>
      !orderedMissingFields.some((omf: string) => field.includes(omf.split(' ')[0]))
  );

  // Combinar los campos ordenados con los demás campos faltantes
  const allMissingFields = [...orderedMissingFields, ...otherMissingFields];
  const missingFieldsSet = new Set(allMissingFields);

  // Actualizar el array de missingFields
  result.missingFields = Array.from(missingFieldsSet);

  // Determinar si la nota es válida
  // Verificar si es un formato simple (MT, MTH, MD, etc.)
  const isSimpleFormat =
    /^[MA]?[THD]+$/i.test(trimmedNote) ||
    /^[MA]$/i.test(trimmedNote) ||
    /^[MA][THD]$/i.test(trimmedNote) ||
    /^[THD][MA]$/i.test(trimmedNote) ||
    /^[THD]$/i.test(trimmedNote) ||
    /^[MA]\d+\.?\d*[THD]?$/i.test(trimmedNote) ||
    /^[MA]\d+\.?\d*[A-Za-z]+$/i.test(trimmedNote);

  // Debug: Log simple format detection
  console.group('Simple format detection');
  console.log('Note:', trimmedNote);
  console.log('Is simple format:', isSimpleFormat);
  if (isSimpleFormat) {
    console.log('Matched as simple format');
  } else {
    console.log('Did not match any simple format pattern');
  }
  console.groupEnd();
  // 4. Tiene profesiones
  // 5. Tiene raids
  // 6. Tiene un gear score
  // 7. Es solo 'A' o 'M' (main/alt sin rol)
  const hasAnyValidField =
    isSimpleFormat ||
    result.role !== undefined ||
    result.mainAlt !== undefined ||
    (result.professions && result.professions.length > 0) ||
    (result.raids && result.raids.length > 0) ||
    (result.schedules && result.schedules.length > 0) ||
    (result.gearScore !== undefined && result.gearScore !== null) ||
    /^[MA]$/i.test(trimmedNote);

  // Debug: Log validation criteria
  console.group('Validation criteria');
  console.log('isSimpleFormat:', isSimpleFormat);
  console.log('result.role:', result.role);
  console.log('result.mainAlt:', result.mainAlt);
  console.log('result.professions:', result.professions);
  console.log('result.raids:', result.raids);
  console.log('result.schedules:', result.schedules);
  console.log('result.gearScore:', result.gearScore);
  console.log("Matches 'A' or 'M':", /^[MA]$/i.test(trimmedNote));
  console.log('hasAnyValidField:', hasAnyValidField);
  console.groupEnd();

  // Establecer el estado de validación
  result.isValid = hasAnyValidField;

  // Si no es válido, agregar un mensaje de error
  if (!result.isValid) {
    errors.push('Formato inválido - No se detectaron campos válidos');
  } else {
    // Limpiar errores si la nota es válida
    errors.length = 0;
  }

  // Asegurarse de que los campos principales estén definidos para formatos simples
  if (isSimpleFormat) {
    // Extraer main/alt si está presente
    const mainAltMatch = trimmedNote.match(/^([MA])/i);
    if (mainAltMatch && !result.mainAlt) {
      result.mainAlt = mainAltMatch[1].toUpperCase() as MainAlt;
    }

    // Extraer rol si está presente
    const roleMatch = trimmedNote.match(/[THD]$/i) || trimmedNote.match(/^[THD]/i);
    if (roleMatch && !result.role) {
      result.role = roleMatch[0].toUpperCase() as Role;
    }

    // Extraer gear score si está presente (formato como AT5.9, ad5.5, etc.)
    const gsMatch = trimmedNote.match(/[MA](\d+(?:\.\d+)?)/i);
    if (gsMatch && !result.gearScore) {
      result.gearScore = parseFloat(gsMatch[1]);
    }

    // Extraer profesiones si están presentes (letras mayúsculas después del gear score)
    const profMatch = trimmedNote.match(/[MA]\d*(?:\.\d+)?([A-Z]{2,})/i);
    if (profMatch && (!result.professions || result.professions.length === 0)) {
      const profs = profMatch[1].match(/[A-Z]{2}/g) || [];
      result.professions = profs.map((p) => p.toUpperCase() as ProfessionCode);
    }
  }

  // Si hay errores, agregarlos al resultado
  if (errors.length > 0) {
    result.error = errors.join('; ');
  }

  // Si faltan campos, agregarlos al resultado
  if (missingFields.length > 0) {
    result.missingFields = [...new Set(missingFields)]; // Eliminar duplicados
  }

  // Procesar bloques de personaje
  if (result.mainAlt || result.role || result.gearScore) {
    result.blocks = result.blocks || [];

    // Asegurarnos de que los valores requeridos no sean undefined
    const mainAlt = result.mainAlt || 'M'; // Valor por defecto 'M' si no está definido
    const mainRole = result.role || 'D'; // Valor por defecto 'D' si no está definido
    const gearScore = result.gearScore ? Number(result.gearScore) : 0;

    // Crear bloque de personaje con tipos seguros
    const characterData = {
      type: 'character' as const,
      content: '',
      isValid: true,
      parsedData: {
        mainAlt: mainAlt as MainAlt,
        mainRole: mainRole as Role,
        dualRole: result.dualRole as Role | undefined,
        mainGearScore: gearScore,
        professions: (result.professions || []) as ProfessionCode[],
        dualGearScore: undefined,
      },
    };

    result.blocks.push(characterData);
  }

  // Procesar bloques de evento
  if (result.raids && result.raids.length > 0) {
    result.blocks = result.blocks || [];

    result.raids.forEach((raid) => {
      // Crear bloque de evento con valores por defecto
      const eventData = {
        type: 'event' as const,
        content: '',
        isValid: true,
        parsedData: {
          days: [] as string[],
          dayRange: '',
          time: '',
          raid: raid.code as RaidCode,
          difficulty: raid.difficultyCode as DifficultyCode,
          isRaidLeader: false,
          isLookingForGroup: false,
        },
      };

      // Si hay información de horario, intentar extraer días y hora
      if (result.schedules && result.schedules.length > 0) {
        const schedule = result.schedules[0];
        // Verificar si el horario incluye un rango de días (ej: L-V 20:00)
        const dayRangeMatch = String(schedule).match(
          /^([LMXJVS])-([LMXJVS])\s+(\d{1,2}:?\d{0,2})/i
        );
        const singleDayMatch = String(schedule).match(/^([LMXJVS])\s+(\d{1,2}:?\d{0,2})/i);

        if (dayRangeMatch) {
          // Formato: L-V 20:00
          const [, startDay, endDay, timePart] = dayRangeMatch;
          eventData.parsedData.dayRange = `${startDay}-${endDay}`;
          eventData.parsedData.time = timePart.includes(':') ? timePart : `${timePart}:00`;
        } else if (singleDayMatch) {
          // Formato: L 20:00
          const [, day, timePart] = singleDayMatch;
          eventData.parsedData.days = [day];
          eventData.parsedData.time = timePart.includes(':') ? timePart : `${timePart}:00`;
        } else if (schedule) {
          // Formato antiguo o diferente
          eventData.parsedData.time = String(schedule);
        }
      }

      // Verificar si es raid leader (RL al inicio del código de raid)
      if (raid.code && String(raid.code).startsWith('RL')) {
        eventData.parsedData.isRaidLeader = true;
        eventData.parsedData.raid = String(raid.code).substring(2) as RaidCode;
      }

      result.blocks.push(eventData);
    });
  }

  // Asegurar que los campos principales estén definidos
  const finalResult = {
    ...result,
    // Asegurar que mainRole esté definido para compatibilidad
    mainRole: result.role,
    // Asegurar que los campos principales tengan valores por defecto si faltan
    mainAlt: result.mainAlt || 'M',
    role: result.role || 'D',
    // Limpiar campos faltantes si es válido
    missingFields: result.isValid ? [] : result.missingFields,
    // Asegurar que los arrays estén definidos
    professions: result.professions || [],
    schedules: result.schedules || [],
    raids: result.raids || [],
    // Depuración
    _debug: {
      originalNote: note,
      trimmedNote,
      isValid: result.isValid,
    },
  };

  // Debug logging for validation results
  console.group(`Validation for note: "${note}"`);
  console.log('Trimmed note:', trimmedNote);
  console.log('Is simple format:', isSimpleFormat);
  console.log('Has any valid field:', hasAnyValidField);
  console.log('Main/Alt:', result.mainAlt);
  console.log('Role:', result.role);
  console.log('Gear Score:', result.gearScore);
  console.log('Professions:', result.professions);
  console.log('Raids:', result.raids);
  console.log('Schedules:', result.schedules);
  console.log('Is valid:', finalResult.isValid);
  console.log('Errors:', errors);
  console.log('Missing fields:', finalResult.missingFields);
  console.log('Full validation result:', finalResult);
  console.groupEnd();

  return finalResult;
}

// Mapa de colores y nombres de profesión
const PROFESSION_INFO = {
  JC: {
    name: 'Joyería',
    colors: { light: '#fde047', dark: '#d97706' },
  },
  BS: {
    name: 'Herrería',
    colors: { light: '#60a5fa', dark: '#1d4ed8' },
  },
  EN: {
    name: 'Encantamiento',
    colors: { light: '#c084fc', dark: '#7e22ce' },
  },
  EG: {
    name: 'Ingeniería',
    colors: { light: '#2dd4bf', dark: '#0d9488' },
  },
  AL: {
    name: 'Alquimia',
    colors: { light: '#4ade80', dark: '#15803d' },
  },
  TL: {
    name: 'Sastrería',
    colors: { light: '#f472b6', dark: '#db2777' },
  },
  IN: {
    name: 'Inscripción',
    colors: { light: '#818cf8', dark: '#4f46e5' },
  },
  HB: {
    name: 'Herboristería',
    colors: { light: '#84cc16', dark: '#65a30d' },
  },
  LW: {
    name: 'Peletería',
    colors: { light: '#f59e0b', dark: '#d97706' },
  },
  MN: {
    name: 'Minería',
    colors: { light: '#f97316', dark: '#c2410c' },
  },
  SK: {
    name: 'Desuello',
    colors: { light: '#f43f5e', dark: '#be123c' },
  },
} as const;

// Función para obtener el nombre del rol
const getRoleName = (role: string): string => {
  const roleNames: Record<string, string> = {
    T: 'Tanque',
    H: 'Sanador',
    D: 'DPS',
    M: 'Melee',
    R: 'Rango',
  };
  return roleNames[role] || role;
};

// Función para obtener la clase de color según el rol
const getRoleColorClass = (role: string): string => {
  const roleColors: Record<string, string> = {
    T: 'bg-blue-500/20 border-blue-500/50',
    H: 'bg-green-500/20 border-green-500/50',
    D: 'bg-red-500/20 border-red-500/50',
    M: 'bg-purple-500/20 border-purple-500/50',
    R: 'bg-yellow-500/20 border-yellow-500/50',
  };
  return roleColors[role] || 'bg-gray-500/20 border-gray-500/50';
};

// Mapeo de nombres de roles para el cliente
const roleNames = {
  T: { name: 'Tanque' },
  H: { name: 'Sanador' },
  D: { name: 'DPS' },
};

// Mapeo de nombres de profesiones para mostrar
const professionNames: Record<ProfessionCode, { name: string; color: string; bgColor: string }> = {
  AL: { name: 'Alquimia', color: 'text-blue-300', bgColor: 'bg-blue-500/20' },
  HB: { name: 'Herboristería', color: 'text-green-300', bgColor: 'bg-green-500/20' },
  TL: { name: 'Sastrería', color: 'text-amber-300', bgColor: 'bg-amber-500/20' },
  EN: { name: 'Encantamiento', color: 'text-purple-300', bgColor: 'bg-purple-500/20' },
  EG: { name: 'Ingeniería', color: 'text-orange-300', bgColor: 'bg-orange-500/20' },
  JC: { name: 'Joyería', color: 'text-yellow-300', bgColor: 'bg-yellow-500/20' },
  BS: { name: 'Herrería', color: 'text-gray-300', bgColor: 'bg-gray-500/20' },
  IN: { name: 'Inscripción', color: 'text-pink-300', bgColor: 'bg-pink-500/20' },
  MN: { name: 'Minería', color: 'text-gray-400', bgColor: 'bg-gray-600/20' },
  SK: { name: 'Desuello', color: 'text-red-200', bgColor: 'bg-red-700/20' },
  LW: { name: 'Peletería', color: 'text-amber-200', bgColor: 'bg-amber-700/20' },
};

// Mapeo de profesiones a nombres completos y colores
const professionInfo: Record<ProfessionCode, { name: string; color: string; bgColor: string }> = {
  JC: { name: 'Joyería', color: 'text-yellow-300', bgColor: 'bg-yellow-500/20' },
  BS: { name: 'Herrería', color: 'text-gray-300', bgColor: 'bg-gray-500/20' },
  EN: { name: 'Encantamiento', color: 'text-purple-300', bgColor: 'bg-purple-500/20' },
  EG: { name: 'Ingeniería', color: 'text-blue-200', bgColor: 'bg-blue-500/20' },
  AL: { name: 'Alquimia', color: 'text-green-200', bgColor: 'bg-green-500/20' },
  TL: { name: 'Trabajo del Cuero', color: 'text-amber-300', bgColor: 'bg-amber-500/20' },
  IN: { name: 'Sastrería', color: 'text-pink-300', bgColor: 'bg-pink-500/20' },
  HB: { name: 'Herboristería', color: 'text-lime-300', bgColor: 'bg-lime-500/20' },
  MN: { name: 'Minería', color: 'text-gray-400', bgColor: 'bg-gray-600/20' },
  SK: { name: 'Desuello', color: 'text-red-200', bgColor: 'bg-red-700/20' },
  LW: { name: 'Peletería', color: 'text-amber-200', bgColor: 'bg-amber-700/20' },
} as const;

// roleStats ya está definido más arriba en el código
// Usar roleDistribution para obtener los conteos de roles duales
// dualRoleStats ya está definido arriba en el código

// Variable para compatibilidad con código existente que espera un array
const sortedDualRoles = [
  {
    combo: 'TH',
    label: 'Tank / Healer',
    count: dualRoleStats.TH,
    color: 'bg-blue-400/20',
    textColor: 'text-blue-400',
  },
  {
    combo: 'TD',
    label: 'Tank / DPS',
    count: dualRoleStats.TD,
    color: 'bg-purple-400/20',
    textColor: 'text-purple-400',
  },
  {
    combo: 'HD',
    label: 'Healer / DPS',
    count: dualRoleStats.HD,
    color: 'bg-green-400/20',
    textColor: 'text-green-400',
  },
].sort((a, b) => b.count - a.count);

// Calcular estadísticas de mains/alts
const mainAltStats = rosterData.members.reduce(
  (acc, member) => {
    const validation = member.noteValidation;
    if (validation?.isValid) {
      // Usar 'A' (Alt) como valor predeterminado si no se especifica mainAlt
      const mainAlt = validation.mainAlt || 'A';
      acc[mainAlt] = (acc[mainAlt] || 0) + 1;
    } else {
      // Si la validación no es válida, contar como Alt
      acc['A'] = (acc['A'] || 0) + 1;
    }
    return acc;
  },
  { M: 0, A: 0 } as Record<MainAlt, number>
);

// Usamos gearScoreStats ya definido anteriormente

// Contar líderes de raid
const raidLeaderCount = rosterData.members.filter(
  (member) => member.noteValidation?.isRaidLeader
).length;

// Obtener lista de rangos únicos
const ranks = [...new Set(rosterData.members.map((member) => member.rank))].sort();

// Obtener lista de clases únicas
const rosterClassInfo = rosterData?.classInfo || {};
const classList = Object.keys(rosterClassInfo) as ClassName[];

// Función para determinar la prioridad del rango
const getRankPriority = (rank: string): number => {
  const rankLower = rank.toLowerCase();
  if (rankLower.includes('oficial')) return 0;
  if (rankLower.includes('general admin')) return 1;
  if (rankLower.includes('explorador')) return 2;
  if (rankLower.includes('iniciado')) return 3;
  if (rankLower.includes('aspirante')) return 4;
  return 5;
};

// Ordenar miembros
const sortedMembers = [...rosterData.members].sort((a, b) => {
  // Primero ordenar por prioridad de rango
  const priorityA = getRankPriority(a.rank);
  const priorityB = getRankPriority(b.rank);

  if (priorityA !== priorityB) {
    return priorityA - priorityB;
  }

  // Si tienen la misma prioridad, ordenar alfabéticamente
  return a.name.localeCompare(b.name);
});

// Datos para el cliente - Usamos los miembros ya ordenados
const rosterClientData: RosterData = {
  ...rosterData,
  members: sortedMembers as Member[],
  classes: Object.keys(rosterData.classInfo || {}),
};

// Definir tipos para las distribuciones
interface DistributionItem {
  name: string;
  count: number;
  percentage?: number;
  color?: string;
}

interface RoleDistributionItem extends DistributionItem {
  role: string;
}

type MainAltType = 'M' | 'A';
interface MainAltDistribution {
  M: number;
  A: number;
}

interface ClassDistributionItem extends DistributionItem {
  color: string;
}

interface MainAltDistributionItem extends DistributionItem {
  type: 'M' | 'A';
}

// Función para calcular la distribución por rango
function calculateRankDistribution(
  members: any[] = []
): Array<{ name: string; count: number; percentage: number }> {
  if (!members || !Array.isArray(members)) {
    return [];
  }
  const totalMembers = members.length;
  if (totalMembers === 0) return [];
  const rankCounts = members.reduce((acc: Record<string, number>, member) => {
    acc[member.rank] = (acc[member.rank] || 0) + 1;
    return acc;
  }, {});

  // Definir el orden de los rangos
  const rankOrder = ['Oficial', 'General Admin', 'Explorador', 'Iniciado', 'Aspirante'];

  // Calcular porcentajes y redondear a 1 decimal
  return Object.entries(rankCounts)
    .map(([name, count]) => ({
      name,
      count: count as number,
      percentage:
        totalMembers > 0 ? Math.round(((count as number) / totalMembers) * 100 * 10) / 10 : 0,
      order: rankOrder.indexOf(name) === -1 ? 999 : rankOrder.indexOf(name), // Asignar un orden alto si el rango no está en la lista
    }))
    .sort((a, b) => a.order - b.order) // Ordenar por el orden definido
    .map(({ name, count, percentage }) => ({
      name,
      count,
      percentage,
    }));
}

// Función para calcular la distribución por clase
function calculateClassDistribution(
  members: any[] = [],
  classInfo: any = {}
): ClassDistributionItem[] {
  if (!Array.isArray(members) || !classInfo) {
    return [];
  }

  const classCounts = members.reduce((acc: Record<string, number>, member) => {
    if (member && member.class) {
      acc[member.class] = (acc[member.class] || 0) + 1;
    }
    return acc;
  }, {});

  return Object.entries(classCounts)
    .filter(([className]) => className && classInfo[className])
    .map(([className, count]) => ({
      name: className,
      count: count as number,
      color: classInfo[className].color || 'FFFFFF',
    }));
}

// Calcular distribuciones
const rankDistribution = calculateRankDistribution(rosterData.members);
const classDistribution = calculateClassDistribution(rosterData.members, rosterData.classInfo);

// Mappings for new stats
const RACE_NAMES: Record<string, string> = {
  GN: 'Gnomo',
  HU: 'Humano',
  NE: 'Elfo de la Noche',
  DW: 'Enano',
  DR: 'Draenei',
  OR: 'Orco',
  TA: 'Tauren',
  UN: 'No Muerto',
  TR: 'Trol',
  BE: 'Elfo de Sangre',
};

const FACTION_NAMES: Record<string, string> = {
  '1': 'Alianza',
  '2': 'Horda',
};

// Calculate new distributions
const raceDistribution = (() => {
  const counts = rosterData.members.reduce(
    (acc, member) => {
      const race = member.race || 'UNKNOWN';
      acc[race] = (acc[race] || 0) + 1;
      return acc;
    },
    {} as Record<string, number>
  );

  return Object.entries(counts)
    .map(([code, count]) => ({
      name: code === 'UNKNOWN' ? 'No Censada' : RACE_NAMES[code] || code,
      count,
      percentage: getRolePercentage(count, rosterData.members.length),
      code,
    }))
    .sort((a, b) => {
      if (a.name === 'No Censada') return 1;
      if (b.name === 'No Censada') return -1;
      return b.count - a.count;
    });
})();

const factionDistribution = (() => {
  const counts = rosterData.members.reduce(
    (acc, member) => {
      const faction = member.faction || 'UNKNOWN';
      acc[faction] = (acc[faction] || 0) + 1;
      return acc;
    },
    {} as Record<string, number>
  );

  return Object.entries(counts)
    .map(([code, count]) => ({
      name: code === 'UNKNOWN' ? 'No Censada' : FACTION_NAMES[code] || code,
      count,
      percentage: getRolePercentage(count, rosterData.members.length),
      code,
    }))
    .sort((a, b) => {
      if (a.name === 'No Censada') return 1;
      if (b.name === 'No Censada') return -1;
      return b.count - a.count;
    });
})();

// Calculate profession distribution including non-censored
const professionDistribution = (() => {
  const counts: Record<string, number> = {};
  let uncensoredCount = 0;

  rosterData.members.forEach((member) => {
    const professions = member.noteValidation?.professions || [];
    if (professions.length === 0) {
      uncensoredCount++;
    } else {
      professions.forEach((prof) => {
        counts[prof] = (counts[prof] || 0) + 1;
      });
    }
  });

  const dist = Object.entries(counts)
    .map(([code, count]) => ({
      name: PROFESSIONS[code as keyof typeof PROFESSIONS] || code,
      count,
      percentage: getRolePercentage(count, rosterData.members.length),
      code,
    }))
    .sort((a, b) => b.count - a.count);

  if (uncensoredCount > 0) {
    dist.push({
      name: 'No Censada',
      count: uncensoredCount,
      percentage: getRolePercentage(uncensoredCount, rosterData.members.length),
      code: 'UNKNOWN',
    });
  }

  return dist;
})();

// Calcular estadísticas del formato de notas
// Usando el stats ya definido anteriormente

// Calcular porcentajes para las distribuciones
const mainAltDistribution: MainAltDistributionItem[] = [
  { type: 'M', name: 'Main', count: mainAltStats.M, percentage: getRolePercentage(mainAltStats.M) },
  { type: 'A', name: 'Alt', count: mainAltStats.A, percentage: getRolePercentage(mainAltStats.A) },
];

// Usar gearScoreStats ya definido al inicio del archivo
const gearScorePercentage =
  gearScoreStats.avg > 0 ? Math.min(100, Math.max(0, (gearScoreStats.avg / 6.8) * 100)) : 0;

// Usar validNotesCount ya calculado anteriormente

// La función getRankPriority y sortedMembers han sido movidas arriba para la inicialización

// Use the sorted members as the base for filtered members
const filteredMembers = [...sortedMembers];
const totalRaiders = rosterData.members.filter(
  (m) =>
    m.rank.toLowerCase().includes('élite') ||
    m.rank.toLowerCase().includes('general admin') ||
    m.rank.toLowerCase().includes('comandante') ||
    m.rank.toLowerCase().includes('oficial')
).length;

// rosterClientData is already defined above with the sorted members
---

<div>
  <!-- Título de la sección -->
  <div class="flex flex-col md:flex-row md:justify-between md:items-end gap-4 px-2 mb-6">
    <div class="flex items-center space-x-4">
      <div
        class="w-12 h-12 bg-gradient-to-br from-amber-600 to-amber-800 rounded-xl flex items-center justify-center shadow-lg shadow-amber-900/20 transform -rotate-2 hover:rotate-0 transition-transform duration-300"
      >
        <svg fill="#000000" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg"
          ><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier">
            <title>cracked-helm</title>
            <path
              d="M27.745 9.605c-2.737-4.441-7.647-7.397-11.759-8.808-1.394 0.445-2.781 1.056-4.12 1.823l5.301 4.128-1.447 1.463 5.196 3.968-9.746-3.045 1.995-1.925-5.295-1.681c-1.311 1.189-2.512 2.553-3.546 4.078 2.827 7.594 2.827 9.077 0 16.671 7.648 5.84 15.714 6.117 23.422 0-2.313-7.594-2.313-9.076 0-16.671zM23.884 17.982c-1.965-0.982-3.885-1.598-5.787-1.841-0.751 4.757-0.732 9.514 0.155 14.271h-3.73c1.153-4.768 0.981-9.535 0.143-14.303-1.956 0.217-3.908 0.839-5.884 1.873v-4.45c4.971-1.398 10.449-0.936 15.103 0v4.45z"
            ></path>
          </g></svg
        >
      </div>
      <div>
        <span class="text-sm md:text-3xl font-black text-white uppercase tracking-tighter italic">
          Roster de la <span
            class="text-transparent bg-clip-text bg-gradient-to-r from-amber-200 via-amber-400 to-amber-200 pr-1"
            >Hermandad</span
          >
        </span>
        <span
          class="text-amber-300/60 font-medium tracking-widest uppercase text-[10px] flex items-center space-x-1"
        >
          <span class="self-end"> Reglas de la Hermandad </span>
          <a
            href="#reglas-hermandad"
            class="inline-flex items-center text-amber-300/60 hover:text-amber-300 transition-colors"
            title="Reglas de la Hermandad"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              ></path>
            </svg>
          </a>
        </span>
      </div>
    </div>
    <div class="flex items-center text-[10px] text-amber-300/40 bg-gray-900/40 px-3 py-1.5 rounded-full border border-amber-900/30 shadow-inner">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1.5 opacity-70" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <span class="font-medium tracking-wide">
        Actualizado por <span class="text-amber-300 font-semibold">{lastUpdatedBy}</span>: {globalLastUpdate ? new Date(globalLastUpdate * 1000).toLocaleString('es-ES', { 
          day: '2-digit', 
          month: '2-digit', 
          year: 'numeric', 
          hour: '2-digit', 
          minute: '2-digit' 
        }) : 'N/A'}
      </span>
    </div>
  </div>

  <style>
    /* Estilos para el modal */
    #member-modal {
      opacity: 0;
      visibility: hidden;
      transition:
        opacity 0.2s ease-in-out,
        visibility 0.2s ease-in-out;
    }

    #member-modal.show {
      opacity: 1;
      visibility: visible;
    }

    #member-modal .modal-content {
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Estilos para los tooltips */
    .tooltip-container {
      position: relative;
      display: inline-block;
    }

    /* Estilos para los contenedores de select personalizados */
    .select-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    .select-wrapper::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 0.75rem;
      transform: translateY(-50%);
      width: 1em;
      height: 1em;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23f59e0b'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      pointer-events: none;
      z-index: 10;
    }

    /* Ocultar la flecha predeterminada en todos los navegadores */
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      padding-right: 2rem !important;
      background-image: none !important;
    }

    /* Para IE11 */
    select::-ms-expand {
      display: none;
    }

    .tooltip-container:hover .tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .tooltip {
      transform: translateY(-5px);
      transition: all 0.2s ease-in-out;
      box-shadow:
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Estilos para los dropdowns */
    select option {
      background-color: #1a202c; /* Fondo oscuro */
      color: #e2e8f0; /* Texto claro */
      padding: 0.5rem;
    }

    select:focus option:checked {
      background-color: #4a5568; /* Color de fondo para la opción seleccionada */
      color: white;
    }

    /* Estilo para el hover en las opciones */
    select option:hover {
      background-color: #4a5568 !important;
    }

    /* Custom scrollbar for boss stats */
    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(31, 41, 55, 0.5);
      border-radius: 3px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(245, 158, 11, 0.3);
      border-radius: 3px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(245, 158, 11, 0.5);
    }
  </style>

  <!-- Script del cliente con la lógica de JavaScript -->
  <script
    define:vars={{
      rosterData: JSON.stringify(rosterClientData),
      roleNames: JSON.stringify(roleNames),
      professionNames: JSON.stringify(professionNames),
      raceNames: JSON.stringify(RACE_NAMES),
      factionNames: JSON.stringify(FACTION_NAMES),
      raidRegistrations: JSON.stringify(raidRegistrations),
    }}
  >
    // Analizar los datos del roster
    const rosterInfo = JSON.parse(rosterData);
    const roleNamesData = JSON.parse(roleNames);
    const professionNamesData = JSON.parse(professionNames);
    const raceNamesData = JSON.parse(raceNames);
    const factionNamesData = JSON.parse(factionNames);
    const raidRegistrationsData = JSON.parse(raidRegistrations);

    // Función para inicializar tooltips
    function initTooltips() {
      document.querySelectorAll('.tooltip-container').forEach((container) => {
        const tooltip = container.querySelector('.tooltip');
        if (!tooltip) return;

        // Posicionamiento del tooltip
        const updatePosition = () => {
          const rect = container.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();

          // Centrar horizontalmente
          const left = rect.left + rect.width / 2 - tooltipRect.width / 2;

          // Ajustar para que no se salga de la pantalla
          const adjustedLeft = Math.max(
            10,
            Math.min(window.innerWidth - tooltipRect.width - 10, left)
          );

          tooltip.style.left = `${adjustedLeft}px`;
        };

        // Actualizar posición al mostrar
        container.addEventListener('mouseenter', updatePosition);

        // Actualizar posición al redimensionar
        window.addEventListener('resize', updatePosition);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Inicializar tooltips después de cargar la tabla
      initTooltips();

      // Obtener elementos del DOM
      const searchInput = document.getElementById('search');
      const classFilter = document.getElementById('class-filter');
      const rankFilter = document.getElementById('rank-filter');
      const rosterGrid = document.getElementById('roster-grid');
      const prevButton = document.getElementById('prev-button');
      const nextButton = document.getElementById('next-button');
      const pageInfo = document.getElementById('page-info');
      const sortButtons = document.querySelectorAll('.sort-button');

      let currentPage = 1;
      let itemsPerPage = 6; // Will be updated based on screen size
      let allMembers = [];
      let filteredMembers = [];
      let sortConfig = { key: 'name', direction: 'asc' };

      // Modal elements
      const modal = document.getElementById('member-modal');
      const closeModalX = document.getElementById('close-modal');
      const closeModalBtn = document.getElementById('close-modal-btn');

      // Modal content elements
      const modalAvatar = document.getElementById('modal-avatar');
      const modalName = document.getElementById('modal-name');
      const modalClass = document.getElementById('modal-class');
      const modalRank = document.getElementById('modal-rank');
      const modalNote = document.getElementById('modal-note');
      const modalTags = document.getElementById('modal-tags');
      const modalRaidSummary = document.getElementById('modal-raid-summary');
      const modalZoneStats = document.getElementById('modal-zone-stats');
      const modalBossStats = document.getElementById('modal-boss-stats');

      // Function to update recognitions display
      function updateRecognitionsDisplay(member) {
        const container = document.getElementById('recognitions-container');
        if (!container) return;

        let html = '';

        if (member.recognitions && member.recognitions.length > 0) {
          // Group recognitions by title
          const groupedRecs = member.recognitions.reduce((acc, rec) => {
            const date = new Date(rec.date);
            let dateStr = 'Fecha desconocida';

            if (!isNaN(date.getTime())) {
              const month = date.getMonth();
              const year = date.getFullYear();
              const monthNames = [
                'Ene',
                'Feb',
                'Mar',
                'Abr',
                'May',
                'Jun',
                'Jul',
                'Ago',
                'Sep',
                'Oct',
                'Nov',
                'Dic',
              ];
              dateStr = `${monthNames[month]}-${year.toString().slice(2)}`;
            }

            const key = rec.title || 'Mención Honorífica';
            if (!acc[key]) {
              acc[key] = [];
            }
            acc[key].push({ ...rec, dateStr });
            return acc;
          }, {});

          // Sort recognition groups by most recent date
          Object.entries(groupedRecs).forEach(([title, recs]) => {
            recs.sort((a, b) => new Date(b.date) - new Date(a.date));
          });

          // Create compact display
          html += '<div class="space-y-2">';

          Object.entries(groupedRecs).forEach(([title, recs]) => {
            const firstRec = recs[0];
            const dateRange =
              recs.length > 1
                ? `${recs[recs.length - 1].dateStr} - ${firstRec.dateStr}`
                : firstRec.dateStr;

            html += `
              <div class="bg-gray-800/40 p-2 rounded-md border border-amber-600/20 hover:border-amber-500/40 transition-colors text-sm">
                <div class="flex justify-between items-center">
                  <span class="font-medium text-amber-300">${title}</span>
                  <span class="text-xs text-gray-400 bg-gray-700/50 px-1.5 py-0.5 rounded">${recs.length}x</span>
                </div>
                <div class="flex justify-between items-center mt-1">
                  <span class="text-xs text-gray-400">${dateRange}</span>
                  ${
                    firstRec.achievement
                      ? `
                    <span class="text-xs text-amber-200/70 flex items-center gap-1">
                      <svg class="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                      </svg>
                      ${firstRec.achievement}
                    </span>
                  `
                      : ''
                  }
                </div>
              </div>
            `;
          });

          html += '</div>';
        } else {
          html = `
            <div class="text-center py-3">
              <p class="text-sm text-gray-400">No hay reconocimientos registrados</p>
            </div>
          `;
        }

        container.innerHTML = html;
      }

      // Function to update boss kills display
      // Function to update boss kills display
      // Note: Removed because boss kills data will no longer be included in roster.json

      window.switchModalTab = function (tabId) {
        // Update tab buttons
        document.querySelectorAll('.modal-tab').forEach((tab) => {
          tab.classList.remove('text-amber-400', 'border-amber-500');
          tab.classList.add('text-gray-400', 'border-transparent');
        });
        const activeTab = document.getElementById(`tab-${tabId}`);
        if (activeTab) {
          activeTab.classList.remove('text-gray-400', 'border-transparent');
          activeTab.classList.add('text-amber-400', 'border-amber-500');
        }

        // Update panes
        document.querySelectorAll('.modal-pane').forEach((pane) => pane.classList.add('hidden'));
        const activePane = document.getElementById(`pane-${tabId}`);
        if (activePane) activePane.classList.remove('hidden');

        // If switching to recognitions tab, update the display
        if (tabId === 'recognitions' && currentMember) {
          updateRecognitionsDisplay(currentMember);
        }

        // If switching to raids tab, update the display
        if (tabId === 'raids' && currentMember) {
          updateRaidsDisplay(currentMember);
        }
      };

      // Function to update raids display
      function updateRaidsDisplay(member) {
        const container = document.getElementById('raids-container');
        const badge = document.getElementById('badge-raids');
        const tabButton = document.getElementById('tab-raids');
        if (!container) return;

        let html = '';
        let totalRaids = 0;

        // Collect all cores from all leaders
        const allCores = [];
        if (member.leaderData) {
          // Handle direct structure (e.g., leader's own cores)
          if (member.leaderData.cores && Array.isArray(member.leaderData.cores)) {
            member.leaderData.cores.forEach((core) => {
              allCores.push({
                ...core,
                leader: member.name,
                lastUpdate: member.leaderData.lastUpdate || 0,
                source: 'roster'
              });
            });
          }

          // Handle nested structure (membership in other leaders' cores)
          Object.entries(member.leaderData).forEach(([key, data]) => {
            // Skip keys that are part of the direct structure
            if (key === 'cores' || key === 'lastUpdate') return;

            if (data && typeof data === 'object' && data.cores && Array.isArray(data.cores)) {
              data.cores.forEach((core) => {
                allCores.push({
                  ...core,
                  leader: key,
                  lastUpdate: data.lastUpdate || 0,
                  source: 'roster'
                });
              });
            }
          });
        }

        totalRaids = allCores.length;
        if (badge) {
          badge.textContent = totalRaids.toString();
          badge.classList.toggle('hidden', totalRaids === 0);
        }

        if (tabButton) {
          if (totalRaids === 0) {
            tabButton.style.display = 'none';
            // Si estamos en la pestaña de raids, cambiar a general
            const activeTab = document.querySelector('.modal-tab.border-amber-500');
            if (activeTab && activeTab.id === 'tab-raids') {
              window.switchModalTab('general');
            }
          } else {
            tabButton.style.display = ''; // Restaurar display original (flex)
          }
        }

        if (totalRaids > 0) {
          // Sort by last update (most recent first)
          allCores.sort((a, b) => b.lastUpdate - a.lastUpdate);

          html += '<div class="grid grid-cols-1 gap-3 sm:grid-cols-2">';
          allCores.forEach((core) => {
            // Determine difficulty color if possible (e.g., from raid name like "ICC10H")
            let diffColorClass = 'bg-gray-700/50 text-gray-300 border-gray-600/30';
            const raidUpper = core.raid.toUpperCase();

            if (raidUpper.includes('10H'))
              diffColorClass = 'bg-blue-900/30 text-blue-300 border-blue-700/40';
            else if (raidUpper.includes('25H'))
              diffColorClass = 'bg-red-900/30 text-red-300 border-red-700/40';
            else if (raidUpper.includes('10N'))
              diffColorClass = 'bg-cyan-900/30 text-cyan-300 border-cyan-700/40';
            else if (raidUpper.includes('25N'))
              diffColorClass = 'bg-purple-900/30 text-purple-300 border-purple-700/40';

            html += `
              <a href="/raids" class="block group bg-gray-800/40 p-3 rounded-md border border-amber-600/20 hover:border-amber-500/40 hover:bg-gray-800/60 transition-all duration-200">
                <div class="flex flex-col mb-1">
                  <span class="font-bold text-amber-300 text-sm group-hover:text-amber-200 transition-colors">${core.raid}</span>
                </div>
                <div class="flex items-center gap-2 mt-1 text-xs text-gray-300 group-hover:text-gray-200">
                  <svg class="w-3.5 h-3.5 text-amber-500/70 group-hover:text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>
                  <span>${core.schedule}</span>
                </div>
              </a>
            `;
          });
          html += '</div>';
        } else {
          html = `
            <div class="text-center py-6">
              <div class="w-12 h-12 bg-gray-800/50 rounded-full flex items-center justify-center mx-auto mb-2 border border-gray-700/30">
                <svg class="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
              </div>
              <p class="text-sm text-gray-500 italic">No hay registros de participación en raids</p>
            </div>
          `;
        }

        container.innerHTML = html;
      }

      // Store current member for tab switching
      let currentMember = null;

      function openModal(member) {
        if (!modal) return;

        // Store the current member
        currentMember = member;

        // Show modal with transition
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden'; // Prevent background scrolling

        // Trigger reflow to ensure the initial state is applied
        void modal.offsetWidth;

        // Add show class to trigger the transition
        modal.classList.add('show');

        // Animate the modal content
        const modalContent = modal.querySelector('.modal-content');
        if (modalContent) {
          setTimeout(() => {
            modalContent.classList.remove('opacity-0', 'scale-95', 'translate-y-4');
            modalContent.classList.add('opacity-100', 'scale-100', 'translate-y-0');
          }, 10);
        }

        // Update modal header with class icon and name
        const modalClassIcon = document.getElementById('modal-class-icon');
        const modalCharacterName = document.getElementById('modal-character-name');

        if (modalClassIcon && member.class) {
          const classData = rosterInfo.classInfo[member.class] || {
            color: 'FFFFFF',
            name: member.class,
          };
          const className = classData.name;
          const classColor = classData.color;

          // Clear previous content
          modalClassIcon.innerHTML = '';

          // Create avatar container
          const avatarContainer = document.createElement('div');
          avatarContainer.className = 'relative flex-shrink-0';

          // Create class avatar image
          const avatarImg = document.createElement('img');
          avatarImg.src = `/images/avatars/class_${className}.jpg`;
          avatarImg.alt = className;
          avatarImg.className =
            'w-12 h-12 rounded-md shadow-lg border border-gray-700/50 object-cover';
          avatarImg.onerror = "this.src='/images/avatars/default.png'";

          // Create class color indicator
          const classIndicator = document.createElement('div');
          classIndicator.className =
            'absolute -bottom-1 -right-1 w-4 h-4 rounded-md border-2 border-gray-900';
          classIndicator.style.backgroundColor = `#${classColor}`;
          classIndicator.title = className;

          // Assemble the avatar
          avatarContainer.appendChild(avatarImg);
          avatarContainer.appendChild(classIndicator);

          // Replace the existing icon with the new avatar
          modalClassIcon.className = ''; // Remove old classes
          modalClassIcon.appendChild(avatarContainer);
        }

        if (modalCharacterName) {
          modalCharacterName.textContent = member.name || 'Personaje';
          // Apply class color to name in header
          if (member.class && rosterInfo.classInfo[member.class]) {
            modalCharacterName.style.color = `#${rosterInfo.classInfo[member.class].color}`;
          } else {
            modalCharacterName.style.color = '';
          }
        }

        // Set rank in header
        const modalHeaderRank = document.getElementById('modal-header-rank');
        if (modalHeaderRank) {
          modalHeaderRank.textContent = member.rank || '';
        }

        // Update body info
        if (modalName) modalName.textContent = member.name || '';
        if (modalClass) {
          modalClass.textContent = member.class || '';
          modalClass.style.display = 'block';
        }

        // Generate color-coded tags (including Faction, Race)
        if (modalTags) {
          modalTags.innerHTML = '';
          let formattedInfo = [];

          // 1. Faction Tag
          if (member.faction) {
            const factionCode = member.faction;
            formattedInfo.push({
              label: (factionCode === '1' ? '🛡️ ' : '⚔️ ') + (factionNamesData[factionCode] || ''),
              class:
                factionCode === '1'
                  ? 'bg-blue-500/10 border-blue-500/40 text-blue-300'
                  : 'bg-red-500/10 border-red-500/40 text-red-300',
            });
          }

          // 2. Race Tag
          if (member.race) {
            const raceColors = {
              GN: 'bg-pink-500/10 border-pink-500/40 text-pink-300',
              HU: 'bg-blue-500/10 border-blue-500/40 text-blue-300',
              NE: 'bg-purple-500/10 border-purple-500/40 text-purple-300',
              DW: 'bg-amber-500/10 border-amber-500/40 text-amber-300',
              DR: 'bg-cyan-500/10 border-cyan-500/40 text-cyan-300',
              OR: 'bg-green-500/10 border-green-500/40 text-green-300',
              TA: 'bg-yellow-500/10 border-yellow-500/40 text-yellow-300',
              UN: 'bg-gray-500/10 border-gray-500/40 text-gray-300',
              TR: 'bg-orange-500/10 border-orange-500/40 text-orange-300',
              BE: 'bg-red-500/10 border-red-500/40 text-red-300',
            };
            formattedInfo.push({
              label: raceNamesData[member.race] || member.race,
              class: raceColors[member.race] || 'bg-gray-500/10 border-gray-500/40 text-gray-300',
            });
          }

          if (member.publicNote) {
            const validation = member.noteValidation;
            if (validation?.isValid) {
              const characterBlocks =
                validation.blocks?.filter((b) => b.type === 'character') || [];
              let charData = {};

              if (characterBlocks.length > 0 && characterBlocks[0]?.parsedData) {
                charData = characterBlocks[0].parsedData;
              } else {
                charData = {
                  mainAlt: validation.mainAlt,
                  mainRole: validation.role,
                  mainGearScore: parseFloat(validation.gearScore) || 0,
                  professions: validation.professions || [],
                  dualRole: validation.dualRole,
                };
              }

              const gearScores = (member.publicNote?.match(/(\d+\.?\d*)/g) || [])
                .map(Number)
                .filter((gs) => gs > 0);

              // Main/Alt
              if (charData.mainAlt) {
                formattedInfo.push({
                  label: charData.mainAlt === 'M' ? 'Main' : 'Alt',
                  class:
                    charData.mainAlt === 'M'
                      ? 'bg-blue-500/10 border-blue-500/40 text-blue-300 hover:bg-blue-500/15 hover:border-blue-400/60'
                      : 'bg-purple-500/10 border-purple-500/40 text-purple-300 hover:bg-purple-500/15 hover:border-purple-400/60',
                });
              }

              // Role
              if (charData.mainRole) {
                const roleName = roleNamesData[charData.mainRole]?.name || charData.mainRole;
                const mainGS = gearScores[0] || charData.mainGearScore;

                formattedInfo.push({
                  label: roleName,
                  class:
                    charData.mainRole === 'T'
                      ? 'bg-blue-500/10 border-blue-500/40 text-blue-200 hover:bg-blue-500/15 hover:border-blue-400/60'
                      : charData.mainRole === 'H'
                        ? 'bg-emerald-500/10 border-emerald-500/40 text-emerald-200 hover:bg-emerald-500/15 hover:border-emerald-400/60'
                        : 'bg-rose-500/10 border-rose-500/40 text-rose-200 hover:bg-rose-500/15 hover:border-rose-400/60',
                });

                if (mainGS) {
                  formattedInfo.push({
                    label: `GS ${mainGS}k`,
                    class:
                      'bg-amber-500/10 border-amber-500/40 text-amber-200 hover:bg-amber-500/15 hover:border-amber-400/60',
                  });
                }
              }

              // Dual Role
              if (charData.dualRole && charData.dualRole !== charData.mainRole) {
                const dualRoleName = roleNamesData[charData.dualRole]?.name || charData.dualRole;
                const dualGS = gearScores[1];

                formattedInfo.push({
                  label: `Dual ${dualRoleName}`,
                  class:
                    'bg-yellow-500/10 border-yellow-500/40 text-yellow-200 hover:bg-yellow-500/15 hover:border-yellow-400/60',
                });

                if (dualGS) {
                  formattedInfo.push({
                    label: `GS ${dualGS}k`,
                    class:
                      'bg-amber-500/10 border-amber-500/40 text-amber-200 hover:bg-amber-500/15 hover:border-amber-400/60',
                  });
                }
              }

              // Professions
              const professionsToShow = (
                charData.professions?.length ? charData.professions : validation.professions || []
              ).filter((prof) => prof && !/^\d+\.?\d*$/.test(prof));

              if (professionsToShow.length) {
                const processedProfs = new Set();
                professionsToShow.forEach((prof) => {
                  let profCode = prof.toUpperCase();
                  const entry = Object.entries(professionNamesData).find(
                    ([_, data]) => data?.name?.toLowerCase() === prof.toLowerCase()
                  );
                  if (entry) profCode = entry[0];

                  if (processedProfs.has(profCode)) return;
                  processedProfs.add(profCode);

                  const profStyle = professionNamesData[profCode] || {
                    name: prof,
                    bgColor: 'bg-indigo-500/10',
                    borderColor: 'border-indigo-500/40',
                    color: 'text-indigo-200',
                    hoverBg: 'hover:bg-indigo-500/20',
                    hoverBorder: 'hover:border-indigo-400/60',
                  };

                  formattedInfo.push({
                    label: profStyle.name,
                    class: `${profStyle.bgColor} ${profStyle.borderColor} ${profStyle.color} ${profStyle.hoverBg || 'hover:bg-indigo-500/15'} ${profStyle.hoverBorder || 'hover:border-indigo-400/60'} transition-all duration-200`,
                  });
                });
              }
            } else {
              formattedInfo.push({
                label: 'Nota inválida',
                class: 'bg-red-500/10 border-red-500/40 text-red-300 italic',
              });
            }
          }

          if (formattedInfo.length > 0) {
            formattedInfo.forEach((tag) => {
              const span = document.createElement('span');
              span.className = `inline-flex items-center px-2 py-0.5 rounded-md text-xs font-medium border ${tag.class}`;
              span.textContent = tag.label;
              modalTags.appendChild(span);
            });
          } else {
            modalTags.innerHTML = '<span class="text-xs text-gray-500 italic">Sin etiquetas</span>';
          }
        }

        // Note
        if (modalNote) {
          modalNote.textContent = member.publicNote || 'Sin nota pública';
        }

        // Reset to General tab
        window.switchModalTab('general');

        const hasRecognitions =
          member.recognitions &&
          Array.isArray(member.recognitions) &&
          member.recognitions.length > 0;

        const recognitionsTab = document.getElementById('tab-recognitions');
        const badgeRecognitions = document.getElementById('badge-recognitions');

        if (recognitionsTab) recognitionsTab.style.display = hasRecognitions ? 'flex' : 'none';

        if (badgeRecognitions) {
          if (hasRecognitions) {
            badgeRecognitions.textContent = member.recognitions.length.toString();
            badgeRecognitions.classList.remove('hidden');
          } else {
            badgeRecognitions.classList.add('hidden');
          }
        }

        // Update raids display (to update badge count)
        updateRaidsDisplay(member);

        // Show modal
        modal.classList.remove('hidden');
        modal.classList.add('show');
        document.body.style.overflow = 'hidden'; // Prevent scrolling
      }

      function closeModal() {
        if (!modal) return;

        // Animate out the modal content
        const modalContent = modal.querySelector('.modal-content');
        if (modalContent) {
          modalContent.classList.remove('opacity-100', 'scale-100', 'translate-y-0');
          modalContent.classList.add('opacity-0', 'scale-95', 'translate-y-4');
        }

        // Remove show class after the animation completes
        setTimeout(() => {
          modal.classList.remove('show');
          modal.classList.add('hidden');
          document.body.style.overflow = ''; // Restore scrolling
        }, 200); // Match this with the CSS transition duration
      }

      // Modal Event Listeners
      if (closeModalX) closeModalX.addEventListener('click', closeModal);
      if (closeModalBtn) closeModalBtn.addEventListener('click', closeModal);
      if (modal) {
        modal.addEventListener('click', (e) => {
          if (e.target === modal || e.target.closest('.fixed.inset-0.bg-gray-900\\/75')) {
            closeModal();
          }
        });
      }

      // Function to update items per page based on screen size
      function updateItemsPerPage() {
        itemsPerPage = window.innerWidth < 768 ? 10 : 9; // 6 for mobile, 9 for desktop
        updateTable();
        updatePaginationInfo();
      }

      // Initial update and add resize listener
      updateItemsPerPage();
      window.addEventListener('resize', updateItemsPerPage);

      // Funciones de utilidad para formatear
      const formatTime = (timeStr) => {
        if (!timeStr) return '';
        return timeStr.includes(':') ? timeStr : `${timeStr}:00`;
      };

      // Inicializar la tabla con los datos
      function initTable() {
        if (!rosterGrid || !pageInfo) {
          return;
        }

        // Use the pre-sorted members from the server
        allMembers = [...rosterInfo.members];

        // Función de ordenamiento
        const sortMembers = () => {
          allMembers.sort((a, b) => {
            let valA, valB;

            if (sortConfig.key === 'name') {
              // Ordenar por nombre y prioridad de rango
              const getRankPriority = (rank) => {
                const rankLower = rank?.toLowerCase() || '';
                if (rankLower.includes('oficial')) return 0;
                if (rankLower.includes('administrador')) return 1;
                if (rankLower.includes('explorador')) return 2;
                if (rankLower.includes('iniciado')) return 3;
                if (rankLower.includes('aspirante')) return 4;
                return 5;
              };

              const priorityA = getRankPriority(a.rank);
              const priorityB = getRankPriority(b.rank);

              if (priorityA !== priorityB) {
                return sortConfig.direction === 'asc'
                  ? priorityA - priorityB
                  : priorityB - priorityA;
              }
              valA = (a.name || '').toLowerCase();
              valB = (b.name || '').toLowerCase();
            } else {
              // Ordenar por detalles (longitud de la nota o presencia de nota)
              valA = (a.publicNote || '').length;
              valB = (b.publicNote || '').length;
            }

            if (valA < valB) return sortConfig.direction === 'asc' ? -1 : 1;
            if (valA > valB) return sortConfig.direction === 'asc' ? 1 : -1;
            return 0;
          });

          // Aplicar filtros después de ordenar
          filterMembers();
        };

        // Event listeners para botones de ordenamiento
        sortButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const sortKey = button.dataset.sort;

            // Actualizar configuración de ordenamiento
            if (sortConfig.key === sortKey) {
              sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
            } else {
              sortConfig.key = sortKey;
              sortConfig.direction = 'asc';
            }

            // Actualizar estilos de botones
            sortButtons.forEach((btn) => {
              btn.classList.remove('bg-amber-900/50', 'border-amber-500/50');
              btn.classList.add('bg-gray-800/50', 'border-amber-900/30');
              const indicator = btn.querySelector('.sort-indicator');
              if (indicator) {
                indicator.textContent = '↕';
                indicator.classList.add('opacity-50');
              }
            });

            button.classList.remove('bg-gray-800/50', 'border-amber-900/30');
            button.classList.add('bg-amber-900/50', 'border-amber-500/50');
            const indicator = button.querySelector('.sort-indicator');
            if (indicator) {
              indicator.textContent = sortConfig.direction === 'asc' ? '↑' : '↓';
              indicator.classList.remove('opacity-50');
            }

            // Re-ordenar y actualizar
            sortMembers();
            updateTable();
            updatePaginationInfo();
          });
        });

        // Función para filtrar miembros
        const filterMembers = () => {
          const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
          const selectedClass = classFilter ? classFilter.value : '';
          const selectedRank = rankFilter ? rankFilter.value : '';

          filteredMembers = allMembers.filter((member) => {
            const matchesSearch = member.name.toLowerCase().includes(searchTerm);
            const matchesClass = selectedClass === '' || member.class === selectedClass;
            const matchesRank = selectedRank === '' || member.rank === selectedRank;
            return matchesSearch && matchesClass && matchesRank;
          });

          currentPage = 1; // Resetear a la primera página al filtrar
        };

        // Event listeners para filtros
        if (searchInput) {
          searchInput.addEventListener('input', () => {
            filterMembers();
            updateTable();
            updatePaginationInfo();
          });
        }
        if (classFilter) {
          classFilter.addEventListener('change', () => {
            filterMembers();
            updateTable();
            updatePaginationInfo();
          });
        }
        if (rankFilter) {
          rankFilter.addEventListener('change', () => {
            filterMembers();
            updateTable();
            updatePaginationInfo();
          });
        }

        // Inicializar
        sortMembers();
        updateTable();
        updatePaginationInfo();
      }

      // Función para calcular el número de raids de un miembro
      function getMemberRaidCount(member) {
        if (!member) return 0;
        const allCores = [];
        
        try {
          // 1. From leaderData
          if (member.leaderData) {
            // Direct structure
            if (member.leaderData.cores && Array.isArray(member.leaderData.cores)) {
              member.leaderData.cores.forEach((core) => {
                if (core) allCores.push({ ...core });
              });
            }

            // Nested structure
            Object.entries(member.leaderData).forEach(([key, data]) => {
              if (key === 'cores' || key === 'lastUpdate') return;
              if (data && typeof data === 'object' && data.cores && Array.isArray(data.cores)) {
                data.cores.forEach((core) => {
                  if (core) allCores.push({ ...core });
                });
              }
            });
          }

          // 2. From Supabase - DISABLED by request (only leaderData should determine raids/leadership)
          /* 
          if (raidRegistrationsData && Array.isArray(raidRegistrationsData)) {
              const memberName = member.name ? member.name.toLowerCase() : '';
              if (memberName) {
                const memberRegistrations = raidRegistrationsData.filter(reg => 
                    reg.player_name && reg.player_name.toLowerCase() === memberName
                );

                memberRegistrations.forEach(reg => {
                    if (!reg.raid_id || !reg.day_of_week) return;
                    
                    const isDuplicate = allCores.some(core => 
                        core.raid === reg.raid_id && 
                        core.schedule && 
                        core.schedule.toLowerCase().includes(reg.day_of_week.toLowerCase())
                    );

                    if (!isDuplicate) {
                        allCores.push({ raid: reg.raid_id });
                    }
                });
              }
          }
          */
        } catch (e) {
          console.error('Error calculating raid count for member:', member?.name, e);
          return 0;
        }

        return allCores.length;
      }

      // Actualizar la tabla (ahora grid) con los miembros filtrados y ordenados
      function updateTable() {
        if (!rosterGrid) return;

        const startIndex = (currentPage - 1) * itemsPerPage;
        const paginatedMembers = filteredMembers.slice(startIndex, startIndex + itemsPerPage);

        rosterGrid.innerHTML = paginatedMembers
          .map((member) => {
            const classData = rosterInfo.classInfo[member.class] || {
              color: 'FFFFFF',
              name: member.class,
            };
            const className = classData.name;
            const classColor = classData.color;
            const raidCount = getMemberRaidCount(member);

            return `
            <div class="group bg-gradient-to-br from-gray-900/60 to-gray-800/50 backdrop-blur-sm rounded-md p-1 sm:p-4 transition-all duration-300 overflow-hidden cursor-pointer hover:bg-gray-800/60 hover:shadow-lg hover:shadow-amber-900/20 relative" 
                 style="border: 1px solid #${classColor}66;"
                 onclick='window.openMemberModal(${JSON.stringify(member).replace(/'/g, '&#39;')})'
                 onmouseover="this.style.borderColor='#${classColor}99'; this.style.boxShadow='0 10px 15px -3px #${classColor}1a, 0 4px 6px -2px #${classColor}0a';"
                 onmouseout="this.style.borderColor='#${classColor}66'; this.style.boxShadow='none';">
                <!-- Class color accent -->
                <div class="absolute top-0 left-0 w-1 h-full transition-opacity" style="background-color: #${classColor}; opacity: 0.5;" onmouseover="this.style.opacity='1';" onmouseout="this.style.opacity='0.5';"></div>
                
                <!-- Stats Indicators -->
                <div class="absolute top-1 right-1 flex flex-col gap-0.5 sm:flex-row sm:gap-1 z-10 flex-shrink-0">
                  ${
                    raidCount > 0
                      ? `
                  <div class="px-1.5 py-0.5 rounded text-[9px] sm:text-xs font-bold bg-purple-500/20 text-purple-300 border border-purple-500/30 flex items-center gap-1" title="${raidCount} Raids Activas">
                    <svg class="w-2 h-2 sm:w-3 sm:h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                    </svg>
                    <span>${raidCount}</span>
                  </div>
                  `
                      : ''
                  }
                  ${
                    member.recognitions && member.recognitions.length > 0
                      ? `
                  <div class="px-1.5 py-0.5 rounded text-[9px] sm:text-xs font-bold bg-amber-500/20 text-amber-300 border border-amber-500/30 flex items-center gap-1" title="${member.recognitions.length} Reconocimientos">
                    <svg class="w-2 h-2 sm:w-3 sm:h-3" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                    </svg>
                    <span>${member.recognitions.length}</span>
                  </div>
                  `
                      : ''
                  }

                </div>
                
                <div class="flex flex-col items-start pl-2">
                  <div class="flex items-center gap-1 sm:gap-2">
                    <!-- Avatar -->
                    <div class="relative flex-shrink-0 hidden sm:block">
                        <img 
                            src="/images/avatars/class_${className}.jpg" 
                            alt="${className}" 
                            class="w-10 h-10 sm:w-12 sm:h-12 rounded-md shadow-lg border border-gray-700/50 group-hover:border-[#${classColor}]/50 transition-colors object-cover"
                            onerror="this.src='/images/avatars/default.png'"
                        />
                        <div class="absolute -bottom-1 -right-1 w-3 h-3 sm:w-4 sm:h-4 rounded-full border-2 border-gray-900 bg-[#${classColor}]" title="${className}"></div>
                    </div>
                    
                    <!-- Info -->
                    <div class="flex-1 min-w-0 flex-grow">
                        <div class="">
                            <div class="font-bold truncate transition-colors text-sm sm:text-lg italic pr-1" style="color: #${classColor}">${member.name}</div>
                            <span class="text-[10px] sm:text-xs px-2 py-0.5 rounded-md font-medium border transition-all duration-200 ${
                              member.rank.toLowerCase().includes('general admin')
                                ? 'bg-gradient-to-r from-amber-500/10 to-purple-600/10 border-amber-500/40 text-amber-300 hover:bg-amber-500/20 hover:border-amber-400/60'
                                : member.rank.toLowerCase().includes('oficial')
                                  ? 'bg-gradient-to-r from-blue-500/10 to-blue-600/10 border-blue-500/40 text-blue-300 hover:bg-blue-500/20 hover:border-blue-400/60'
                                  : member.rank.toLowerCase().includes('explorador')
                                    ? 'bg-gradient-to-r from-emerald-500/10 to-emerald-600/10 border-emerald-500/40 text-emerald-300 hover:bg-emerald-500/20 hover:border-emerald-400/60'
                                    : member.rank.toLowerCase().includes('iniciado')
                                      ? 'bg-gradient-to-r from-green-500/10 to-green-600/10 border-green-500/40 text-green-300 hover:bg-green-500/20 hover:border-green-400/60'
                                      : 'bg-gradient-to-r from-gray-500/10 to-gray-600/10 border-gray-500/40 text-gray-300 hover:bg-gray-500/20 hover:border-gray-400/60'
                            }">${member.rank}</span>
                        </div>
                        
                        
                    </div>
                </div>
            </div>
        </div>
        `;
          })
          .join('');
      }

      // Función para actualizar la información de paginación
      function updatePaginationInfo() {
        if (!pageInfo) return;
        const totalPages = Math.ceil(filteredMembers.length / itemsPerPage);

        // Actualizar el contador de página
        pageInfo.textContent = `Página ${currentPage} de ${totalPages} (${filteredMembers.length} miembros)`;

        // Actualizar estado de los botones de paginación
        if (prevButton) {
          prevButton.disabled = currentPage <= 1;
          prevButton.onclick = () => {
            if (currentPage > 1) {
              currentPage--;
              updateTable();
              updatePaginationInfo();
            }
          };
        }
        if (nextButton) {
          nextButton.disabled = currentPage >= totalPages;
          nextButton.onclick = () => {
            if (currentPage < totalPages) {
              currentPage++;
              updateTable();
              updatePaginationInfo();
            }
          };
        }
      }

      // Expose openModal to window for onclick access
      window.openMemberModal = openModal;

      // Inicializar la tabla
      initTable();
    });
  </script>

  <div
    id="roster-container"
    class="bg-gradient-to-br from-amber-900/20 via-gray-900/40 to-amber-800/10 backdrop-blur-sm border border-amber-600/30 rounded-md p-4 mb-20 shadow-2xl hover:border-amber-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-amber-500/10"
  >
    <!-- Grid de miembros -->
    <div
      id="roster-grid"
      class="grid grid-cols-2 gap-2 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3"
    >
      <!-- Los miembros se cargarán aquí dinámicamente -->
    </div>

    <!-- Filtros y Ordenamiento - Diseño Compacto -->
    <div class="filters-container mt-6">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-4 items-end">
        <!-- Buscador -->
        <div class="w-full">
          <label for="search" class="block text-xs font-medium text-text-muted/80 mb-1">
            Buscar nombre
          </label>
          <div class="relative">
            <input
              type="text"
              id="search"
              placeholder="Nombre..."
              class="w-full bg-transparent border border-amber-500/10 rounded-md px-3 py-1.5 text-sm text-white focus:outline-none focus:ring-1 focus:ring-amber-500/50 placeholder-text-muted/50 transition-all duration-200"
            />
            <svg
              class="w-4 h-4 absolute right-3 top-1/2 transform -translate-y-1/2 text-amber-500/60 pointer-events-none"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
            </svg>
          </div>
        </div>

        <!-- Filtro de Clase -->
        <div class="w-full">
          <label for="class-filter" class="block text-xs font-medium text-text-muted/80 mb-1">
            Clase
          </label>
          <div class="relative">
            <select
              id="class-filter"
              class="w-full appearance-none bg-transparent border border-amber-500/10 rounded-md px-3 py-1.5 pr-8 text-sm text-white focus:outline-none focus:ring-1 focus:ring-amber-500/50 placeholder-text-muted/50 transition-all duration-200"
            >
              <option value="">Todas las clases</option>
              {
                Object.entries(rosterData.classInfo).map(([key, info]) => (
                  <option value={key} style={`color: #${info.color}`}>
                    {info.name}
                  </option>
                ))
              }
            </select>
          </div>
        </div>

        <!-- Filtro de Rango -->
        <div class="flex-1 min-w-[150px]">
          <label for="rank-filter" class="block text-xs font-medium text-text-muted/80 mb-1">
            Rango
          </label>
          <div class="select-wrapper">
            <select
              id="rank-filter"
              class="w-full bg-transparent border border-amber-500/10 rounded-md px-3 py-1.5 text-sm text-white focus:outline-none focus:ring-1 focus:ring-amber-500/50 placeholder-text-muted/50 transition-all duration-200"
            >
              <option value="">Todos los rangos</option>
              {
                ranks.map((rank) => (
                  <option value={rank} class="text-white">
                    {rank}
                  </option>
                ))
              }
            </select>
          </div>
        </div>

        <!-- Botones de Ordenamiento -->
        <div class="flex-1 min-w-full sm:min-w-0 mt-2 sm:mt-0">
          <div class="flex flex-wrap gap-2 items-center justify-center">
            <button
              id="sort-name"
              class="sort-button px-3 py-1.5 text-xs rounded-md bg-amber-900/30 border border-amber-700/50 text-amber-100 hover:bg-amber-800/40 hover:border-amber-500/60 transition-all duration-200 flex items-center gap-1.5"
              data-sort="name"
              data-direction="asc"
            >
              <span>Personaje</span>
              <span class="sort-indicator text-amber-400">↕</span>
            </button>
            <button
              id="sort-details"
              class="sort-button px-3 py-1.5 text-xs rounded-md bg-amber-900/30 border border-amber-700/50 text-amber-100 hover:bg-amber-800/40 hover:border-amber-500/60 transition-all duration-200 flex items-center gap-1.5"
              data-sort="publicNote"
              data-direction="none"
            >
              <span>Detalles</span>
              <span class="sort-indicator text-amber-400">↕</span>
            </button>
          </div>
        </div>
      </div>
      <div id="pagination-container" class="mt-4">
        <div class="flex flex-col sm:flex-row justify-center gap-4">
          <!-- Mobile: Stacked layout -->
          <div
            class="w-full flex flex-col sm:flex-row items-center justify-between sm:justify-start gap-4 sm:gap-6"
          >
            <!-- Page info - more compact on mobile -->
            <div id="page-info" class="text-sm text-amber-200/70 whitespace-nowrap">
              <span class="font-medium text-amber-300">Página</span>
              <span id="current-page" class="font-bold text-white">1</span>
              <span class="text-gray-400">de</span>
              <span id="total-pages" class="font-medium">1</span>
              <span class="hidden sm:inline text-gray-400">•</span>
              <span class="hidden sm:inline text-gray-300"
                ><span id="total-members">0</span> miembros</span
              >
            </div>

            <!-- Pagination controls -->
            <div class="flex items-center gap-2">
              <!-- Previous page button -->
              <button
                id="prev-button"
                class="w-9 h-9 flex items-center justify-center rounded-md border border-amber-700/50 bg-amber-900/20 text-amber-200 hover:bg-amber-800/40 hover:border-amber-500/60 disabled:opacity-40 disabled:cursor-not-allowed transition-all duration-200"
                title="Página anterior"
                disabled
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M15 19l-7-7 7-7"></path>
                </svg>
              </button>

              <!-- Page numbers -->
              <div id="page-buttons" class="flex items-center gap-1">
                <!-- Page buttons will be inserted here by JavaScript -->
              </div>

              <!-- Next page button -->
              <button
                id="next-button"
                class="w-9 h-9 flex items-center justify-center rounded-md border border-amber-700/50 bg-amber-900/20 text-amber-200 hover:bg-amber-800/40 hover:border-amber-500/60 transition-all duration-200"
                title="Página siguiente"
              >
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M9 5l7 7-7 7"></path>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="mt-8 flex justify-end opacity-40 hover:opacity-100 transition-opacity duration-500">
    <a href="https://paypal.me/iamdev88" target="_blank" rel="noopener noreferrer" class="group flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-900/30 hover:bg-amber-900/20 border border-transparent hover:border-amber-600/30 transition-all duration-300" title="Apoya el desarrollo">
      <span class="text-[10px] uppercase tracking-wider text-gray-500 group-hover:text-amber-400/80 font-medium transition-colors">Invítame a un café</span>
      <svg class="w-3 h-3 text-gray-600 group-hover:text-amber-500 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
      </svg>
    </a>
  </div>
  </div>
  
  
</div>

<!-- Modal de Detalles del Miembro -->
<div
  id="member-modal"
  class="fixed inset-0 z-[9999] hidden overflow-y-auto"
  aria-labelledby="modal-title"
  role="dialog"
  aria-modal="true"
>
  <!-- Backdrop -->
  <div
    class="fixed inset-0 bg-gray-900/75 backdrop-blur-sm transition-opacity duration-200"
    aria-hidden="true"
    onclick="document.getElementById('member-modal').classList.add('hidden')"
  >
  </div>

  <!-- Modal container -->
  <div class="flex min-h-full items-center justify-center p-4 text-center sm:items-center sm:p-0">
    <!-- Modal panel -->
    <div
      class="relative transform overflow-hidden rounded-md bg-gray-800 border border-amber-600/30 text-left shadow-xl transition-all mt-16 w-full max-w-2xl"
    >
      <!-- Header with Character Info -->
      <div
        class="bg-gray-900/50 px-4 py-3 sm:px-6 border-b border-amber-600/20 flex justify-between items-center"
      >
        <div class="flex items-center space-x-3">
          <div
            id="modal-class-icon"
            class="w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center"
          >
            <!-- Class icon will be inserted here by JavaScript -->
          </div>
          <div class="flex flex-col">
            <span class="text-lg font-bold leading-tight" id="modal-title">
              <span id="modal-character-name" class="italic">Detalles del Personaje</span>
            </span>
            <span id="modal-header-rank" class="text-xs uppercase text-white font-bold"></span>
          </div>
        </div>
        <button
          type="button"
          id="close-modal"
          class="text-gray-400 hover:text-white focus:outline-none"
        >
          <svg
            class="h-6 w-6"
            fill="none"
            viewBox="0 0 24 24"
            stroke-width="1.5"
            stroke="currentColor"
            aria-hidden="true"
          >
            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>

      <!-- Content -->
      <div class="px-4 py-5 sm:p-6">
        <!-- Tabs Navigation -->
        <div class="flex border-b border-gray-700/50 mb-4 overflow-x-auto custom-scrollbar">
          <button
            id="tab-general"
            class="modal-tab px-4 py-2 text-sm font-medium text-amber-400 border-b-2 border-amber-500 transition-all duration-200 whitespace-nowrap"
            onclick="window.switchModalTab('general')"
          >
            General
          </button>

          <button
            id="tab-recognitions"
            class="modal-tab px-4 py-2 text-sm font-medium text-gray-400 border-b-2 border-transparent hover:text-amber-300 transition-all duration-200 flex items-center gap-1.5 whitespace-nowrap"
            onclick="window.switchModalTab('recognitions')"
          >
            Reconocimientos
            <span
              id="badge-recognitions"
              class="hidden px-1.5 py-0.5 text-[10px] font-bold rounded-full bg-amber-500/20 text-amber-300 border border-amber-500/30"
              >0</span
            >
          </button>

          <button
            id="tab-raids"
            class="modal-tab px-4 py-2 text-sm font-medium text-gray-400 border-b-2 border-transparent hover:text-amber-300 transition-all duration-200 flex items-center gap-1.5 whitespace-nowrap"
            onclick="window.switchModalTab('raids')"
          >
            Raids
            <span
              id="badge-raids"
              class="hidden px-1.5 py-0.5 text-[10px] font-bold rounded-full bg-amber-500/20 text-amber-300 border border-amber-500/30"
              >0</span
            >
          </button>
        </div>

        <!-- Tab Panes -->
        <div id="pane-general" class="modal-pane space-y-4">
          <!-- Tags Summary -->
          <div id="modal-tags" class="flex flex-wrap gap-2">
            <!-- Color coded tags will be inserted here -->
          </div>

          <!-- Original Note (Details) -->
          <div class="mt-4">
            <span class="text-sm text-gray-400 block mb-1">Nota Pública (Detalles)</span>
            <p
              id="modal-note"
              class="text-sm text-gray-300 bg-gray-900/50 p-3 rounded-md border border-gray-700/30 italic"
            >
            </p>
          </div>
        </div>

        <!-- Recognitions Tab Content -->
        <div id="pane-recognitions" class="modal-pane hidden space-y-4">
          <div class="bg-gray-900/50 p-4 rounded-md border border-amber-800/30">
            <h4
              class="text-sm font-semibold text-amber-300 mb-3 border-b border-amber-900/50 pb-1 flex items-center gap-2"
            >
              <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                <path
                  d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"
                ></path>
              </svg>
              Reconocimientos Especiales
            </h4>
            <div id="recognitions-container" class="space-y-3">
              <!-- Recognitions will be inserted here by JavaScript -->
              <p class="text-sm text-gray-400 text-center py-4">Cargando reconocimientos...</p>
            </div>
          </div>
        </div>

        <!-- Raids Tab Content -->
        <div id="pane-raids" class="modal-pane hidden space-y-4">
          <div class="bg-gray-900/50 p-4 rounded-md border border-amber-800/30">
            <h4
              class="text-sm font-semibold text-amber-300 mb-3 border-b border-amber-900/50 pb-1 flex items-center gap-2"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M13 10V3L4 14h7v7l9-11h-7z"></path>
              </svg>
              Participación en Raids (Cores)
            </h4>
            <div id="raids-container" class="space-y-3">
              <!-- Raids info will be inserted here by JavaScript -->
              <p class="text-sm text-gray-400 text-center py-4">Cargando información de raids...</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Título de la sección -->
<div class="flex flex-col md:flex-row md:justify-between md:items-end gap-4 px-2 mb-6">
  <div class="flex items-center space-x-4">
    <div
      class="w-12 h-12 bg-gradient-to-br from-amber-600 to-amber-800 rounded-xl flex items-center justify-center shadow-lg shadow-amber-900/20 transform -rotate-2 hover:rotate-0 transition-transform duration-300"
    >
      <svg fill="#000000" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg"
        ><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g
          id="SVGRepo_tracerCarrier"
          stroke-linecap="round"
          stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier">
          <title>droplet-splash</title>
          <path
            d="M25.163 19.626c1.694 0.806 2.733 1.824 2.733 2.944 0 2.584-5.398 4.67-12.062 4.67s-12.062-2.085-12.062-4.67c0-1.12 1.039-2.138 2.733-2.944-3.211 1.041-5.284 2.617-5.284 4.365 0 3.13 6.54 5.685 14.613 5.685s14.613-2.555 14.613-5.685c0-1.748-2.073-3.325-5.284-4.365zM15.833 25.92c4.383 0 7.944-1.396 7.944-3.096 0-0.955-1.152-1.77-2.915-2.335 0.932 0.439 1.531 0.961 1.531 1.573 0 1.403-2.941 2.538-6.559 2.538s-6.559-1.135-6.559-2.538c0-0.613 0.598-1.134 1.531-1.574-1.763 0.565-2.915 1.38-2.915 2.335 0 1.7 3.561 3.096 7.944 3.096zM15.505 5.624c0 0.001 0 0.002 0 0.003 0-0.001 0-0.002 0-0.003l-0 0zM15.688 23.007c2.78 0 5.186-2.144 6.45-5.289-0.4 0.434-0.792 0.687-1.13 0.713-1.016 0.079-1.426-1.868-1.239-4.903-0.412 0.861-0.887 1.397-1.385 1.397-1.425 0-2.603-3.993-2.879-9.297-0.276 5.304-1.453 9.297-2.879 9.297-0.354 0-0.706-0.263-1.020-0.713 0.081 2.619-0.306 4.292-1.239 4.219-0.338-0.026-0.73-0.279-1.13-0.713 1.264 3.145 3.67 5.289 6.45 5.289zM16.968 2.756c0 0.84-0.681 1.52-1.52 1.52s-1.52-0.681-1.52-1.52c0-0.84 0.681-1.52 1.52-1.52s1.52 0.681 1.52 1.52z"
          ></path>
        </g></svg
      >
    </div>
    <div>
      <span class="text-sm md:text-3xl font-black text-white uppercase tracking-tighter italic">
        Estadísticas del <span
          class="text-transparent bg-clip-text bg-gradient-to-r from-amber-200 via-amber-400 to-amber-200 pr-1"
          >Roster</span
        >
      </span>
      <span
        class="text-amber-300/60 font-medium tracking-widest uppercase text-[10px] flex items-center space-x-1"
      >
        <span class="self-end"> Composición de la hermandad </span>
      </span>
    </div>
  </div>
</div>

<!-- Estadísticas del Roster Superiores -->
<div
  class="grid grid-cols-2 sm:grid-cols-4 gap-2 mb-20 bg-gradient-to-br from-amber-900/20 via-gray-900/40 to-amber-800/10 backdrop-blur-sm border border-amber-600/30 rounded-md p-4 shadow-2xl hover:border-amber-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-amber-500/10"
  x-data
>
  <!-- Total de Miembros y Mains/Alts -->
  <div
    x-data="{ expanded: false }"
    class="relative group"
    :class="{ 'z-50': expanded, 'z-0': !expanded }"
    x-cloak
  >
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/50 to-gray-800/60 backdrop-blur-sm border border-amber-600/40 rounded-md p-2 hover:border-amber-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-amber-500/20 rounded-md flex items-center justify-center">
          <svg class="w-5 h-5 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-amber-300/90 uppercase tracking-wide"
            >
              Miembros
            </div>
            <span class="text-xl font-bold text-amber-200 italic">{stats.totalMembers || 0}</span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-amber-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-amber-600/40 rounded-md p-3 shadow-lg"
    >
      <div class="grid grid-cols-2 gap-2">
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{mainAltStats.M || 0}</p>
          <p class="text-[10px] text-amber-300/90 font-medium uppercase">Mains</p>
        </div>
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{mainAltStats.A || 0}</p>
          <p class="text-[10px] text-amber-300/90 font-medium uppercase">Alts</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Distribución de Roles -->
  <div
    x-data="{ expanded: false }"
    class="relative group"
    :class="{ 'z-50': expanded, 'z-0': !expanded }"
    x-cloak
  >
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-blue-600/40 rounded-md p-2 hover:border-blue-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-blue-500/20 rounded-md flex items-center justify-center">
          <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-blue-300/90 uppercase tracking-wide"
            >
              Roles
            </div>
            <span class="text-xl font-bold text-blue-200 italic">
              {Object.values(roleStats).reduce((a, b) => a + b, 0) || 0}
            </span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-blue-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-blue-600/40 rounded-md p-3 shadow-lg"
    >
      <div class="grid grid-cols-3 gap-2">
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{roleStats.T || 0}</p>
          <p class="text-[10px] text-blue-300/90 font-medium uppercase">Tanks</p>
        </div>
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{roleStats.H || 0}</p>
          <p class="text-[10px] text-green-300/90 font-medium uppercase">Healers</p>
        </div>
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{roleStats.D || 0}</p>
          <p class="text-[10px] text-red-300/90 font-medium uppercase">DPS</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Roles Duales -->
  <div
    x-data="{ expanded: false }"
    class="relative group"
    :class="{ 'z-50': expanded, 'z-0': !expanded }"
    x-cloak
  >
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-purple-600/40 rounded-md p-2 hover:border-purple-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-purple-500/20 rounded-md flex items-center justify-center">
          <svg
            class="w-5 h-5 text-purple-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-purple-300/90 uppercase tracking-wide"
            >
              Duales
            </div>
            <span class="text-xl font-bold text-purple-200 italic">
              {dualRoleStats.TH + dualRoleStats.TD + dualRoleStats.HD}
            </span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-purple-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-purple-600/40 rounded-md p-3 shadow-lg"
    >
      <div class="grid grid-cols-3 gap-2">
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{dualRoleStats.TH}</p>
          <p class="text-[10px] text-purple-300/90 font-medium uppercase leading-tight">
            Tank<br />Healer
          </p>
        </div>
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{dualRoleStats.TD}</p>
          <p class="text-[10px] text-purple-300/90 font-medium uppercase leading-tight">
            Tank<br />DPS
          </p>
        </div>
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">{dualRoleStats.HD}</p>
          <p class="text-[10px] text-purple-300/90 font-medium uppercase leading-tight">
            Healer<br />DPS
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Gear Score -->
  <div
    x-data="{ expanded: false }"
    class="relative group"
    :class="{ 'z-50': expanded, 'z-0': !expanded }"
    x-cloak
  >
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-green-600/40 rounded-md p-2 hover:border-green-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-green-500/20 rounded-md flex items-center justify-center">
          <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-green-300/90 uppercase tracking-wide"
            >
              GearScore
            </div>
            <span class="text-xl font-bold text-green-200 italic">
              {averageGearScore !== 'N/A' ? averageGearScore : 'N/A'}
            </span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-green-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-green-600/40 rounded-md p-3 shadow-lg"
    >
      <div class="grid grid-cols-2 gap-2">
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">
            {minGearScore !== 'N/A' ? minGearScore : 'N/A'}
          </p>
          <p class="text-[10px] text-green-300/90 font-medium uppercase">Mínimo</p>
        </div>
        <div class="text-center bg-gray-700/60 rounded p-1.5">
          <p class="text-lg font-bold text-white">
            {maxGearScore !== 'N/A' ? maxGearScore : 'N/A'}
          </p>
          <p class="text-[10px] text-green-300/90 font-medium uppercase">Máximo</p>
        </div>
      </div>
    </div>
  </div>
  <!-- Distribución de Clases -->
  <div
    x-data="{ expanded: false }"
    class="relative group"
    :class="{ 'z-50': expanded, 'z-0': !expanded }"
    x-cloak
  >
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-cyan-600/40 rounded-md p-2 hover:border-cyan-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-cyan-500/20 rounded-md flex items-center justify-center">
          <svg class="w-5 h-5 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-cyan-300/90 uppercase tracking-wide"
            >
              Clases
            </div>
            <span class="text-xl font-bold text-cyan-200 italic">{classDistribution.length}</span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-cyan-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-cyan-600/40 rounded-md p-3 shadow-lg max-h-60 overflow-y-auto custom-scrollbar"
    >
      <div class="space-y-2">
        {
          classDistribution
            .sort((a, b) => b.count - a.count)
            .map((item) => (
              <div class="flex items-center justify-between bg-gray-700/40 rounded p-1.5 px-2">
                <div class="flex flex-col">
                  <span class="text-xs font-medium" style={`color: #${item.color}`}>
                    {item.name}
                  </span>
                  <div class="w-14 md:w-24 h-1 bg-gray-600 rounded-full mt-1 overflow-hidden">
                    <div
                      class="h-full"
                      style={`background-color: #${item.color}; width: ${Math.round((item.count / rosterData.members.length) * 100)}%`}
                    />
                  </div>
                </div>
                <div class="text-right">
                  <span class="text-xs font-bold" style={`color: #${item.color}`}>
                    {item.count}
                  </span>
                  <span class="text-[10px] text-gray-400 ml-1">
                    {Math.round((item.count / rosterData.members.length) * 100)}%
                  </span>
                </div>
              </div>
            ))
        }
      </div>
    </div>
  </div>

  <!-- Distribución de Rangos -->
  <div
    x-data="{ expanded: false }"
    class="relative group"
    :class="{ 'z-50': expanded, 'z-0': !expanded }"
    x-cloak
  >
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-indigo-600/40 rounded-md p-2 hover:border-indigo-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-indigo-500/20 rounded-md flex items-center justify-center">
          <svg
            class="w-5 h-5 text-indigo-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-indigo-300/90 uppercase tracking-wide"
            >
              Rangos
            </div>
            <span class="text-xl font-bold text-indigo-200 italic">{rankDistribution.length}</span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-indigo-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-indigo-600/40 rounded-md p-3 shadow-lg max-h-60 overflow-y-auto custom-scrollbar"
    >
      <div class="space-y-2">
        {
          rankDistribution.map((item) => (
            <div class="flex items-center justify-between bg-gray-700/40 rounded p-1.5 px-2">
              <div class="flex flex-col">
                <span class="text-[10px] md:text-xs font-medium text-gray-200">{item.name}</span>
                <div class="w-14 md:w-24 h-1 bg-gray-600 rounded-full mt-1 overflow-hidden">
                  <div class="h-full bg-indigo-500" style={`width: ${item.percentage}%`} />
                </div>
              </div>
              <div class="text-right">
                <span class="text-xs font-bold text-indigo-300">{item.count}</span>
                <span class="text-[10px] text-gray-400 ml-1">{item.percentage}%</span>
              </div>
            </div>
          ))
        }
      </div>
    </div>
  </div>

  <!-- Distribución por Profesión -->
  <div x-data="{ expanded: false }" class="relative group" x-cloak>
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-emerald-600/40 rounded-md p-2 hover:border-emerald-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-emerald-500/20 rounded-md flex items-center justify-center">
          <svg
            class="w-5 h-5 text-emerald-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-emerald-300/90 uppercase tracking-wide"
            >
              Profesiones
            </div>
            <span class="text-xl font-bold text-emerald-200 italic">
              {professionDistribution.filter((i) => i.name !== 'No Censada').length}
            </span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-emerald-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-emerald-600/40 rounded-md p-3 shadow-lg max-h-60 overflow-y-auto custom-scrollbar"
    >
      <div class="space-y-2">
        {
          professionDistribution.map((item) => (
            <div class="flex items-center justify-between bg-gray-700/40 rounded p-1.5 px-2">
              <div class="flex flex-col">
                <span class="text-xs font-medium text-gray-200">{item.name}</span>
                <div class="w-14 md:w-24 h-1 bg-gray-600 rounded-full mt-1 overflow-hidden">
                  <div class="h-full bg-emerald-500" style={`width: ${item.percentage}%`} />
                </div>
              </div>
              <div class="text-right">
                <span class="text-xs font-bold text-emerald-300">{item.count}</span>
                <span class="text-[10px] text-gray-400 ml-1">{item.percentage}%</span>
              </div>
            </div>
          ))
        }
      </div>
    </div>
  </div>

  <!-- Distribución por Raza -->
  <div x-data="{ expanded: false }" class="relative group" x-cloak>
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-orange-600/40 rounded-md p-2 hover:border-orange-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-orange-500/20 rounded-md flex items-center justify-center">
          <svg
            class="w-5 h-5 text-orange-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-orange-300/90 uppercase tracking-wide"
            >
              Razas
            </div>
            <span class="text-xl font-bold text-orange-200 italic">
              {raceDistribution.filter((i) => i.name !== 'No Censada').length}
            </span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-orange-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-orange-600/40 rounded-md p-3 shadow-lg max-h-60 overflow-y-auto custom-scrollbar"
    >
      <div class="space-y-2">
        {
          raceDistribution.map((item) => (
            <div class="flex items-center justify-between bg-gray-700/40 rounded p-1.5 px-2">
              <div class="flex flex-col">
                <span class="text-xs font-medium text-gray-200">{item.name}</span>
                <div class="w-14 md:w-24 h-1 bg-gray-600 rounded-full mt-1 overflow-hidden">
                  <div class="h-full bg-orange-500" style={`width: ${item.percentage}%`} />
                </div>
              </div>
              <div class="text-right">
                <span class="text-xs font-bold text-orange-300">{item.count}</span>
                <span class="text-[10px] text-gray-400 ml-1">{item.percentage}%</span>
              </div>
            </div>
          ))
        }
      </div>
    </div>
  </div>

  <!-- Distribución por Facción -->
  <div
    x-data="{ expanded: false }"
    class="relative group"
    :class="{ 'z-50': expanded, 'z-0': !expanded }"
    x-cloak
  >
    <div
      @click="expanded = !expanded"
      class="cursor-pointer bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-rose-600/40 rounded-md p-2 hover:border-rose-500/60 transition-all duration-200"
    >
      <div class="flex items-center justify-around">
        <div class="w-8 h-8 bg-rose-500/20 rounded-md flex items-center justify-center">
          <svg class="w-5 h-5 text-rose-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M3 21v-4m0 0V5a2 2 0 012-2h6.5l1 1H21l-3 6 3 6h-8.5l-1-1H5a2 2 0 00-2 2zm9-7h.01M9 16h.01"
            ></path>
          </svg>
        </div>
        <div class="flex items-center space-x-2">
          <div class="text-center">
            <div
              class="text-[10px] md:text-xs font-medium text-rose-300/90 uppercase tracking-wide"
            >
              Facciones
            </div>
            <span class="text-xl font-bold text-rose-200 italic">
              {factionDistribution.filter((i) => i.name !== 'No Censada').length}
            </span>
          </div>
        </div>
        <div class="text-right">
          <div
            class="w-4 h-4 text-rose-400/70 transform transition-transform duration-200 ml-auto"
            :class="{'rotate-180': expanded}"
          >
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-4 h-4">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>
    </div>
    <div
      x-show="expanded"
      x-collapse
      x-transition:enter="transition ease-out duration-200"
      x-transition:enter-start="opacity-0 transform scale-95"
      x-transition:enter-end="opacity-100 transform scale-100"
      x-transition:leave="transition ease-in duration-150"
      x-transition:leave-start="opacity-100 transform scale-100"
      x-transition:leave-end="opacity-0 transform scale-95"
      class="absolute z-10 w-full mt-1 bg-gray-800/95 backdrop-blur-sm border border-rose-600/40 rounded-md p-3 shadow-lg"
    >
      <div class="space-y-2">
        {
          factionDistribution.map((item) => (
            <div class="flex items-center justify-between bg-gray-700/40 rounded p-1.5 px-2">
              <div class="flex flex-col">
                <span class="text-xs font-medium text-gray-200">{item.name}</span>
                <div class="w-14 md:w-24 h-1 bg-gray-600 rounded-full mt-1 overflow-hidden">
                  <div class="h-full bg-rose-500" style={`width: ${item.percentage}%`} />
                </div>
              </div>
              <div class="text-right">
                <span class="text-xs font-bold text-rose-300">{item.count}</span>
                <span class="text-[10px] text-gray-400 ml-1">{item.percentage}%</span>
              </div>
            </div>
          ))
        }
      </div>
    </div>
  </div>
</div>
