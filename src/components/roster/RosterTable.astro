---
// Definir las props del componente
interface Props {
  initialRosterData?: any[];
}

// Obtener las props
const { initialRosterData: rosterDataFromProps = [] } = Astro.props;

// Define default class info with TypeScript type
const defaultClassInfo: Record<string, { name: string; color: string }> = {
  Guerrero: { color: 'C79C6E', name: 'Guerrero' },
  Paladín: { color: 'F58CBA', name: 'Paladín' },
  Cazador: { color: 'ABD473', name: 'Cazador' },
  Pícaro: { color: 'FFF569', name: 'Pícaro' },
  Sacerdote: { color: 'FFFFFF', name: 'Sacerdote' },
  'Caballero de la Muerte': { color: 'C41F3B', name: 'Caballero de la Muerte' },
  Chamán: { color: '0070DE', name: 'Chamán' },
  Mago: { color: '69CCF0', name: 'Mago' },
  Brujo: { color: '9482C9', name: 'Brujo' },
  Druida: { color: 'FF7D0A', name: 'Druida' },
};

// Import types and constants from roster types
import type {
  RosterMember as RosterMemberType,
  RosterData as RosterDataType,
  EventBlock,
  ClassName as ClassNameType,
  Role,
  MainAlt,
  ProfessionCode,
  RaidCode,
  DifficultyCode,
  PublicNoteValidation as RosterPublicNoteValidation,
  MainAltDistributionItem as MainAltDistItem,
  NoteBlock,
  Member,
  RosterStats,
  RaidInfo,
} from '../../types/roster';

// Usar los tipos directamente desde la importación

// Import roster utilities
import {
  validatePublicNote as validateRosterNote,
  calculateRoleDistribution as calculateRoleDistro,
  calculateGearScoreStats as calculateGSStats,
  countRaidLeaders as countLeaders,
  calculateMainAltDistribution as calculateMainAlts,
  PROFESSION_CODES,
} from '../../utils/rosterUtils';

type ProfessionCode = (typeof PROFESSION_CODES)[number];

// Variables para las estadísticas de Gear Score
let gearScoreStats = {
  min: 0,
  max: 0,
  avg: 0,
  total: 0,
  mainGearScore: 0,
  dualGearScore: null as number | null,
};
let averageGearScore = 'N/A';
let minGearScore = 'N/A';
let maxGearScore = 'N/A';
let mainGearScore = 'N/A';
let dualGearScore = 'N/A';

// Import constants
import {
  ROLES,
  PROFESSIONS,
  RAID_NAMES,
  DIFFICULTY_NAMES,
  DAY_NAMES,
  RAID_CODES,
  DIFFICULTIES,
  STATUS,
} from '../../types/roster';

// Define initial stats structure
const initialStats: RosterStats = {
  totalMembers: 0,
  roleDistribution: { tank: 0, healer: 0, melee: 0, ranged: 0 },
  gearScoreStats: {
    min: 0,
    max: 0,
    avg: 0,
    total: 0,
  },
  raidLeadersCount: 0,
  mainAltDistribution: { M: 0, A: 0 },
  professions: {},
  validNotesCount: 0,
};

// Define RAIDS constant with proper typing
const RAIDS: Array<{ code: RaidCode; name: string }> = Object.entries(RAID_NAMES).map(
  ([code, name]) => ({
    code: code as RaidCode,
    name: String(name),
  })
);

// Initialize stats with default values
let stats: RosterStats = { ...initialStats };

// Type definitions for the component
interface RoleInfo {
  name: string;
  color: string;
  icon: string;
}

// Usar RosterMemberType importado directamente

// Component props interface
export interface RosterTableProps {
  rosterData: RosterDataType;
  status?: {
    isLoading: boolean;
    error: string | null;
  };
}

// Get props from Astro
const { rosterData: initialRosterData, status = { isLoading: false, error: null } } =
  Astro.props as RosterTableProps;

// Define default roster data structure
const defaultRosterData: RosterData = {
  members: [],
  classInfo: {},
  rankInfo: {},
  classes: [],
  totalMembers: 0,
  guildInfo: {
    name: '',
    realm: '',
    faction: 0,
    level: 25,
    memberCount: 0,
    achievementPoints: 0,
  },
  stats: {
    ...initialStats,
    total: 0,
    raidLeadersCount: 0,
    mainAltDistribution: { M: 0, A: 0 },
    professions: {},
    validNotesCount: 0,
  },
} as const;

// Usar directamente las funciones importadas con sus alias

// Process members with proper typing
const processRosterMember = (member: any): RosterMemberType => {
  const className = (Object.keys(defaultClassInfo) as (keyof typeof defaultClassInfo)[]).includes(
    member.class
  )
    ? (member.class as keyof typeof defaultClassInfo)
    : ('Desconocido' as const);

  // Ensure mainAlt is either 'M' or 'A'
  const mainAlt =
    member.mainAlt === 'main' ? 'M' : member.mainAlt === 'alt' ? 'A' : member.mainAlt || 'A';

  // Validar la nota pública usando el alias importado
  const noteValidation = validateRosterNote(
    member.publicNote || '',
    member.name || '',
    member.officerNote || ''
  );

  // Asegurar que noteValidation cumpla con PublicNoteValidation
  const validNoteValidation: RosterPublicNoteValidation = {
    isValid: noteValidation.isValid || false,
    blocks: noteValidation.blocks || [],
    mainAlt: noteValidation.mainAlt || 'A', // Valor por defecto 'A' si no está definido
    role: noteValidation.role,
    dualRole: noteValidation.dualRole,
    gearScore: noteValidation.gearScore || 0,
    dualGearScore: noteValidation.dualGearScore,
    professions: noteValidation.professions || [],
    isRaidLeader: noteValidation.isRaidLeader || false,
    hasSchedule: noteValidation.hasSchedule || false,
    hasRaids: noteValidation.hasRaids || false,
    schedules: noteValidation.schedules || [],
    raids: noteValidation.raids || [],
    error: noteValidation.error,
    missingFields: noteValidation.missingFields || [],
  };

  // Create a valid RosterMember object with required properties
  const processedMember: RosterMemberType = {
    ...member,
    name: member.name || '',
    class: className,
    rank: member.rank || '',
    publicNote: member.publicNote || '',
    officerNote: member.officerNote || '',
    noteValidation: validNoteValidation,
    mainAlt: mainAlt as MainAlt,
  };

  return processedMember;
};

// Las funciones de cálculo ahora se importan desde rosterUtils.ts

// Define the roster data with proper typing
// Procesar los miembros del roster
const members = rosterDataFromProps.map(processRosterMember);
const totalMembers = members.length;
const validNotesCount = members.filter((m) => m.publicNote).length;

// Utility function to get role percentage
const getRolePercentage = (count: number, total: number = totalMembers) => {
  return total > 0 ? Math.round((count / total) * 100) : 0;
};

// Calcular las estadísticas de Gear Score
const updateGearScoreStats = () => {
  try {
    const stats = calculateGSStats(members as unknown as RosterMemberType[]);
    gearScoreStats = stats;
    averageGearScore = stats.avg > 0 ? stats.avg.toFixed(1) : 'N/A';
    minGearScore = stats.min > 0 ? stats.min.toFixed(1) : 'N/A';
    maxGearScore = stats.max > 0 ? stats.max.toFixed(1) : 'N/A';
    mainGearScore = stats.mainGearScore > 0 ? stats.mainGearScore.toFixed(1) : 'N/A';
    dualGearScore =
      stats.dualGearScore !== null && stats.dualGearScore > 0
        ? stats.dualGearScore.toFixed(1)
        : 'N/A';
  } catch (error) {
    gearScoreStats = { min: 0, max: 0, avg: 0, total: 0 };
    averageGearScore = 'N/A';
    minGearScore = 'N/A';
    maxGearScore = 'N/A';
  }
};

// Ejecutar el cálculo inicial
updateGearScoreStats();

// Function to ensure roster members have all required properties
function ensureRosterMember(member: Partial<RosterMember>): RosterMember {
  return {
    name: member.name || 'Unknown',
    class: member.class || 'Guerrero',
    rank: member.rank || 'Aspirante',
    publicNote: member.publicNote || '',
    officerNote: member.officerNote || '',
    noteValidation: member.noteValidation || {
      isValid: false,
      mainAlt: 'M',
      role: 'D',
      gearScore: 0,
      professions: [],
      raids: [],
      schedules: [],
      missingFields: [],
      error: 'No note provided',
    },
    ...member,
  };
}

// Process members to ensure they have required properties
const processedMembers = members.map((member) =>
  ensureRosterMember(member as Partial<RosterMember>)
);

// Create the rosterData object with the expected structure
const rosterData: RosterDataWithRankInfo = {
  ...defaultRosterData,
  members: processedMembers,
  totalMembers,
  classInfo: {
    ...defaultClassInfo,
  },
  stats: {
    ...initialStats,
    totalMembers,
    validNotesCount,
    roleDistribution: calculateRoleDistro(processedMembers),
    gearScoreStats: calculateGSStats(processedMembers),
    raidLeadersCount: countLeaders(processedMembers),
    mainAltDistribution: calculateMainAlts(processedMembers),
    professions: {},
  },
  raids: [],
  raidDays: {},
  raidTimes: {},
  rankInfo: {},
} as unknown as RosterDataWithRankInfo;

// Calculate statistics - single implementation
const calculateStats = (members: RosterMember[]): RosterStats => {
  if (!members.length)
    return {
      ...initialStats,
      totalMembers: 0,
      roleDistribution: {},
      gearScoreStats: { min: 0, max: 0, avg: 0, total: 0, mainGearScore: 0, dualGearScore: null },
      raidLeadersCount: 0,
      mainAltDistribution: { M: 0, A: 0 },
      professions: {},
      validNotesCount: 0,
    } as RosterStats;

  // Use members directly with proper type
  const roleDistribution = calculateRoleDistro(members);
  const gearScoreStats = calculateGSStats(members);
  const raidLeadersCount = countLeaders(members);
  const mainAltDistribution = calculateMainAlts(members);
  const validNotesCount = members.filter((m) => m.noteValidation?.isValid).length;

  // Initialize professions object with all possible profession codes set to 0
  const professions: Record<string, number> = {
    JC: 0,
    BS: 0,
    EN: 0,
    EG: 0,
    LW: 0,
    AL: 0,
    TL: 0,
    IN: 0,
    HB: 0,
    MN: 0,
    SK: 0,
  };

  // Initialize profession counts to 0
  PROFESSION_CODES.forEach((code) => {
    professions[code] = 0;
  });

  let totalProcessed = 0;
  let membersWithValidNotes = 0;

  // Process each member's professions
  for (const member of members) {
    // Only process if the note is valid
    if (!member.noteValidation?.isValid) {
      continue;
    }

    membersWithValidNotes++;

    // Get professions from all possible sources
    const profSources: string[] = [];

    // 1. Get professions directly from noteValidation
    if (member.noteValidation?.professions?.length) {
      profSources.push(...member.noteValidation.professions);
    }

    // 2. Get professions from character blocks
    const characterBlocks = (member.noteValidation?.blocks || []).filter(
      (b) => b.type === 'character' && b.parsedData?.professions?.length
    );

    if (characterBlocks.length > 0) {
      characterBlocks.forEach((block) => {
        if (block.parsedData?.professions?.length) {
          profSources.push(...block.parsedData.professions);
        }
      });
    }

    // Filter and normalize profession codes
    const allProfs: string[] = [...new Set(profSources)]
      .filter((code): code is string => Boolean(code)) // Filter and ensure they are strings
      .map((code) => {
        const normalizedCode = code.trim().toUpperCase();
        // Ensure the code has exactly 2 characters
        return normalizedCode.length === 2 ? normalizedCode : null;
      })
      .filter((code): code is string => Boolean(code)) // Remove null codes after normalization
      .filter((code): code is ProfessionCode => {
        const isValid = PROFESSION_CODES.includes(code as ProfessionCode);
        if (!isValid && code) {
          console.warn(`  Unrecognized profession code: "${code}"`);
        }
        return isValid;
      }) as ProfessionCode[]; // Ensure TypeScript knows these are valid profession codes

    // Count the professions
    allProfs.forEach((profCode) => {
      if (profCode in professions) {
        professions[profCode]++;
        totalProcessed++;
      } else {
        console.warn(`  Unrecognized profession code: ${profCode}`);
      }
    });
  }

  // Verificar si hay alguna profesión con conteo > 0
  const hasProfessions = Object.values(professions).some((count) => count > 0);

  if (!hasProfessions) {
    console.warn('No se encontraron profesiones en ninguna nota. Revisar el formato de las notas.');
  }

  // Actualizar las estadísticas globales
  stats.validNotesCount = membersWithValidNotes;
  stats.professions = professions;

  return {
    totalMembers: members.length,
    roleDistribution,
    gearScoreStats,
    raidLeadersCount,
    mainAltDistribution,
    professions,
    validNotesCount: membersWithValidNotes,
  };
};

// mainAltStats se define más abajo con un cálculo más completo

// Calcular estadísticas completas del roster
const calculatedStats = calculateStats(rosterData.members);

// Actualizar las estadísticas del roster
stats = {
  ...stats,
  totalMembers: rosterData.totalMembers,
  validNotesCount: calculatedStats.validNotesCount || 0,
  professions: calculatedStats.professions || {},
};

// Asegurarse de que rosterData.stats tenga las estadísticas actualizadas
rosterData.stats = {
  ...rosterData.stats,
  ...calculatedStats,
};

// Inicializar roleStats contando cada rol (T, H, D) independientemente de si es rol principal o dual
// Un jugador puede contribuir a múltiples roles si tiene un rol dual
const roleStats = {
  T: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'T' || member.noteValidation?.dualRole === 'T'
  ).length,
  H: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'H' || member.noteValidation?.dualRole === 'H'
  ).length,
  D: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'D' || member.noteValidation?.dualRole === 'D'
  ).length,
};

// Contar roles duales por separado
const dualRoleStats = {
  TH: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'T' && member.noteValidation?.dualRole === 'H') ||
      (member.noteValidation?.role === 'H' && member.noteValidation?.dualRole === 'T')
  ).length,
  TD: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'T' && member.noteValidation?.dualRole === 'D') ||
      (member.noteValidation?.role === 'D' && member.noteValidation?.dualRole === 'T')
  ).length,
  HD: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'H' && member.noteValidation?.dualRole === 'D') ||
      (member.noteValidation?.role === 'D' && member.noteValidation?.dualRole === 'H')
  ).length,
};

// Format role distribution for display
const formattedRoleDistribution = Object.entries(rosterData.stats.roleDistribution || {})
  .filter(([_, count]) => count > 0)
  .map(([role, count]) => ({
    role,
    count: Number(count) || 0,
    percentage: getRolePercentage(Number(count) || 0, stats.totalMembers),
  }));

// Mapeo de roles a nombres completos y colores
interface RoleInfo {
  name: string;
  color: string;
  bgColor: string;
}

const roleNames: Record<string, RoleInfo> = {
  T: { name: 'Tanque', color: 'text-blue-300', bgColor: 'bg-blue-500/20' },
  H: { name: 'Sanador', color: 'text-green-300', bgColor: 'bg-green-500/20' },
  D: { name: 'DPS', color: 'text-red-300', bgColor: 'bg-red-500/20' },
};

// Mapeo de colores para las profesiones
const professionColors: Record<string, string> = {
  AL: 'bg-green-500/20 text-green-300',
  HB: 'bg-green-500/20 text-green-300',
  TL: 'bg-pink-500/20 text-pink-300',
  EN: 'bg-purple-500/20 text-purple-300',
  EG: 'bg-blue-500/20 text-blue-300',
  JC: 'bg-yellow-500/20 text-yellow-300',
  BS: 'bg-gray-500/20 text-gray-300',
  IN: 'bg-indigo-500/20 text-indigo-300',
  MN: 'bg-gray-600/20 text-gray-400',
  SK: 'bg-orange-500/20 text-orange-300',
  LW: 'bg-amber-500/20 text-amber-300',
};

// Mapeo de colores para las dificultades
const difficultyColors: Record<string, string> = {
  '10N': 'bg-blue-500/20 text-blue-300',
  '10H': 'bg-blue-700/20 text-blue-400',
  '25N': 'bg-purple-500/20 text-purple-300',
  '25H': 'bg-red-500/20 text-red-300',
};

// Función para obtener el color de fondo basado en la clase del personaje
function getClassColor(className: string): string {
  const classColors: Record<string, string> = {
    Guerrero: 'bg-[#C79C6E]',
    Paladín: 'bg-[#F58CBA]',
    Cazador: 'bg-[#ABD473]',
    Pícaro: 'bg-[#FFF569]',
    Sacerdote: 'bg-[#FFFFFF]',
    'Caballero de la Muerte': 'bg-[#C41F3B]',
    Chamán: 'bg-[#0070DE]',
    Mago: 'bg-[#69CCF0]',
    Brujo: 'bg-[#9482C9]',
    Monje: 'bg-[#00FF96]',
    Druida: 'bg-[#FF7D0A]',
    'Cazador de demonios': 'bg-[#A330C9]',
  };
  return classColors[className] || 'bg-gray-500';
}

// Función para obtener el color de la profesión
function getProfessionColor(profCode: ProfessionCode): string {
  const professionColors = {
    JC: { light: 'bg-yellow-500/20', dark: 'text-yellow-300' },
    BS: { light: 'bg-gray-500/20', dark: 'text-gray-300' },
    EN: { light: 'bg-purple-500/20', dark: 'text-purple-300' },
    EG: { light: 'bg-blue-500/20', dark: 'text-blue-300' },
    LW: { light: 'bg-amber-500/20', dark: 'text-amber-300' },
    AL: { light: 'bg-green-500/20', dark: 'text-green-300' },
    TL: { light: 'bg-pink-500/20', dark: 'text-pink-300' },
    IN: { light: 'bg-indigo-500/20', dark: 'text-indigo-300' },
    HB: { light: 'bg-green-500/20', dark: 'text-green-300' },
    MN: { light: 'bg-gray-600/20', dark: 'text-gray-400' },
    SK: { light: 'bg-orange-500/20', dark: 'text-orange-300' },
  };

  const color = professionColors[profCode] || { light: 'bg-gray-500/20', dark: 'text-gray-400' };
  return `${color.light} ${color.dark}`;
}

// Extend RosterMemberType with additional properties
interface MainAltDistributionItem extends DistributionItem {
  type: 'M' | 'A';
  name: string;
  count: number;
  percentage: number;
  color?: string;
}

// Import types from the types file
import type {
  RosterMember as RosterMemberType,
  PublicNoteValidation as RosterPublicNoteValidation,
  RosterData as BaseRosterData,
  RosterStats,
  ClassName,
  Role,
  MainAlt,
  Member,
  PublicNoteValidation,
} from '../../types/roster';

// Define the default note validation object
const defaultNoteValidation: PublicNoteValidation = {
  isValid: false,
  blocks: [],
  isRaidLeader: false,
  hasSchedule: false,
  hasRaids: false,
};

// Define a type for the roster member with all required properties
type RosterMember = Omit<RosterMemberType, 'noteValidation'> & {
  name: string;
  class: ClassName;
  rank: string;
  publicNote?: string;
  officerNote?: string;
  noteValidation: PublicNoteValidation;
  _priority?: number;
  mainAlt: MainAlt;
  role?: Role;
  // Add index signature to allow dynamic property access with type safety
  [key: string]: unknown;
};

// Type guard to check if a member has noteValidation
function hasNoteValidation(
  member: RosterMember
): member is RosterMember & { noteValidation: RosterPublicNoteValidation } {
  return member.noteValidation !== undefined;
}

// Type for the member parameter in array methods
type MemberCallback = (member: RosterMember) => void;

// Extend the base RosterData type to include rankInfo
type RosterDataWithRankInfo = Omit<BaseRosterData, 'members' | 'stats' | 'rankInfo'> & {
  members: RosterMember[];
  stats: RosterStats;
  rankInfo: Record<string, { name: string; order: number }>;
  // Add missing properties from BaseRosterData
  classInfo: Record<string, ClassInfo>;
  name: string;
  order: number;
  classes: string[];
  totalMembers: number;
  raids: any[];
  raidDays: Record<string, unknown>;
  raidTimes: Record<string, unknown>;
};

// Type for the member parameter in array methods
type MemberCallback = (member: RosterMember) => void;

// Calculate main/alt distribution
const calculateMainAltDistribution = (members: Member[]): { M: number; A: number } => {
  const result = { M: 0, A: 0 };

  for (const member of members) {
    const mainAlt = member.noteValidation?.mainAlt || 'A'; // Default to 'A' if not specified
    if (mainAlt === 'M') {
      result.M++;
    } else {
      // Count as Alt if not explicitly marked as Main
      result.A++;
    }
  }

  return result;
};

// ==========================================
// TIPOS Y UTILIDADES
// ==========================================

// Format event block for display
const formatEventBlock = (event: {
  days?: string[];
  time?: string;
  raid?: string;
  difficulty?: string;
  isRaidLeader?: boolean;
}): string[] => {
  if (!event) return [];

  const formatted: string[] = [];

  // Format days
  if (event.days?.length) {
    const dayNames = event.days.map((day) => {
      const dayCode = day.toUpperCase();
      return DAY_NAMES[dayCode as keyof typeof DAY_NAMES] || day;
    });

    let daysText = '';
    if (dayNames.length === 1) {
      daysText = dayNames[0];
    } else if (dayNames.length > 1) {
      const lastDay = dayNames.pop();
      daysText = `${dayNames.join(', ')} y ${lastDay}`;
    }

    if (daysText) {
      formatted.push(`<span class="text-yellow-400">${daysText}</span>`);
    }
  }

  // Format time
  if (event.time) {
    formatted.push(`<span class="text-blue-300">${event.time}</span>`);
  }

  // Format raid
  if (event.raid) {
    const raidName = RAID_NAMES[event.raid as keyof typeof RAID_NAMES] || event.raid;
    formatted.push(`<span class="text-purple-300">${raidName}</span>`);
  }

  // Format difficulty
  if (event.difficulty) {
    const difficultyName =
      DIFFICULTY_NAMES[event.difficulty as keyof typeof DIFFICULTY_NAMES] || event.difficulty;
    formatted.push(`<span class="text-green-300">${difficultyName}</span>`);
  }

  // Add Raid Leader tag if needed
  if (event.isRaidLeader) {
    formatted.push('<span class="text-yellow-300 font-bold">RL</span>');
  }

  return formatted;
};

type ClassName =
  | 'Guerrero'
  | 'Paladín'
  | 'Cazador'
  | 'Pícaro'
  | 'Sacerdote'
  | 'Caballero de la Muerte'
  | 'Chamán'
  | 'Mago'
  | 'Brujo'
  | 'Druida';

// Use imported types from roster.ts

interface RaidInfo {
  name: string;
  difficulty?: string;
  code: string;
  difficultyCode?: string;
}

interface PublicNoteValidation {
  isValid: boolean;
  mainAlt?: MainAlt;
  role?: Role;
  dualRole?: Role;
  gearScore?: string;
  professions?: string[];
  schedules?: string[];
  raids?: RaidInfo[];
  isRaidLeader?: boolean;
  error?: string;
  missingFields?: string[];
  days?: string[];
}

interface ClassInfo {
  color: string;
  name: string;
}

interface RosterData {
  members: RosterMember[];
  classInfo: Record<string, ClassInfo>;
  rankInfo: Record<string, { name: string; order: number }>;
}

// Validar nota pública según el formato requerido
function validatePublicNote(
  note: string | undefined,
  characterName: string = 'Desconocido',
  officerNote: string = ''
): RosterPublicNoteValidation {
  // Usar la función importada que combina notas públicas y oficiales
  const result = validateRosterNote(note, characterName, officerNote);

  // Crear un objeto con los valores por defecto según la interfaz
  const validated: RosterPublicNoteValidation = {
    isValid: result.isValid || false,
    blocks: result.blocks || [],
    isRaidLeader: result.isRaidLeader || false,
    hasSchedule: result.hasSchedule || false,
    hasRaids: result.hasRaids || false,
    missingFields: result.missingFields || [],
    // Propiedades opcionales
    mainAlt: result.mainAlt,
    role: result.role,
    dualRole: result.dualRole,
    gearScore: result.gearScore,
    professions: result.professions,
    schedules: result.schedules,
    raids: result.raids,
    error: result.error,
  };

  return validated;
}

// Función auxiliar para validar notas (mantener para compatibilidad)
function validateNoteLegacy(
  note: string | undefined,
  characterName: string = 'Desconocido'
): RosterPublicNoteValidation {
  const errors: string[] = [];
  const missingFields: string[] = [];
  const result: RosterPublicNoteValidation & { blocks?: Array<{ type: string; parsedData: any }> } =
    {
      isValid: false,
      raids: [],
      blocks: [],
    };

  if (!note?.trim()) {
    return { ...result, error: 'La nota pública no puede estar vacía' };
  }

  const trimmedNote = note.trim();
  const parts = trimmedNote.split(/\s+/); // Dividir por cualquier espacio en blanco

  // 1. Detección de Main/Alt (M/A) - Prioridad a patrones con roles

  // Patrón 1: M o A seguido de rol (ej: 'MT', 'AD', 'MH', 'AH', 'at', 'md')
  const mainAltWithRole = trimmedNote.match(/^([MA])([THD])(?![a-zA-Z])/i);

  // Patrón para notas con gear score (ej: 'AD5.9', 'at5.7')
  const gearScorePattern = trimmedNote.match(/^([MA])([THD])(\d+(?:\.\d+)?)/i);

  // Patrón para notas con profesiones (ej: 'adALHB', 'ad6.6TLBS')
  const professionPattern = trimmedNote.match(/^([MA])([THD])(\d+(?:\.\d+)?)?([A-Za-z]{2,})/i);

  // Patrón para notas de raid (ej: 'AT5.9 M20RLTOC25N')
  const raidPatternMatch = trimmedNote.match(
    /^([MA])([THD])(\d+(?:\.\d+)?)?(?:\s+([A-Za-z0-9]+))?/i
  );

  if (mainAltWithRole || gearScorePattern || professionPattern || raidPatternMatch) {
    // Extraer la información del patrón coincidente
    let mainAlt,
      role,
      gearScore = 0,
      professions = [];
    let raidInfo = null;

    if (mainAltWithRole) {
      mainAlt = mainAltWithRole[1].toUpperCase() as MainAlt;
      role = mainAltWithRole[2].toUpperCase() as Role;
    } else if (gearScorePattern) {
      mainAlt = gearScorePattern[1].toUpperCase() as MainAlt;
      role = gearScorePattern[2].toUpperCase() as Role;
      gearScore = parseFloat(gearScorePattern[3]);
    } else if (professionPattern) {
      mainAlt = professionPattern[1].toUpperCase() as MainAlt;
      role = professionPattern[2].toUpperCase() as Role;
      if (professionPattern[3]) {
        gearScore = parseFloat(professionPattern[3]);
      }
      // Extraer códigos de profesión (2 letras cada uno)
      const profCodes = (professionPattern[4] || '').match(/[A-Za-z]{2}/g) || [];
      professions = profCodes.map((p) => p.toUpperCase() as ProfessionCode);
    } else if (raidPatternMatch) {
      mainAlt = raidPatternMatch[1].toUpperCase() as MainAlt;
      role = raidPatternMatch[2].toUpperCase() as Role;
      if (raidPatternMatch[3]) {
        gearScore = parseFloat(raidPatternMatch[3]);
      }
      // Procesar información de raid si está presente
      if (raidPatternMatch[4]) {
        const raidMatch = raidPatternMatch[4].match(/([A-Za-z]+)(\d+)([NH])?/i);
        if (raidMatch) {
          raidInfo = {
            code: raidMatch[1].toUpperCase(),
            difficulty: raidMatch[3] ? `${raidMatch[2]}${raidMatch[3]}` : undefined,
            isRaidLeader: raidPattern[4].toLowerCase().includes('rl'),
          };
        }
      }
    }

    // Crear el bloque de personaje
    const characterBlock: NoteBlock = {
      type: 'character',
      content: trimmedNote,
      isValid: true,
      parsedData: {
        mainAlt,
        role,
        mainRole: role,
        mainGearScore: gearScore,
        professions: professions,
      },
    };

    // Crear el objeto de resultado
    const validationResult: RosterPublicNoteValidation = {
      isValid: true,
      blocks: [characterBlock],
      mainAlt,
      role,
      mainRole: role,
      gearScore: gearScore,
      professions: professions,
      schedules: [],
      raids: raidInfo
        ? [
            {
              code: raidInfo.code as RaidCode,
              difficulty: (raidInfo.difficulty as DifficultyCode) || '10N',
              name: raidInfo.code,
              difficultyCode: (raidInfo.difficulty as DifficultyCode) || '10N',
              isRaidLeader: raidInfo.isRaidLeader || false,
            },
          ]
        : [],
      isRaidLeader: raidInfo?.isRaidLeader || false,
      hasSchedule: false,
      hasRaids: !!raidInfo,
      missingFields: [],
    };

    // Si es un patrón simple (AD, AT, etc.), marcar como válido y salir
    if (trimmedNote.length === 2 || (gearScore && trimmedNote.length <= 10)) {
      // Asegurarse de que el bloque de personaje tenga toda la información necesaria
      const charBlock: NoteBlock = {
        type: 'character',
        content: trimmedNote,
        isValid: true,
        parsedData: {
          mainAlt,
          role,
          mainRole: role,
          mainGearScore: 0,
          professions: [],
        },
      };

      // Crear el resultado final
      const finalResult: RosterPublicNoteValidation = {
        isValid: true,
        blocks: [charBlock],
        mainAlt,
        role,
        mainRole: role,
        gearScore: 0,
        professions: [],
        schedules: [],
        raids: [],
        isRaidLeader: false,
        hasSchedule: false,
        hasRaids: false,
        missingFields: [],
      };

      return finalResult;
    }

    // Actualizar el resultado actual
    Object.assign(result, validationResult);
  } else {
    // Si no coincide el primer patrón, intentar con el patrón de dos letras
    const twoLetterPattern = trimmedNote.match(/^([a-zA-Z]{2})(?:\s|$)/i);
    if (twoLetterPattern) {
      const code = twoLetterPattern[1].toUpperCase();

      // Verificar si el código es un patrón de rol (primera letra M/A, segunda T/H/D)
      const roleMatch = code.match(/^([MA])([THD])$/i);
      if (roleMatch) {
        const mainAlt = roleMatch[1].toUpperCase() as MainAlt;
        const role = roleMatch[2].toUpperCase() as Role;

        const charBlock: NoteBlock = {
          type: 'character',
          content: code,
          isValid: true,
          parsedData: {
            mainAlt,
            role,
            mainRole: role,
            mainGearScore: 0,
            professions: [],
          },
        };

        return {
          isValid: true,
          blocks: [charBlock],
          mainAlt,
          role,
          mainRole: role,
          gearScore: 0,
          professions: [],
          schedules: [],
          raids: [],
          isRaidLeader: false,
          hasSchedule: false,
          hasRaids: false,
          missingFields: [],
        };
      }
    }
  }

  // Patrones adicionales...
  if (!result.role) {
    const twoLetterPattern = trimmedNote.match(/^([a-zA-Z]{2})(?:\s|$)/i);
    if (twoLetterPattern) {
      const [_, code] = twoLetterPattern;
      const upperCode = code.toUpperCase();
      const validRoles = ['T', 'H', 'D'];
      const validMains = ['M', 'A'];

      const firstChar = upperCode[0];
      const secondChar = upperCode[1];

      // Caso 1: Primera letra es M/A y segunda es T/H/D (ej: MT, AD, MH, MD)
      if (validMains.includes(firstChar) && validRoles.includes(secondChar)) {
        result.mainAlt = firstChar as MainAlt;
        result.role = secondChar as Role;
        result.mainRole = secondChar as Role;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              role: result.role,
              mainRole: result.role,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 2: Primera letra es T/H/D y segunda es M/A (ej: TM, HA, DM)
      else if (validRoles.includes(firstChar) && validMains.includes(secondChar)) {
        result.role = firstChar as Role;
        result.mainRole = firstChar as Role;
        result.mainAlt = secondChar as MainAlt;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              role: result.role,
              mainRole: result.role,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 3: Cualquier combinación de dos letras de rol (ej: TH, HD, DT)
      else if (validRoles.includes(firstChar) && validRoles.includes(secondChar)) {
        result.role = firstChar as Role;
        result.mainRole = firstChar as Role;
        result.dualRole = secondChar as Role;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              role: result.role,
              mainRole: result.role,
              dualRole: result.dualRole,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 4: Primera letra es M/A y segunda es M/A (ej: MA, AM)
      else if (validMains.includes(firstChar) && validMains.includes(secondChar)) {
        result.mainAlt = firstChar as MainAlt;
        result.isValid = true;

        // Crear bloque de personaje mínimo
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }

      // Si encontramos un patrón válido de dos letras, asegurar que los campos requeridos estén establecidos
      if (result.isValid) {
        // Asegurar que siempre haya un valor para mainRole
        result.mainRole = result.mainRole || result.role;
        return result;
      }
    }
  }

  // Patrón 2: M o A al inicio de la nota (ej: 'M 5.9', 'A TL/EN', 'a')
  if (!result.mainAlt) {
    const startWithMainAlt = trimmedNote.match(/^([MA])(?:\s+|$)/i);
    if (startWithMainAlt) {
      result.mainAlt = startWithMainAlt[1].toUpperCase() as MainAlt;

      // Si es solo 'a' o 'm', marcar como válido
      if (trimmedNote.match(/^[ma]$/i)) {
        result.isValid = true;
      }
    }
  }

  // Patrón 3: M o A con separador (ej: 'M/Tank', 'A-Healer')
  if (!result.mainAlt) {
    const mainAltWithSeparator = trimmedNote.match(/(?:^|[\s/\-|])([MA])(?=$|[\s/\-|])/i);
    if (mainAltWithSeparator) {
      result.mainAlt = mainAltWithSeparator[1].toUpperCase() as MainAlt;
    }
  }

  // Patrón 4: M o A en cualquier parte como palabra completa (último recurso)
  if (!result.mainAlt) {
    const mainAltAnywhere = trimmedNote.match(/(?:^|\s)([MA])(?:\s|$)/i);
    if (mainAltAnywhere) {
      result.mainAlt = mainAltAnywhere[1].toUpperCase() as MainAlt;
    }
  }

  // 2. Buscar si es Raid Leader (RL o rl)
  // Primero buscar el formato específico '20:00xRLICC25N' o similar
  result.isRaidLeader = /\d{1,2}[:.]?\d{0,2}xRL/.test(trimmedNote);

  // Si no se encontró, buscar otros patrones comunes
  if (!result.isRaidLeader) {
    // Buscar patrones como 'RL', 'rl', 'RaidLeader', 'raid leader', etc.
    result.isRaidLeader = /(?:^|\s|\d*[xX]?\s*)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl)\b/i.test(
      trimmedNote
    );
  }

  // 3. Buscar roles (T, H, D) y rol dual
  // Primero buscar formato de rol con GS (ej: d5.8, t6.2, D5.8, T6.2)
  const roleWithGS = trimmedNote.match(/^([thdTHD])(\d\.?\d?\d?)$/);
  if (roleWithGS && !result.role) {
    result.role = roleWithGS[1].toUpperCase() as Role;
    result.gearScore = roleWithGS[2];
    result.isValid = true;
  }

  // Buscar formato de 3 letras que comience con A o M (ej: MDT, AHT, etc.)
  const threeLetterRoleMatch = trimmedNote.match(/\b([MA]?)([THD])([THD]?)\b/i);

  if (threeLetterRoleMatch) {
    const [, mainAlt, primaryRole, dualRole] = threeLetterRoleMatch;

    // Si hay un prefijo M o A, establecer mainAlt
    if (mainAlt) {
      result.mainAlt = mainAlt.toUpperCase() as MainAlt;
    } else if (!result.mainAlt && threeLetterRoleMatch[0].startsWith('M')) {
      // Si no hay mainAlt pero el match empieza con M, asumir que es Main
      result.mainAlt = 'M';
    }

    // Establecer rol principal
    result.role = primaryRole.toUpperCase() as Role;

    // Si hay un rol dual, establecerlo
    if (dualRole) {
      const dual = dualRole.toUpperCase() as Role;
      if (dual !== result.role) {
        result.dualRole = dual;
      } else {
        errors.push('El rol secundario no puede ser igual al principal');
      }
    }
  }

  // Si no se encontró un rol dual, buscar cualquier otro rol en la nota
  if (!result.dualRole) {
    // Buscar cualquier letra T, H o D que no sea parte de otra palabra
    const roleMatches = [...trimmedNote.matchAll(/\b([THD])\b/gi)];
    const roles = Array.from(new Set(roleMatches.map((m) => m[1].toUpperCase())));

    // Si hay más de un rol, establecer el segundo como dual
    if (roles.length > 1) {
      const primary = result.role || roles[0];
      const secondary = roles.find((r) => r !== primary) as Role;

      if (secondary) {
        if (!result.role) result.role = primary as Role;
        result.dualRole = secondary;
      }
    } else if (roles.length === 1 && !result.role) {
      // Si solo hay un rol y no se ha establecido, usarlo como principal
      result.role = roles[0] as Role;
    }
  }

  // Si aún no se ha encontrado un rol, buscar en otros formatos
  if (!result.role) {
    // Último intento: buscar cualquier combinación de roles (ej: TH, HD, DT, etc.)
    const dualRoleMatch = trimmedNote.match(/\b([THD]{2,})\b/i);
    if (dualRoleMatch) {
      const rolesStr = dualRoleMatch[1].toUpperCase();
      result.role = rolesStr[0] as Role;
      if (rolesStr.length > 1 && rolesStr[1] !== rolesStr[0]) {
        result.dualRole = rolesStr[1] as Role;
      }
    }
  }

  if (!result.role) {
    missingFields.push(`Rol principal (${Object.keys(ROLES).join(', ')})`);
  }

  // 2. Extraer Gear Score - Múltiples formatos soportados:
  //    - Números de 4 dígitos (ej: 5585 -> 5.5)
  //    - Números decimales con punto o coma (ej: 5.9, 6,2)
  //    - Números después de rol (ej: d5.8, t6.2)
  //    - Números rodeados de cualquier carácter
  //    - Prefijos comunes como 'GS', 'gs', 'ilvl', 'iLvl', etc.
  let gsValue: string | null = null;

  // Patrón 1: Buscar formato XXXX (4 dígitos) en cualquier parte
  const fourDigitMatch = trimmedNote.match(/\b(\d{4})\b/);
  if (fourDigitMatch) {
    const num = parseInt(fourDigitMatch[1]);
    gsValue = (num / 1000).toFixed(1);
  }
  // Patrón 2: Buscar números decimales con punto o coma
  else {
    const decimalMatch = trimmedNote.match(/(\d[\.,]\d\d?)/);
    if (decimalMatch) {
      gsValue = decimalMatch[1].replace(',', '.');
    }
  }

  // Patrón 3: Buscar después de prefijos comunes (GS, ilvl, etc.)
  if (!gsValue) {
    const prefixMatch = trimmedNote.match(
      /(?:GS|gs|ilvl|iLvl|gear|Gear|gs:?\s*)(?:\s*[:=]?\s*)(\d[\.,]?\d?\d?)/i
    );
    if (prefixMatch) {
      gsValue = prefixMatch[1].replace(',', '.');
      // Asegurar formato decimal correcto
      if (!gsValue.includes('.')) {
        gsValue = gsValue + '.0';
      }
    }
  }

  // Validar y guardar el Gear Score encontrado
  if (gsValue) {
    const gsNumber = parseFloat(gsValue);
    if (!isNaN(gsNumber) && gsNumber >= 0.1 && gsNumber <= 10) {
      result.gearScore = gsNumber.toFixed(1);
    } else {
      errors.push('El Gear Score debe estar entre 0.1 y 10');
    }
  } else if (!trimmedNote.match(/GS|gs|ilvl|iLvl|gear|Gear|\d[\.,]\d|\d{4}/i)) {
    // Solo marcar como faltante si no hay ningún indicio de GS en la nota
    missingFields.push('Gear Score (ej: 5.9, 6.2, 5585)');
  }

  // 3. Extraer días de la semana (formato L-V, LMXJV, etc.)
  const dayPattern = /([LMXJVSD])(?:-([LMXJVSD]))?/g;
  const daysSet = new Set<string>();
  let dayMatch;

  while ((dayMatch = dayPattern.exec(trimmedNote)) !== null) {
    const startDay = dayMatch[1];
    const endDay = dayMatch[2];

    if (endDay) {
      // Es un rango de días (ej: L-V)
      const dayOrder = ['L', 'M', 'X', 'J', 'V', 'S', 'D'];
      const startIndex = dayOrder.indexOf(startDay);
      const endIndex = dayOrder.indexOf(endDay);

      if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {
        for (let i = startIndex; i <= endIndex; i++) {
          daysSet.add(dayOrder[i]);
        }
      } else {
        // Si el rango no es válido, agregar solo los días individuales
        daysSet.add(startDay);
        daysSet.add(endDay);
      }
    } else {
      // Es un día individual
      daysSet.add(startDay);
    }
  }

  // Convertir a array y ordenar según el orden de la semana
  const daysArray = Array.from(daysSet).sort((a, b) => {
    const order = { L: 1, M: 2, X: 3, J: 4, V: 5, S: 6, D: 7 };
    return (order[a as keyof typeof order] || 0) - (order[b as keyof typeof order] || 0);
  });

  // Agregar los días al resultado
  if (daysArray.length > 0) {
    result.days = daysArray;
  }

  // 4. Extraer Profesiones - Opcionales pero recomendadas
  const profCodes = Object.keys(PROFESSIONS);
  const profCodesStr = profCodes.join('|');

  const foundProfs = new Set<string>();

  // Caso especial para 'ALMN' (Alquimia + Minería)
  if (trimmedNote.includes('ALMN')) {
    foundProfs.add('AL');
    foundProfs.add('MN');
  } else {
    // Búsqueda normal de códigos de profesión
    const singleProfRegex = new RegExp(
      `(?:^|[^a-zA-Z])(${profCodesStr})(?![a-zA-Z])|(${profCodesStr})$`,
      'gi'
    );
    let singleMatch;

    singleProfRegex.lastIndex = 0;

    while ((singleMatch = singleProfRegex.exec(trimmedNote)) !== null) {
      const code = (singleMatch[1] || singleMatch[2]).toUpperCase() as ProfessionCode;

      if (profCodes.includes(code) && !foundProfs.has(code)) {
        foundProfs.add(code);
        if (foundProfs.size >= 2) break;
      }
    }
  }

  // Si no encontramos códigos individuales, buscar códigos juntos sin separador
  if (foundProfs.size < 2) {
    const combinedProfRegex = /[A-Z]{4,6}/g;
    let combinedMatch;

    while ((combinedMatch = combinedProfRegex.exec(trimmedNote.toUpperCase())) !== null) {
      const combinedText = combinedMatch[0];

      // Buscar códigos de profesión dentro del texto combinado
      let index = 0;
      while (index < combinedText.length) {
        let found = false;

        // Probar con códigos de 2 caracteres primero (más comunes)
        if (index + 2 <= combinedText.length) {
          const possibleCode = combinedText.substring(index, index + 2);
          if (profCodes.includes(possibleCode) && !foundProfs.has(possibleCode)) {
            foundProfs.add(possibleCode as ProfessionCode);
            index += 2;
            found = true;
          }
        }

        // Si no se encontró un código de 2 caracteres, probar con 3
        if (!found && index + 3 <= combinedText.length) {
          const possibleCode = combinedText.substring(index, index + 3);
          if (profCodes.includes(possibleCode) && !foundProfs.has(possibleCode)) {
            foundProfs.add(possibleCode as ProfessionCode);
            index += 3;
            found = true;
          }
        }

        // Si no se encontró ningún código, avanzar un carácter
        if (!found) {
          index++;
        }

        // No buscar más de 2 profesiones (máximo razonable)
        if (foundProfs.size >= 2) break;
      }

      // Si ya encontramos 2 profesiones, no es necesario seguir buscando
      if (foundProfs.size >= 2) break;
    }
  }

  // Si no encontramos códigos juntos, buscar otros patrones
  if (foundProfs.size < 2) {
    // Patrón 2: Buscar el patrón específico 'TL/en' o similar
    const directProfRegex = new RegExp(
      `(?:^|[^a-zA-Z])(${profCodesStr})[/,\s-](${profCodesStr})(?![a-zA-Z])`,
      'gi'
    );
    let directMatch;

    while ((directMatch = directProfRegex.exec(trimmedNote)) !== null) {
      const code1 = directMatch[1].toUpperCase() as ProfessionCode;
      const code2 = directMatch[2].toUpperCase() as ProfessionCode;
      if (profCodes.includes(code1)) foundProfs.add(code1);
      if (profCodes.includes(code2)) foundProfs.add(code2);
      if (foundProfs.size >= 2) break;
    }

    // Patrón 3: Buscar códigos individuales
    if (foundProfs.size < 2) {
      const singleProfRegex = new RegExp(`(?:^|[^a-zA-Z])(${profCodesStr})(?![a-zA-Z])`, 'gi');
      let singleMatch;

      while ((singleMatch = singleProfRegex.exec(trimmedNote)) !== null) {
        const code = singleMatch[1].toUpperCase() as ProfessionCode;
        if (profCodes.includes(code)) {
          foundProfs.add(code);
          if (foundProfs.size >= 2) break;
        }
      }
    }
  }

  // Si encontramos al menos una profesión, actualizar el resultado
  if (foundProfs.size > 0) {
    // Guardamos los códigos de profesión directamente
    result.professions = Array.from(foundProfs);

    // Si solo hay una profesión y es una abreviatura de 2 letras (ej: 'EN'), marcar como válido
    if (foundProfs.size === 1 && Array.from(foundProfs)[0].length === 2) {
      result.isValid = true;
    }
  }

  // La extracción de días ya se realizó anteriormente en la sección 3 del código
  // y ya está disponible en result.days

  // 5. Extraer horarios (pueden ser individuales o rangos con formato HHX-HHX)
  const uniqueHours = new Set<string>();

  // Primero buscamos rangos de días con horario (ej: L-V20:00x, L-V20:00, L-V20x, etc.)
  const dayRangeWithTimeRegex = /([LMXJVS])(?:-([LMXJVS]))?(\d{1,2}:?\d{0,2})X?/gi;
  let dayRangeMatch;

  // Buscar rangos de días con horario
  while ((dayRangeMatch = dayRangeWithTimeRegex.exec(trimmedNote)) !== null) {
    const startDay = dayRangeMatch[1];
    const endDay = dayRangeMatch[2] || startDay; // Si no hay día final, usamos el día inicial
    const timePart = dayRangeMatch[3] || '';

    // Formatear la hora correctamente
    let formattedTime = '';
    if (timePart.includes(':')) {
      const [hours, minutes = '00'] = timePart.split(':');
      formattedTime = `${hours.padStart(2, '0')}:${minutes.padEnd(2, '0')}`;
    } else if (timePart) {
      formattedTime = `${timePart.padStart(2, '0')}:00`;
    }

    if (formattedTime) {
      // Si hay un rango de días (ej: L-V)
      if (startDay && endDay && startDay !== endDay) {
        uniqueHours.add(`${startDay}-${endDay} ${formattedTime}`);
      } else {
        // Si es un solo día (ej: L20:00)
        uniqueHours.add(`${startDay} ${formattedTime}`);
      }
    }
  }

  // Luego buscamos rangos de horas (ej: 20X-23X, 20-23X, 20X-23, 20-23)
  const rangeRegex =
    /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X?\s*-\s*(\d{1,2})(?::(\d{2}))?X(?:$|[^\d])/gi;
  const rangeMatches = [];
  let rangeMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((rangeMatch = rangeRegex.exec(trimmedNote)) !== null) {
    rangeMatches.push(rangeMatch);
  }

  // Procesar rangos de horas (ej: 20X-23X, 20-23X, 20X-23, 20-23)
  rangeMatches.forEach((match) => {
    const startHour = parseInt(match[1], 10);
    const startMinutes = match[2] ? parseInt(match[2], 10) : 0;
    const endHour = parseInt(match[3], 10);
    const endMinutes = match[4] ? parseInt(match[4], 10) : 0;

    // Validar que las horas y minutos estén en rango
    if (
      startHour >= 0 &&
      startHour <= 23 &&
      endHour >= 0 &&
      endHour <= 23 &&
      startMinutes >= 0 &&
      startMinutes <= 59 &&
      endMinutes >= 0 &&
      endMinutes <= 59
    ) {
      const formattedStart = `${startHour.toString().padStart(2, '0')}${startMinutes > 0 ? ':' + startMinutes.toString().padStart(2, '0') : ''}X`;
      const formattedEnd = `${endHour.toString().padStart(2, '0')}${endMinutes > 0 ? ':' + endMinutes.toString().padStart(2, '0') : ''}X`;

      uniqueHours.add(formattedStart);
      uniqueHours.add(formattedEnd);
    }
  });

  // Luego buscamos horas individuales (que no sean parte de un rango)
  // Ahora detecta con o sin espacios alrededor de la X, pero evita falsos positivos
  const hourRegex = /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X(?:$|[^\d-])/gi;
  const hourMatches = [];
  let hourMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((hourMatch = hourRegex.exec(trimmedNote)) !== null) {
    hourMatches.push(hourMatch);
  }

  hourMatches.forEach((match) => {
    const hour = parseInt(match[1], 10);
    const minutes = match[2] ? parseInt(match[2], 10) : 0;

    if (hour >= 0 && hour <= 23 && minutes >= 0 && minutes <= 59) {
      const formattedHour = hour.toString().padStart(2, '0');
      const formattedMinutes = minutes > 0 ? `:${minutes.toString().padStart(2, '0')}` : '';
      uniqueHours.add(`${formattedHour}${formattedMinutes}X`);
    }
  });

  if (uniqueHours.size > 0) {
    result.schedules = Array.from(uniqueHours).sort();
  } else if (!trimmedNote.match(/\d{1,2}(?::\d{2})?X/)) {
    // Solo agregar el mensaje si no hay ningún formato de horario en la nota
    missingFields.push('Horario de conexión (ej: 18X, 21:30X)');
  }

  // 5. Extraer raids y dificultades por separado
  const allRaidCodes = Object.keys(RAID_NAMES) as RaidCode[];
  const raidCodesPattern = allRaidCodes
    .map((rc) => rc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join('|');

  // Inicializar el conjunto de raids encontradas
  result.raids = [];
  const usedRaids = new Set<string>();
  const usedIndices = new Set<string>();

  // 1. Buscar menciones directas de raids
  const raidPattern = new RegExp(`\\b(${raidCodesPattern})\\b`, 'gi');
  let raidMatch;

  while ((raidMatch = raidPattern.exec(trimmedNote)) !== null) {
    const raidCode = raidMatch[1].toUpperCase();

    if (raidCode in RAID_NAMES && !usedRaids.has(raidCode)) {
      result.raids.push({
        code: raidCode as RaidCode,
        difficultyCode: undefined, // Sin dificultad específica
        difficulty: undefined,
        name: RAID_NAMES[raidCode as RaidCode],
      });
      usedRaids.add(raidCode);
    }
  }

  // 2. Buscar dificultades (10n, 25h, etc.)
  const difficultyPattern = /\b(10|25)([hn])\b/gi;
  const foundDifficulties = new Set<string>();
  let diffMatch;

  while ((diffMatch = difficultyPattern.exec(trimmedNote)) !== null) {
    const number = diffMatch[1];
    const difficulty = diffMatch[2].toUpperCase() as 'N' | 'H';
    const difficultyCode = `${number}${difficulty}` as DifficultyCode;
    foundDifficulties.add(difficultyCode);
  }

  // Si no encontramos raids con los patrones anteriores, buscar solo los códigos de raid
  if (result.raids.length === 0) {
    const raidCodePattern = new RegExp(
      `(?:^|[^a-zA-Z])(${raidCodesPattern})(?=$|[^a-zA-Z0-9])`,
      'gi'
    );
    const raidCodeMatches = Array.from(trimmedNote.matchAll(raidCodePattern));

    for (const match of raidCodeMatches) {
      const raidCodeStr = match[0].toUpperCase();
      // Verificar que el código de raid sea uno de los permitidos
      const validRaidCodes: RaidCode[] = [
        'ICC',
        'TOC',
        'ULD',
        'NAX',
        'OS',
        'VOA',
        'EOE',
        'ONY',
        'RS',
      ];
      if (validRaidCodes.includes(raidCodeStr as RaidCode)) {
        const raidCode = raidCodeStr as RaidCode;
        if (!usedRaids.has(raidCode)) {
          // Buscar el raid en el array RAIDS
          const raidInfo = RAIDS.find((r) => r.code === raidCode);
          const raidName = raidInfo ? raidInfo.name : raidCode;

          const raidData: RaidInfo = {
            code: raidCode,
            difficulty: 'Normal', // Valor por defecto
            name: raidName,
            difficultyCode: '10N' as DifficultyCode, // Valor por defecto
            isRaidLeader: false, // Propiedad opcional
          };
          result.raids.push(raidData);
          usedRaids.add(raidCode);
        }
      }
    }
  }

  // Si no encontramos raids aún, intentar con un patrón más flexible
  if (result.raids.length === 0) {
    const escapedRaidCodes = allRaidCodes
      .map((raid) => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
      .join('|');
    const raidPatterns2 = [
      // Patrón para 'icc10n' o 'voa25h' (sin espacios)
      new RegExp(`(${escapedRaidCodes})(\\d+)([NH])`, 'gi'),
      // Patrón para 'icc 10n' o 'voa 25h' (con espacios)
      new RegExp(`(${escapedRaidCodes})\\s*(\\d+)([NH])`, 'gi'),
      // Patrón para solo el código de raid
      new RegExp(`\\b(${escapedRaidCodes})\\b`, 'gi'),
    ];

    for (const pattern of raidPatterns) {
      let match;
      while ((match = pattern.exec(trimmedNote)) !== null) {
        const raidCode = match[1]?.toUpperCase() as RaidCode;
        if (!raidCode) continue;

        // Type assertion to handle the indexing
        const raidName = raidCode in RAIDS ? RAIDS[raidCode as keyof typeof RAIDS] : raidCode;

        // Si es un patrón con dificultad (ej: 'icc10n' o 'icc 10n')
        if (match[2] && match[3]) {
          const difficultyNumber = match[2];
          const difficultyLetter = match[3].toUpperCase();
          const difficultyCode = `${difficultyNumber}${difficultyLetter}` as DifficultyCode;

          if (['10N', '10H', '25N', '25H'].includes(difficultyCode)) {
            const raidKey = `${raidCode}${difficultyCode}`;
            if (!usedRaids.has(raidKey)) {
              result.raids.push({
                code: raidCode,
                difficultyCode,
                difficulty: difficultyLetter === 'N' ? 'Normal' : 'Heroic',
                name: raidName,
              });
              usedRaids.add(raidKey);
            }
          }
        } else if (!usedRaids.has(raidCode)) {
          // Si es solo el código de raid sin dificultad
          result.raids.push({
            code: raidCode,
            difficultyCode: undefined,
            difficulty: undefined,
            name: raidName,
          });
          usedRaids.add(raidCode);
        }

        if (match.index === pattern.lastIndex) {
          pattern.lastIndex++; // Evitar bucle infinito
        }
      }
    }
  }

  // Verificar si faltan raids o su dificultad (solo como advertencia, no invalida)
  if (result.raids.length === 0) {
    // Verificar si hay algún código de raid sin dificultad
    const raidPatterns = [
      // Patrones para detectar menciones de raid con o sin dificultad
      new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodesPattern})(?![a-z0-9])(?:$|\\s|\\)|\\]|\/)`, 'i'),
      new RegExp(`(${raidCodesPattern})\\s*\\d+[NH]`, 'i'),
      new RegExp(`(${raidCodesPattern})\\d+[NH]`, 'i'),
      new RegExp(`(10|25)[NH](${raidCodesPattern})`, 'i'), // Para formato 10Nicc, 25Hvoa
    ];

    const hasAnyRaidMention = raidPatterns.some((pattern) => pattern.test(trimmedNote));
    const hasRaidWithDifficulty = new RegExp(
      `(?:${raidCodesPattern})(?:\\s*\\d+[NH]|\\d+[NH]|(?:10|25)[NH](?=${raidCodesPattern}))`,
      'i'
    ).test(trimmedNote);

    if (hasAnyRaidMention && !hasRaidWithDifficulty) {
      // Solo agregar el mensaje de dificultad faltante si no está ya en el array
      if (!missingFields.some((mf) => mf.includes('Dificultad'))) {
        missingFields.push('Dificultad (ej: 10N, 25H)');
      }
    } else if (!hasAnyRaidMention) {
      // Verificar si hay menciones de raid en el texto sin formato específico
      const raidMentionPattern = new RegExp(
        `(?:^|\\s|\\(|\\[)(${allRaidCodes.join('|')})(?=$|[^a-zA-Z0-9])`,
        'i'
      );
      if (!raidMentionPattern.test(trimmedNote)) {
        missingFields.push('Raids que busca/arma (ej: ICC, TOC)');
      }
    }
  } else if (result.raids.some((raid) => !raid.difficultyCode)) {
    // Verificar si hay alguna mención de dificultad en la nota
    const hasDifficultyMention = /(?:^|\s)(\d+[NH])(?:\s|$)/i.test(trimmedNote);
    if (!hasDifficultyMention && !missingFields.some((mf) => mf.includes('Dificultad'))) {
      missingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 6. Verificar campos faltantes en el orden especificado
  const orderedMissingFields: string[] = [];

  // 1. Main/Alt
  if (!result.mainAlt) {
    orderedMissingFields.push('Main/Alt (M/A)');
  }

  // 2. Rol principal
  if (!result.role) {
    orderedMissingFields.push('Rol (T/H/D)');
  }

  // 3. Dual - Solo mostrar si no se ha detectado un rol dual
  if (!result.dualRole) {
    orderedMissingFields.push('Dual (T/H/D)');
  }

  // 4. Gear Score
  if (!result.gearScore) {
    orderedMissingFields.push('Gear Score (ej: 6.2)');
  }

  // 5. Profesiones
  if (!result.professions || result.professions.length === 0) {
    orderedMissingFields.push('Profesiones (ej: JC/BS)');
  }

  // 6. Horario de juego
  if (!result.schedules || result.schedules.length === 0) {
    orderedMissingFields.push('Horario de juego (ej: 18X, 21:30X)');
  }

  // 7. Verificar raids en la nota
  const raidCodes = Object.keys(RAID_NAMES)
    .map((raid) => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join('|');

  // Buscar cualquier mención de raid, con o sin dificultad
  const raidSearchPattern = new RegExp(
    `(?:^|\\s|\\(|\\[)(${raidCodes})(?![a-z0-9])(?:$|\\s|\\)|\\]|\\/|\\d|\\s*\\d*[NH])`,
    'i'
  );
  const hasAnyRaid = raidSearchPattern.test(trimmedNote);

  // Buscar específicamente patrones como 'icc10n' o 'voa25h'
  const raidWithNumberPattern = new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodes})\\s*\\d+[NH]`, 'i');
  const hasAnyRaidWithNumber = raidWithNumberPattern.test(trimmedNote);

  if (!hasAnyRaid && !hasAnyRaidWithNumber) {
    orderedMissingFields.push('Raids que busca (ej: ICC 25H)');
  } else if (!result.raids || result.raids.length === 0) {
    // Si no se detectaron raids pero hay menciones de raids con números, asumir que el formato es correcto
    if (!hasAnyRaidWithNumber) {
      orderedMissingFields.push('Formato de raid (ej: ICC 25H)');
    }
  } else {
    // Verificar dificultad para cada raid
    const raidsWithoutDifficulty = result.raids.filter((raid) => !raid.difficultyCode);
    if (raidsWithoutDifficulty.length > 0 && !hasAnyRaidWithNumber) {
      orderedMissingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 8. Raid Leader (opcional, solo si se especifica RL pero no está marcado)
  const hasRLNotation = /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl|\d*[xX]\s*rl)\b/i.test(
    trimmedNote
  );
  if (hasRLNotation && !result.isRaidLeader) {
    // Verificar si el formato es válido pero no se pudo marcar
    orderedMissingFields.push(
      'RaidLeader (RL) - Verificar formato (ej: RL, rl, RaidLeader, 18xrl)'
    );
  }

  // 2. Rol principal
  if (!result.role) {
    orderedMissingFields.push('Rol (T/H/D)');
  }

  // 3. Dual - Solo mostrar si no se ha detectado un rol dual
  if (!result.dualRole) {
    orderedMissingFields.push('Dual (T/H/D)');
  }

  // 4. Gear Score
  if (!result.gearScore) {
    orderedMissingFields.push('Gear Score (ej: 6.2)');
  }

  // 5. Profesiones
  if (!result.professions || result.professions.length === 0) {
    orderedMissingFields.push('Profesiones (ej: JC/BS)');
  }

  // 6. Horario de juego
  if (!result.schedules || result.schedules.length === 0) {
    orderedMissingFields.push('Horario de juego (ej: 18X, 21:30X)');
  }

  // 8. Raid Leader (opcional, solo si se especifica RL pero no está marcado)
  const hasRLNotationFlag =
    /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl|\d*[xX]\s*rl)\b/i.test(trimmedNote);
  if (hasRLNotationFlag && !result.isRaidLeader) {
    // Verificar si el formato es válido pero no se pudo marcar
    orderedMissingFields.push(
      'RaidLeader (RL) - Verificar formato (ej: RL, rl, RaidLeader, 18xrl)'
    );
  }

  // Agregar cualquier otro campo faltante que no esté en la lista ordenada
  const otherMissingFields = missingFields.filter(
    (field: string) =>
      !orderedMissingFields.some((omf: string) => field.includes(omf.split(' ')[0]))
  );

  // Combinar los campos ordenados con los demás campos faltantes
  const allMissingFields = [...orderedMissingFields, ...otherMissingFields];
  const missingFieldsSet = new Set(allMissingFields);

  // Actualizar el array de missingFields
  result.missingFields = Array.from(missingFieldsSet);

  // Determinar si la nota es válida
  // Verificar si es un formato simple (MT, MTH, MD, etc.)
  const isSimpleFormat =
    /^[MA]?[THD]+$/i.test(trimmedNote) ||
    /^[MA]$/i.test(trimmedNote) ||
    /^[MA][THD]$/i.test(trimmedNote) ||
    /^[THD][MA]$/i.test(trimmedNote) ||
    /^[THD]$/i.test(trimmedNote) ||
    /^[MA]\d+\.?\d*[THD]?$/i.test(trimmedNote) ||
    /^[MA]\d+\.?\d*[A-Za-z]+$/i.test(trimmedNote);

  // Debug: Log simple format detection
  console.group('Simple format detection');
  console.log('Note:', trimmedNote);
  console.log('Is simple format:', isSimpleFormat);
  if (isSimpleFormat) {
    console.log('Matched as simple format');
  } else {
    console.log('Did not match any simple format pattern');
  }
  console.groupEnd();
  // 4. Tiene profesiones
  // 5. Tiene raids
  // 6. Tiene un gear score
  // 7. Es solo 'A' o 'M' (main/alt sin rol)
  const hasAnyValidField =
    isSimpleFormat ||
    result.role !== undefined ||
    result.mainAlt !== undefined ||
    (result.professions && result.professions.length > 0) ||
    (result.raids && result.raids.length > 0) ||
    (result.schedules && result.schedules.length > 0) ||
    (result.gearScore !== undefined && result.gearScore !== null) ||
    /^[MA]$/i.test(trimmedNote);

  // Debug: Log validation criteria
  console.group('Validation criteria');
  console.log('isSimpleFormat:', isSimpleFormat);
  console.log('result.role:', result.role);
  console.log('result.mainAlt:', result.mainAlt);
  console.log('result.professions:', result.professions);
  console.log('result.raids:', result.raids);
  console.log('result.schedules:', result.schedules);
  console.log('result.gearScore:', result.gearScore);
  console.log("Matches 'A' or 'M':", /^[MA]$/i.test(trimmedNote));
  console.log('hasAnyValidField:', hasAnyValidField);
  console.groupEnd();

  // Establecer el estado de validación
  result.isValid = hasAnyValidField;

  // Si no es válido, agregar un mensaje de error
  if (!result.isValid) {
    errors.push('Formato inválido - No se detectaron campos válidos');
  } else {
    // Limpiar errores si la nota es válida
    errors.length = 0;
  }

  // Asegurarse de que los campos principales estén definidos para formatos simples
  if (isSimpleFormat) {
    // Extraer main/alt si está presente
    const mainAltMatch = trimmedNote.match(/^([MA])/i);
    if (mainAltMatch && !result.mainAlt) {
      result.mainAlt = mainAltMatch[1].toUpperCase() as MainAlt;
    }

    // Extraer rol si está presente
    const roleMatch = trimmedNote.match(/[THD]$/i) || trimmedNote.match(/^[THD]/i);
    if (roleMatch && !result.role) {
      result.role = roleMatch[0].toUpperCase() as Role;
    }

    // Extraer gear score si está presente (formato como AT5.9, ad5.5, etc.)
    const gsMatch = trimmedNote.match(/[MA](\d+(?:\.\d+)?)/i);
    if (gsMatch && !result.gearScore) {
      result.gearScore = parseFloat(gsMatch[1]);
    }

    // Extraer profesiones si están presentes (letras mayúsculas después del gear score)
    const profMatch = trimmedNote.match(/[MA]\d*(?:\.\d+)?([A-Z]{2,})/i);
    if (profMatch && (!result.professions || result.professions.length === 0)) {
      const profs = profMatch[1].match(/[A-Z]{2}/g) || [];
      result.professions = profs.map((p) => p.toUpperCase() as ProfessionCode);
    }
  }

  // Si hay errores, agregarlos al resultado
  if (errors.length > 0) {
    result.error = errors.join('; ');
  }

  // Si faltan campos, agregarlos al resultado
  if (missingFields.length > 0) {
    result.missingFields = [...new Set(missingFields)]; // Eliminar duplicados
  }

  // Procesar bloques de personaje
  if (result.mainAlt || result.role || result.gearScore) {
    result.blocks = result.blocks || [];

    // Asegurarnos de que los valores requeridos no sean undefined
    const mainAlt = result.mainAlt || 'M'; // Valor por defecto 'M' si no está definido
    const mainRole = result.role || 'D'; // Valor por defecto 'D' si no está definido
    const gearScore = result.gearScore ? Number(result.gearScore) : 0;

    // Crear bloque de personaje con tipos seguros
    const characterData = {
      type: 'character' as const,
      content: '',
      isValid: true,
      parsedData: {
        mainAlt: mainAlt as MainAlt,
        mainRole: mainRole as Role,
        dualRole: result.dualRole as Role | undefined,
        mainGearScore: gearScore,
        professions: (result.professions || []) as ProfessionCode[],
        dualGearScore: undefined,
      },
    };

    result.blocks.push(characterData);
  }

  // Procesar bloques de evento
  if (result.raids && result.raids.length > 0) {
    result.blocks = result.blocks || [];

    result.raids.forEach((raid) => {
      // Crear bloque de evento con valores por defecto
      const eventData = {
        type: 'event' as const,
        content: '',
        isValid: true,
        parsedData: {
          days: [] as string[],
          dayRange: '',
          time: '',
          raid: raid.code as RaidCode,
          difficulty: raid.difficultyCode as DifficultyCode,
          isRaidLeader: false,
          isLookingForGroup: false,
        },
      };

      // Si hay información de horario, intentar extraer días y hora
      if (result.schedules && result.schedules.length > 0) {
        const schedule = result.schedules[0];
        // Verificar si el horario incluye un rango de días (ej: L-V 20:00)
        const dayRangeMatch = String(schedule).match(
          /^([LMXJVS])-([LMXJVS])\s+(\d{1,2}:?\d{0,2})/i
        );
        const singleDayMatch = String(schedule).match(/^([LMXJVS])\s+(\d{1,2}:?\d{0,2})/i);

        if (dayRangeMatch) {
          // Formato: L-V 20:00
          const [, startDay, endDay, timePart] = dayRangeMatch;
          eventData.parsedData.dayRange = `${startDay}-${endDay}`;
          eventData.parsedData.time = timePart.includes(':') ? timePart : `${timePart}:00`;
        } else if (singleDayMatch) {
          // Formato: L 20:00
          const [, day, timePart] = singleDayMatch;
          eventData.parsedData.days = [day];
          eventData.parsedData.time = timePart.includes(':') ? timePart : `${timePart}:00`;
        } else if (schedule) {
          // Formato antiguo o diferente
          eventData.parsedData.time = String(schedule);
        }
      }

      // Verificar si es raid leader (RL al inicio del código de raid)
      if (raid.code && String(raid.code).startsWith('RL')) {
        eventData.parsedData.isRaidLeader = true;
        eventData.parsedData.raid = String(raid.code).substring(2) as RaidCode;
      }

      result.blocks.push(eventData);
    });
  }

  // Asegurar que los campos principales estén definidos
  const finalResult = {
    ...result,
    // Asegurar que mainRole esté definido para compatibilidad
    mainRole: result.role,
    // Asegurar que los campos principales tengan valores por defecto si faltan
    mainAlt: result.mainAlt || 'M',
    role: result.role || 'D',
    // Limpiar campos faltantes si es válido
    missingFields: result.isValid ? [] : result.missingFields,
    // Asegurar que los arrays estén definidos
    professions: result.professions || [],
    schedules: result.schedules || [],
    raids: result.raids || [],
    // Depuración
    _debug: {
      originalNote: note,
      trimmedNote,
      isValid: result.isValid,
    },
  };

  // Debug logging for validation results
  console.group(`Validation for note: "${note}"`);
  console.log('Trimmed note:', trimmedNote);
  console.log('Is simple format:', isSimpleFormat);
  console.log('Has any valid field:', hasAnyValidField);
  console.log('Main/Alt:', result.mainAlt);
  console.log('Role:', result.role);
  console.log('Gear Score:', result.gearScore);
  console.log('Professions:', result.professions);
  console.log('Raids:', result.raids);
  console.log('Schedules:', result.schedules);
  console.log('Is valid:', finalResult.isValid);
  console.log('Errors:', errors);
  console.log('Missing fields:', finalResult.missingFields);
  console.log('Full validation result:', finalResult);
  console.groupEnd();

  return finalResult;
}

// Mapa de colores y nombres de profesión
const PROFESSION_INFO = {
  JC: {
    name: 'Joyería',
    colors: { light: '#fde047', dark: '#d97706' },
  },
  BS: {
    name: 'Herrería',
    colors: { light: '#60a5fa', dark: '#1d4ed8' },
  },
  EN: {
    name: 'Encantamiento',
    colors: { light: '#c084fc', dark: '#7e22ce' },
  },
  EG: {
    name: 'Ingeniería',
    colors: { light: '#2dd4bf', dark: '#0d9488' },
  },
  AL: {
    name: 'Alquimia',
    colors: { light: '#4ade80', dark: '#15803d' },
  },
  TL: {
    name: 'Sastrería',
    colors: { light: '#f472b6', dark: '#db2777' },
  },
  IN: {
    name: 'Inscripción',
    colors: { light: '#818cf8', dark: '#4f46e5' },
  },
  HB: {
    name: 'Herboristería',
    colors: { light: '#84cc16', dark: '#65a30d' },
  },
  LW: {
    name: 'Peletería',
    colors: { light: '#f59e0b', dark: '#d97706' },
  },
  MN: {
    name: 'Minería',
    colors: { light: '#f97316', dark: '#c2410c' },
  },
  SK: {
    name: 'Desuello',
    colors: { light: '#f43f5e', dark: '#be123c' },
  },
} as const;

// Función para obtener el nombre del rol
const getRoleName = (role: string): string => {
  const roleNames: Record<string, string> = {
    T: 'Tanque',
    H: 'Sanador',
    D: 'DPS',
    M: 'Melee',
    R: 'Rango',
  };
  return roleNames[role] || role;
};

// Función para obtener la clase de color según el rol
const getRoleColorClass = (role: string): string => {
  const roleColors: Record<string, string> = {
    T: 'bg-blue-500/20 border-blue-500/50',
    H: 'bg-green-500/20 border-green-500/50',
    D: 'bg-red-500/20 border-red-500/50',
    M: 'bg-purple-500/20 border-purple-500/50',
    R: 'bg-yellow-500/20 border-yellow-500/50',
  };
  return roleColors[role] || 'bg-gray-500/20 border-gray-500/50';
};

// Mapeo de nombres de profesiones para mostrar
const professionNames: Record<ProfessionCode, { name: string; color: string; bgColor: string }> = {
  AL: { name: 'Alquimia', color: 'text-blue-300', bgColor: 'bg-blue-500/20' },
  HB: { name: 'Herboristería', color: 'text-green-300', bgColor: 'bg-green-500/20' },
  TL: { name: 'Sastrería', color: 'text-amber-300', bgColor: 'bg-amber-500/20' },
  EN: { name: 'Encantamiento', color: 'text-purple-300', bgColor: 'bg-purple-500/20' },
  EG: { name: 'Ingeniería', color: 'text-orange-300', bgColor: 'bg-orange-500/20' },
  JC: { name: 'Joyería', color: 'text-yellow-300', bgColor: 'bg-yellow-500/20' },
  BS: { name: 'Herrería', color: 'text-gray-300', bgColor: 'bg-gray-500/20' },
  IN: { name: 'Inscripción', color: 'text-pink-300', bgColor: 'bg-pink-500/20' },
  MN: { name: 'Minería', color: 'text-gray-400', bgColor: 'bg-gray-600/20' },
  SK: { name: 'Desuello', color: 'text-red-200', bgColor: 'bg-red-700/20' },
  LW: { name: 'Peletería', color: 'text-amber-200', bgColor: 'bg-amber-700/20' },
};

// Mapeo de profesiones a nombres completos y colores
const professionInfo: Record<ProfessionCode, { name: string; color: string; bgColor: string }> = {
  JC: { name: 'Joyería', color: 'text-yellow-300', bgColor: 'bg-yellow-500/20' },
  BS: { name: 'Herrería', color: 'text-gray-300', bgColor: 'bg-gray-500/20' },
  EN: { name: 'Encantamiento', color: 'text-purple-300', bgColor: 'bg-purple-500/20' },
  EG: { name: 'Ingeniería', color: 'text-blue-200', bgColor: 'bg-blue-500/20' },
  AL: { name: 'Alquimia', color: 'text-green-200', bgColor: 'bg-green-500/20' },
  TL: { name: 'Trabajo del Cuero', color: 'text-amber-300', bgColor: 'bg-amber-500/20' },
  IN: { name: 'Sastrería', color: 'text-pink-300', bgColor: 'bg-pink-500/20' },
  HB: { name: 'Herboristería', color: 'text-lime-300', bgColor: 'bg-lime-500/20' },
  MN: { name: 'Minería', color: 'text-gray-400', bgColor: 'bg-gray-600/20' },
  SK: { name: 'Desuello', color: 'text-red-200', bgColor: 'bg-red-700/20' },
  LW: { name: 'Peletería', color: 'text-amber-200', bgColor: 'bg-amber-700/20' },
} as const;

// roleStats ya está definido más arriba en el código
// Usar roleDistribution para obtener los conteos de roles duales
// dualRoleStats ya está definido arriba en el código

// Variable para compatibilidad con código existente que espera un array
const sortedDualRoles = [
  {
    combo: 'TH',
    label: 'Tank / Heal',
    count: dualRoleStats.TH,
    color: 'bg-blue-400/20',
    textColor: 'text-blue-400',
  },
  {
    combo: 'TD',
    label: 'Tank / DPS',
    count: dualRoleStats.TD,
    color: 'bg-purple-400/20',
    textColor: 'text-purple-400',
  },
  {
    combo: 'HD',
    label: 'Heal / DPS',
    count: dualRoleStats.HD,
    color: 'bg-green-400/20',
    textColor: 'text-green-400',
  },
].sort((a, b) => b.count - a.count);

// Calcular estadísticas de mains/alts
const mainAltStats = rosterData.members.reduce(
  (acc, member) => {
    const validation = member.noteValidation;
    if (validation?.isValid) {
      // Usar 'A' (Alt) como valor predeterminado si no se especifica mainAlt
      const mainAlt = validation.mainAlt || 'A';
      acc[mainAlt] = (acc[mainAlt] || 0) + 1;
    } else {
      // Si la validación no es válida, contar como Alt
      acc['A'] = (acc['A'] || 0) + 1;
    }
    return acc;
  },
  { M: 0, A: 0 } as Record<MainAlt, number>
);

// Usamos gearScoreStats ya definido anteriormente

// Contar líderes de raid
const raidLeaderCount = rosterData.members.filter(
  (member) => member.noteValidation?.isRaidLeader
).length;

// Obtener lista de rangos únicos
const ranks = [...new Set(rosterData.members.map((member) => member.rank))].sort();

// Obtener lista de clases únicas
const rosterClassInfo = rosterData?.classInfo || {};
const classList = Object.keys(rosterClassInfo) as ClassName[];

// Función para determinar la prioridad del rango
const getRankPriority = (rank: string): number => {
  const rankLower = rank.toLowerCase();
  if (rankLower.includes('guild master')) return 0;
  if (rankLower.includes('alter')) return 1;
  return 2;
};

// Ordenar miembros
const sortedMembers = [...rosterData.members].sort((a, b) => {
  // Primero ordenar por prioridad de rango
  const priorityA = getRankPriority(a.rank);
  const priorityB = getRankPriority(b.rank);

  if (priorityA !== priorityB) {
    return priorityA - priorityB;
  }

  // Si tienen la misma prioridad, ordenar alfabéticamente
  return a.name.localeCompare(b.name);
});

// Datos para el cliente - Usamos los miembros ya ordenados
const rosterClientData: RosterData = {
  ...rosterData,
  members: sortedMembers as RosterMemberType[],
  classes: Object.keys(rosterData.classInfo || {}),
};

// Definir tipos para las distribuciones
interface DistributionItem {
  name: string;
  count: number;
  percentage?: number;
  color?: string;
}

interface RoleDistributionItem extends DistributionItem {
  role: string;
}

type MainAltType = 'M' | 'A';
interface MainAltDistribution {
  M: number;
  A: number;
}

interface ClassDistributionItem extends DistributionItem {
  color: string;
}

interface MainAltDistributionItem extends DistributionItem {
  type: 'M' | 'A';
}

// Función para calcular la distribución por rango
function calculateRankDistribution(
  members: any[] = []
): Array<{ name: string; count: number; percentage: number }> {
  if (!members || !Array.isArray(members)) {
    return [];
  }
  const totalMembers = members.length;
  if (totalMembers === 0) return [];
  const rankCounts = members.reduce((acc: Record<string, number>, member) => {
    acc[member.rank] = (acc[member.rank] || 0) + 1;
    return acc;
  }, {});

  // Definir el orden de los rangos
  const rankOrder = ['Aspirante', 'Iniciado', 'Explorador', 'Alter', 'Guild Master'];

  // Calcular porcentajes y redondear a 1 decimal
  return Object.entries(rankCounts)
    .map(([name, count]) => ({
      name,
      count: count as number,
      percentage:
        totalMembers > 0 ? Math.round(((count as number) / totalMembers) * 100 * 10) / 10 : 0,
      order: rankOrder.indexOf(name), // Añadir orden para el sort
    }))
    .sort((a, b) => {
      // Si un rango no está en la lista, lo colocamos al final
      if (a.order === -1) return 1;
      if (b.order === -1) return -1;
      return a.order - b.order;
    })
    .map(({ name, count, percentage }) => ({
      name,
      count,
      percentage,
    }));
}

// Función para calcular la distribución por clase
function calculateClassDistribution(
  members: any[] = [],
  classInfo: any = {}
): ClassDistributionItem[] {
  if (!Array.isArray(members) || !classInfo) {
    return [];
  }

  const classCounts = members.reduce((acc: Record<string, number>, member) => {
    if (member && member.class) {
      acc[member.class] = (acc[member.class] || 0) + 1;
    }
    return acc;
  }, {});

  return Object.entries(classCounts)
    .filter(([className]) => className && classInfo[className])
    .map(([className, count]) => ({
      name: className,
      count: count as number,
      color: classInfo[className].color || 'FFFFFF',
    }));
}

// Calcular distribuciones
const rankDistribution = calculateRankDistribution(rosterData.members);
const classDistribution = calculateClassDistribution(rosterData.members, rosterData.classInfo);

// Calcular estadísticas del formato de notas
// Usando el stats ya definido anteriormente

// Calcular porcentajes para las distribuciones
const mainAltDistribution: MainAltDistributionItem[] = [
  { type: 'M', name: 'Main', count: mainAltStats.M, percentage: getRolePercentage(mainAltStats.M) },
  { type: 'A', name: 'Alt', count: mainAltStats.A, percentage: getRolePercentage(mainAltStats.A) },
];

// Usar gearScoreStats ya definido al inicio del archivo
const gearScorePercentage =
  gearScoreStats.avg > 0 ? Math.min(100, Math.max(0, (gearScoreStats.avg / 6.8) * 100)) : 0;

// Usar validNotesCount ya calculado anteriormente

// La función getRankPriority y sortedMembers han sido movidas arriba para la inicialización

// Use the sorted members as the base for filtered members
const filteredMembers = [...sortedMembers];
const totalRaiders = rosterData.members.filter(
  (m) =>
    m.rank.toLowerCase().includes('élite') ||
    m.rank.toLowerCase().includes('alter') ||
    m.rank.toLowerCase().includes('comandante') ||
    m.rank.toLowerCase().includes('guild master')
).length;

// rosterClientData is already defined above with the sorted members
---

<div class="space-y-6">
  <style>
    /* Estilos para los tooltips */
    .tooltip-container {
      position: relative;
      display: inline-block;
    }

    .tooltip-container:hover .tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .tooltip {
      transform: translateY(-5px);
      transition: all 0.2s ease-in-out;
      box-shadow:
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Estilos para los dropdowns */
    select option {
      background-color: #1a202c; /* Fondo oscuro */
      color: #e2e8f0; /* Texto claro */
      padding: 0.5rem;
    }

    select:focus option:checked {
      background-color: #4a5568; /* Color de fondo para la opción seleccionada */
      color: white;
    }

    /* Estilo para el hover en las opciones */
    select option:hover {
      background-color: #4a5568 !important;
    }
  </style>
  <!-- Script del cliente con la lógica de JavaScript -->
  <script
    define:vars={{
      rosterData: JSON.stringify(rosterClientData),
      roleNames: JSON.stringify(roleNames),
      professionNames: JSON.stringify(professionNames),
    }}
  >
    // Analizar los datos del roster
    const rosterInfo = JSON.parse(rosterData);
    const roleNamesData = JSON.parse(roleNames);
    const professionNamesData = JSON.parse(professionNames);

    // Función para inicializar tooltips
    function initTooltips() {
      document.querySelectorAll('.tooltip-container').forEach((container) => {
        const tooltip = container.querySelector('.tooltip');
        if (!tooltip) return;

        // Posicionamiento del tooltip
        const updatePosition = () => {
          const rect = container.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();

          // Centrar horizontalmente
          const left = rect.left + rect.width / 2 - tooltipRect.width / 2;

          // Ajustar para que no se salga de la pantalla
          const adjustedLeft = Math.max(
            10,
            Math.min(window.innerWidth - tooltipRect.width - 10, left)
          );

          tooltip.style.left = `${adjustedLeft}px`;
        };

        // Actualizar posición al mostrar
        container.addEventListener('mouseenter', updatePosition);

        // Actualizar posición al redimensionar
        window.addEventListener('resize', updatePosition);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Inicializar tooltips después de cargar la tabla
      initTooltips();
      // Obtener elementos del DOM
      const searchInput = document.getElementById('search');
      const classFilter = document.getElementById('class-filter');
      const rankFilter = document.getElementById('rank-filter');
      const tableBody = document.getElementById('roster-table-body');
      const prevButton = document.getElementById('prev-button');
      const nextButton = document.getElementById('next-button');
      const pageInfo = document.getElementById('page-info');

      let currentPage = 1;
      const itemsPerPage = 2;
      let allMembers = [];
      let filteredMembers = [];
      let sortConfig = { key: 'name', direction: 'asc' };

      // Funciones de utilidad para formatear
      const formatTime = (timeStr) => {
        if (!timeStr) return '';
        // Convertir "20" a "20:00" o mantener "20:00"
        return timeStr.includes(':') ? timeStr : `${timeStr}:00`;
      };

      const formatDays = (days) => {
        if (!days || !days.length) return [];
        if (typeof days === 'string') {
          // Manejar rangos como "L-V"
          if (days.includes('-')) {
            const [start, end] = days.split('-');
            const dayOrder = ['L', 'M', 'X', 'J', 'V', 'S', 'D'];
            const startIdx = dayOrder.indexOf(start);
            const endIdx = dayOrder.indexOf(end);
            if (startIdx !== -1 && endIdx !== -1 && startIdx <= endIdx) {
              return dayOrder.slice(startIdx, endIdx + 1);
            }
          }
          return days.split('');
        }
        return Array.isArray(days) ? days : [];
      };

      const isRaidLeader = (eventBlock) => {
        if (!eventBlock) return false;
        const content = typeof eventBlock === 'string' ? eventBlock : JSON.stringify(eventBlock);
        return /RL/i.test(content);
      };

      const formatRaidInfo = (raid, difficulty) => {
        if (!raid) return '';
        const difficultyText = difficulty ? ` ${difficulty}` : '';
        return `${raid}${difficultyText}`;
      };

      // Inicializar la tabla con los datos
      function initTable() {
        if (!tableBody || !pageInfo) {
          return;
        }

        // Use the pre-sorted members from the server
        allMembers = [...rosterInfo.members];

        // Apply the same sorting logic on the client side
        allMembers.sort((a, b) => {
          const getRankPriority = (rank) => {
            const rankLower = rank?.toLowerCase() || '';
            if (rankLower.includes('guild master')) return 0;
            if (rankLower.includes('alter')) return 1;
            return 2;
          };

          const priorityA = getRankPriority(a.rank);
          const priorityB = getRankPriority(b.rank);

          if (priorityA !== priorityB) {
            return priorityA - priorityB;
          }

          return (a.name || '').localeCompare(b.name || '');
        });

        filteredMembers = [...allMembers];

        // Llenar filtros
        if (classFilter && rankFilter) {
          // No necesitamos llenar los dropdowns aquí ya que se generan en el template
        }

        updateTable();
        updatePaginationInfo();
      }

      // Actualizar la tabla con los miembros filtrados y ordenados
      function updateTable() {
        if (!tableBody) return;

        const startIndex = (currentPage - 1) * itemsPerPage;
        const paginatedMembers = filteredMembers.slice(startIndex, startIndex + itemsPerPage);

        tableBody.innerHTML = paginatedMembers
          .map((member) => {
            const classData = rosterInfo.classInfo[member.class] || {
              color: 'FFFFFF',
              name: member.class,
            };
            const className = classData.name;
            const classColor = classData.color;

            return `
            <tr class="hover:bg-steel-dark transition-colors duration-200 hover:border-accent">
              <td class="px-2 md:px-6 py-4 whitespace-nowrap text-center max-w-[250px]">
                <div class="flex items-center sm:flex-row flex-col">
                  <img src="/images/avatars/class_${className}.jpg" alt="${className}" class="w-8 h-8 rounded-full sm:mr-3 border border-accent/30" onerror="this.src='/images/avatars/default.png'"/>
                  <div class="flex-grow">
                    <div class="text-xs" style="color: #${classColor}">${className}</div>
                    <div class="font-medium text-text-primary">${member.name}</div>
                    <div class="mt-1">
                      <span class="px-2 py-0.5 text-xs font-medium rounded-full ${member.rank === 'Guild Master' ? 'bg-yellow-500/20 text-yellow-300' : member.rank === 'Alter' ? 'bg-purple-500/20 text-purple-300' : 'bg-gray-500/20 text-gray-300'}">
                        ${member.rank}
                      </span>
                    </div>
                    <!-- Nota combinada -->
                    <div class="text-xs mt-1 text-gray-400 hidden">
                      ${member.publicNote || ''}
                      ${member.officerNote ? `<div class="text-amber-500/80">${member.officerNote}</div>` : ''}
                    </div>
                  </div>
                </div>
              </td>
              <td class="px-2 md:px-6 py-4 relative overflow-visible">
                <div class="relative">
                  <div class="flex items-start gap-2">
                    <div class="relative inline-flex items-center w-full">
                      ${
                        member.publicNote
                          ? `
                        <div class="space-y-1 w-full">
                          ${(() => {
                            const validation = member.noteValidation;
                            if (validation?.isValid) {
                              const formattedInfo = [];
                              const missingFields = [];

                              // 1. Procesar bloques de personaje
                              const characterBlocks =
                                validation.blocks?.filter((b) => b.type === 'character') || [];
                              let charData = {};

                              // Usar datos del bloque de personaje si existe, si no, usar los del nivel superior
                              if (characterBlocks.length > 0 && characterBlocks[0]?.parsedData) {
                                charData = characterBlocks[0].parsedData;
                              } else {
                                // Usar datos del nivel superior como respaldo
                                charData = {
                                  mainAlt: validation.mainAlt,
                                  mainRole: validation.role,
                                  mainGearScore: parseFloat(validation.gearScore) || 0,
                                  professions: validation.professions || [],
                                  dualRole: validation.dualRole,
                                };
                              }

                              // Extraer todos los GS de la nota pública
                              const gearScores = (member.publicNote?.match(/(\d+\.?\d*)/g) || [])
                                .map(Number)
                                .filter((gs) => gs > 0);

                              // Main/Alt
                              if (charData.mainAlt) {
                                formattedInfo.push({
                                  label: charData.mainAlt === 'M' ? 'Main' : 'Alt',
                                  class:
                                    charData.mainAlt === 'M'
                                      ? 'text-blue-300 font-medium'
                                      : 'text-purple-300 font-medium',
                                });
                              }

                              // Rol principal con su GS
                              if (charData.mainRole) {
                                const roleName =
                                  roleNamesData[charData.mainRole]?.name || charData.mainRole;
                                const mainGS = gearScores[0] || charData.mainGearScore;

                                // Agregar rol principal
                                formattedInfo.push({
                                  label: roleName,
                                  class:
                                    charData.mainRole === 'T'
                                      ? 'text-blue-300 font-medium'
                                      : charData.mainRole === 'H'
                                        ? 'text-green-300 font-medium'
                                        : 'text-red-300 font-medium',
                                });

                                // Agregar GS del rol principal si existe
                                if (mainGS) {
                                  formattedInfo.push({
                                    label: `GS ${mainGS}`,
                                    class: 'bg-amber-500/20 border-amber-500/50',
                                    inline: true,
                                  });
                                }
                              }

                              // Rol dual (si existe) con su GS
                              const dualRoleToShow =
                                charData.dualRole ||
                                member.publicNote
                                  ?.match(/[dD](\d+\.?\d*)([tThHdD])/i)?.[2]
                                  ?.toUpperCase();

                              if (dualRoleToShow) {
                                const dualRoleName =
                                  roleNamesData[dualRoleToShow]?.name || dualRoleToShow;
                                const dualGS = gearScores[1]; // Segundo GS para el rol dual

                                // Agregar rol dual
                                formattedInfo.push({
                                  label: `Dual ${dualRoleName}`,
                                  class: 'bg-yellow-500/20 border-yellow-500/50',
                                  inline: true,
                                });

                                // Agregar GS del rol dual si existe
                                if (dualGS) {
                                  formattedInfo.push({
                                    label: `GS ${dualGS}`,
                                    class: 'bg-amber-500/20 border-amber-500/50',
                                    inline: true,
                                  });
                                }
                              }

                              // Función para obtener el código de profesión a partir del nombre
                              const getProfessionCode = (profName) => {
                                if (!profName) return null;
                                const normalizedProf = profName.toLowerCase().trim();
                                // Buscar en el objeto professionNamesData el código que coincida con el nombre
                                const entry = Object.entries(professionNamesData).find(
                                  ([_, data]) => data?.name?.toLowerCase() === normalizedProf
                                );
                                return entry ? entry[0] : null;
                              };

                              const professionsToShow = (
                                charData.professions?.length
                                  ? charData.professions
                                  : validation.professions || []
                              ).filter((prof) => prof && !/^\d+\.?\d*$/.test(prof)); // Filtrar posibles GS mal interpretados

                              if (professionsToShow.length) {
                                // Procesar cada profesión
                                const processedProfs = new Set(); // Para evitar duplicados

                                professionsToShow.forEach((prof) => {
                                  try {
                                    // Primero intentamos obtener el código de profesión
                                    let profCode = getProfessionCode(prof) || prof.toUpperCase();
                                    const profName = professionNamesData[profCode]?.name || prof;

                                    // Evitar duplicados
                                    if (processedProfs.has(profCode)) return;
                                    processedProfs.add(profCode);

                                    if (profName) {
                                      // Usar los estilos definidos o los predeterminados
                                      const profStyle = professionNamesData[profCode] || {
                                        name: profName,
                                        color: 'text-indigo-300',
                                        bgColor: 'bg-indigo-500/20',
                                        borderColor: 'border-indigo-500/50',
                                      };

                                      formattedInfo.push({
                                        label: profName,
                                        class: `${profStyle.bgColor || 'bg-indigo-500/20'} ${profStyle.borderColor || 'border-indigo-500/50'}`,
                                        inline: true,
                                      });
                                    }
                                  } catch (error) {
                                    console.error(
                                      `[${member.name}] Error procesando profesión ${prof}:`,
                                      error
                                    );
                                  }
                                });
                              }

                              // 2. Procesar bloques de evento
                              const eventBlocks =
                                validation.blocks?.filter((b) => b.type === 'event') || [];

                              // Si no hay bloques de evento pero hay datos en el nivel superior, crear uno
                              if (
                                eventBlocks.length === 0 &&
                                (validation.days?.length ||
                                  validation.raids?.length ||
                                  validation.schedules?.length)
                              ) {
                                const eventData = {
                                  days: validation.days,
                                  time:
                                    validation.schedules?.[0]?.match(/\d{1,2}:?\d{0,2}/)?.[0] || '',
                                  raid: validation.raids?.[0]?.name || '',
                                  difficulty: validation.raids?.[0]?.difficultyCode || '',
                                  isRaidLeader: validation.isRaidLeader,
                                  isLookingForGroup: false,
                                };
                                eventBlocks.push({
                                  type: 'event',
                                  isValid: true,
                                  parsedData: eventData,
                                });
                              }

                              // Si aún no hay bloques de evento, verificar si hay datos en el nivel superior
                              if (eventBlocks.length === 0) {
                                // Intentar extraer información de la nota pública
                                const publicNote = member.publicNote || '';
                                const raidMatch = publicNote.match(
                                  /([A-Za-z]+)(?:\s+([0-9]+[NH]))?/
                                );
                                const timeMatch = publicNote.match(/(\d{1,2}:?\d{0,2})/);

                                if (raidMatch || timeMatch) {
                                  const eventData = {
                                    days: validation.days || [],
                                    time: timeMatch ? timeMatch[1] : '',
                                    raid: raidMatch ? raidMatch[1] : '',
                                    difficulty: raidMatch ? raidMatch[2] || '' : '',
                                    isRaidLeader: /RL/i.test(publicNote),
                                    isLookingForGroup: /LFG/i.test(publicNote),
                                  };

                                  eventBlocks.push({
                                    type: 'event',
                                    isValid: true,
                                    parsedData: eventData,
                                  });
                                }
                              }

                              if (eventBlocks.length > 0) {
                                eventBlocks.forEach((eventBlock) => {
                                  if (eventBlock.parsedData) {
                                    const eventData = eventBlock.parsedData;
                                    const formattedEventInfo = [];

                                    // Días - Convertir códigos de días a nombres completos
                                    const daysToShow = eventData.days?.length
                                      ? eventData.days
                                      : validation.days;
                                    const dayNames = {
                                      L: 'Lunes',
                                      M: 'Martes',
                                      X: 'Miércoles',
                                      J: 'Jueves',
                                      V: 'Viernes',
                                      S: 'Sábado',
                                      D: 'Domingo',
                                    };

                                    if (daysToShow?.length) {
                                      // Usar la función formatDays para manejar rangos
                                      const days = formatDays(daysToShow)
                                        .map((day) => dayNames[day] || day)
                                        .filter(Boolean);

                                      // Formatear días como "Lun, Mar, Mié..."
                                      const shortDayNames = {
                                        Lunes: 'Lun',
                                        Martes: 'Mar',
                                        Miércoles: 'Mié',
                                        Jueves: 'Jue',
                                        Viernes: 'Vie',
                                        Sábado: 'Sáb',
                                        Domingo: 'Dom',
                                      };

                                      const shortDays = days.map(
                                        (day) => shortDayNames[day] || day
                                      );

                                      // Agregar cada día como una etiqueta separada
                                      shortDays.forEach((day) => {
                                        if (day) {
                                          formattedInfo.push({
                                            label: day,
                                            class: 'bg-blue-500/20 border-blue-500/50',
                                            inline: true,
                                          });
                                        }
                                      });
                                    }

                                    // Hora
                                    if (eventData.time) {
                                      let timeToShow = eventData.time;
                                      // Limpiar formato de hora (eliminar 'x' al final si existe)
                                      timeToShow = timeToShow.replace(/x$/i, '');
                                      // Asegurar formato HH:MM
                                      if (!timeToShow.includes(':')) {
                                        timeToShow =
                                          timeToShow.length <= 2
                                            ? `${timeToShow}:00`
                                            : `${timeToShow.slice(0, 2)}:${timeToShow.slice(2)}`;
                                      }

                                      formattedInfo.push({
                                        label: timeToShow,
                                        class: 'bg-green-500/20 border-green-500/50',
                                        inline: true,
                                      });
                                    }

                                    // Raid y dificultad - Eliminado para evitar duplicados
                                    // Este bloque se maneja más abajo

                                    // Verificar si es raid leader (compatibilidad con string 'YES' o booleano true)
                                    // o si la validación general indica que es raid leader
                                    const isLeader =
                                      eventData.isRaidLeader === true ||
                                      eventData.isRaidLeader === 'YES' ||
                                      (typeof eventData.isRaidLeader === 'string' &&
                                        eventData.isRaidLeader.toUpperCase() === 'YES') ||
                                      validation.isRaidLeader === true;

                                    // Solo mostrar información de raid si no se ha mostrado ya
                                    if (eventData.raid) {
                                      const difficultyNames = {
                                        '10N': '10 Normal',
                                        '10H': '10 Heroico',
                                        '25N': '25 Normal',
                                        '25H': '25 Heroico',
                                        N: 'Normal',
                                        H: 'Heroico',
                                      };

                                      // Formatear dificultad
                                      const difficultyText = eventData.difficulty
                                        ? difficultyNames[eventData.difficulty] ||
                                          eventData.difficulty
                                        : '';

                                      // Usar formatRaidInfo para mostrar raid y dificultad juntas
                                      const raidInfo = formatRaidInfo(
                                        eventData.raid,
                                        difficultyText
                                      );

                                      // Agregar etiqueta de Raid Leader si corresponde
                                      if (isLeader) {
                                        formattedInfo.unshift({
                                          label: 'Raid Leader',
                                          class:
                                            'text-yellow-300 font-bold border-b border-yellow-500/60 pb-0.5',
                                        });

                                        // Mostrar "Armo" en lugar de "Busco" para raid leaders
                                        formattedInfo.push({
                                          label: `Armo: ${raidInfo}`,
                                          class: 'text-purple-300 font-medium',
                                        });
                                      } else {
                                        // Si no es raid leader, mostrar "Busco"
                                        formattedInfo.push({
                                          label: `Busco: ${raidInfo}`,
                                          class: 'text-purple-300 font-medium',
                                        });
                                      }
                                    }

                                    // Looking for Group
                                    if (eventData.isLookingForGroup) {
                                      formattedInfo.push({
                                        label: 'LFG',
                                        class: 'text-green-400 font-bold',
                                      });
                                    }
                                  }
                                });
                              } else if (validation.raids?.length) {
                                // Si no hay bloques de evento pero hay raids en la validación
                                validation.raids.forEach((raid) => {
                                  // Mostrar días si están disponibles
                                  if (raid.days) {
                                    const dayNames = raid.days
                                      .split('')
                                      .map((day) => DAY_NAMES[day] || day)
                                      .join(', ');

                                    formattedInfo.push({
                                      label: dayNames,
                                      class: 'text-blue-300 font-medium',
                                    });
                                  }

                                  // Mostrar hora si está disponible
                                  if (raid.time) {
                                    formattedInfo.push({
                                      label: raid.time,
                                      class: 'text-blue-300 font-medium',
                                    });
                                  }

                                  // Mostrar información de la raid
                                  if (raid.name) {
                                    const isLeader = raid.isRaidLeader || validation.isRaidLeader;
                                    const raidAction = isLeader ? 'Armo' : 'Busco';

                                    // Solo mostrar el estado de RL si es líder
                                    if (isLeader) {
                                      formattedInfo.unshift({
                                        label: 'Raid Leader',
                                        class:
                                          'text-yellow-300 font-bold border-b border-yellow-500/60 pb-0.5',
                                      });
                                    }

                                    // Mostrar acción (Armo/Busco) y nombre de la raid
                                    formattedInfo.push({
                                      label: `${raidAction}: ${raid.name}`,
                                      class: isLeader
                                        ? 'text-purple-300 font-medium border-b border-purple-500/60 pb-0.5'
                                        : 'text-purple-300 font-medium',
                                    });
                                  }

                                  // Mostrar dificultad
                                  if (raid.difficulty) {
                                    formattedInfo.push({
                                      label: raid.difficulty,
                                      class: 'text-orange-300 font-medium',
                                    });
                                  } else if (raid.difficultyCode) {
                                    formattedInfo.push({
                                      label: raid.difficultyCode,
                                      class: 'text-orange-300 font-medium',
                                    });
                                  }
                                });
                              } else {
                                missingFields.push('Datos de evento');
                              }

                              // 3. Verificar campos faltantes
                              const hasCharacterData =
                                characterBlocks.length > 0 ||
                                validation.mainAlt ||
                                validation.mainRole ||
                                validation.role ||
                                validation.gearScore;

                              // Solo marcar como faltante si no hay ningún dato de personaje
                              if (!hasCharacterData) {
                                missingFields.push('Datos de personaje');
                              } else {
                                // Verificar campos específicos faltantes
                                if (
                                  !validation.mainAlt &&
                                  !characterBlocks.some((b) => b.parsedData?.mainAlt)
                                ) {
                                  missingFields.push('Main/Alt');
                                }
                                if (
                                  !validation.mainRole &&
                                  !validation.role &&
                                  !characterBlocks.some(
                                    (b) => b.parsedData?.mainRole || b.parsedData?.role
                                  )
                                ) {
                                  missingFields.push('Rol principal');
                                }
                              }
                              if (
                                eventBlocks.length === 0 &&
                                !validation.raids?.length &&
                                !validation.schedules?.length
                              ) {
                              }

                              // Función para procesar los bloques de la nota
                              const processNoteBlocks = (validation) => {
                                const characterTags = [];
                                const eventTags = [];
                                const missingCharacterFields = [];
                                const missingEventFields = [];

                                // Obtener bloques de personaje y evento
                                const characterBlocks =
                                  validation.blocks?.filter((b) => b.type === 'character') || [];
                                const eventBlocks =
                                  validation.blocks?.filter((b) => b.type === 'event') || [];
                                // Procesar bloques de personaje
                                if (characterBlocks.length > 0) {
                                  const charData = characterBlocks[0]?.parsedData || {};

                                  // Agregar etiquetas en el orden deseado
                                  if (charData.mainAlt) {
                                    characterTags.push({
                                      label: charData.mainAlt === 'M' ? 'Main' : 'Alt',
                                      class: 'bg-blue-500/20 border-blue-500/50',
                                    });
                                  }

                                  // Agregar rol principal (usar role como respaldo si mainRole no está definido)
                                  const roleToUse = charData.mainRole || charData.role;
                                  if (roleToUse) {
                                    characterTags.push({
                                      label: roleNamesData[roleToUse]?.name || roleToUse,
                                      class: 'bg-green-500/20 border-green-500/50',
                                      title: `Rol: ${roleNamesData[roleToUse]?.name || roleToUse}`,
                                    });

                                    // Agregar GS del rol principal
                                    const gsToUse = charData.mainGearScore || charData.gearScore;
                                    if (gsToUse) {
                                      characterTags.push({
                                        label: `GS ${gsToUse}`,
                                        class: 'bg-amber-500/20 border-amber-500/50',
                                        title: `Gear Score: ${gsToUse}`,
                                      });
                                    }

                                    // Si hay un rol dual, mostrarlo también
                                    if (charData.dualRole) {
                                      characterTags.push({
                                        label:
                                          roleNamesData[charData.dualRole]?.name ||
                                          charData.dualRole,
                                        class: 'bg-purple-500/20 border-purple-500/50',
                                        title: `Rol secundario: ${roleNamesData[charData.dualRole]?.name || charData.dualRole}`,
                                      });
                                    }
                                  }

                                  // Agregar rol dual si existe
                                  if (charData.dualRole) {
                                    characterTags.push({
                                      label: `Dual ${roleNamesData[charData.dualRole]?.name || charData.dualRole}`,
                                      class: 'bg-yellow-500/20 border-yellow-500/50',
                                    });

                                    // Agregar GS del rol dual si existe
                                    if (charData.dualGearScore) {
                                      characterTags.push({
                                        label: `GS ${charData.dualGearScore}`,
                                        class: 'bg-amber-500/20 border-amber-500/50',
                                      });
                                    }
                                  }

                                  // Agregar etiquetas de profesiones
                                  if (charData.professions && charData.professions.length > 0) {
                                    charData.professions.forEach((profCode) => {
                                      const profInfo = professionNamesData[profCode];
                                      if (profInfo) {
                                        const tag = {
                                          label: profInfo.name,
                                          class: `${profInfo.bgColor || 'bg-indigo-500/20'} border-${profInfo.color.replace('text-', '')}`,
                                        };
                                        characterTags.push(tag);
                                      }
                                    });
                                  }

                                  // Verificar campos faltantes en personaje
                                  if (!charData.mainAlt) missingCharacterFields.push('Main/Alt');
                                  if (!charData.mainRole)
                                    missingCharacterFields.push('Rol principal');
                                  if (!charData.mainGearScore)
                                    missingCharacterFields.push('Gear Score');
                                }

                                // Procesar bloques de evento
                                if (eventBlocks.length > 0) {
                                  // Crear un array para almacenar los eventos procesados
                                  const processedEvents = [];

                                  eventBlocks.forEach((eventBlock, index) => {
                                    if (eventBlock.parsedData) {
                                      const eventData = eventBlock.parsedData;
                                      const eventTags = [];
                                      const eventMissingFields = [];

                                      // Procesar días
                                      if (eventData.days) {
                                        // Si days es un array, convertirlo a string primero
                                        const daysStr = Array.isArray(eventData.days)
                                          ? eventData.days.join('')
                                          : String(eventData.days);

                                        // Mapear códigos de días a nombres cortos
                                        const dayMap = {
                                          L: 'Lun',
                                          M: 'Mar',
                                          X: 'Mié',
                                          J: 'Jue',
                                          V: 'Vie',
                                          S: 'Sáb',
                                          D: 'Dom',
                                        };

                                        // Solo agregar días si hay algo que mostrar
                                        if (daysStr.trim()) {
                                          // Manejar rangos como "L-V"
                                          if (daysStr.includes('-')) {
                                            const [startDay, endDay] = daysStr.split('-');
                                            const dayOrder = ['L', 'M', 'X', 'J', 'V', 'S', 'D'];
                                            const startIndex = dayOrder.indexOf(startDay);
                                            const endIndex = dayOrder.indexOf(endDay);

                                            if (
                                              startIndex !== -1 &&
                                              endIndex !== -1 &&
                                              startIndex <= endIndex
                                            ) {
                                              // Crear rango de días
                                              const rangeDays = [];
                                              for (let i = startIndex; i <= endIndex; i++) {
                                                rangeDays.push(dayOrder[i]);
                                              }
                                              const formattedDays = rangeDays
                                                .map((day) => dayMap[day] || day)
                                                .join(', ');
                                              if (formattedDays) {
                                                eventTags.push({
                                                  label: formattedDays,
                                                  class: 'bg-blue-500/20 border-blue-500/50',
                                                });
                                              }
                                            } else if (daysStr.trim()) {
                                              // Si no se puede formar un rango válido, mostrar el texto original solo si no está vacío
                                              eventTags.push({
                                                label: daysStr.trim(),
                                                class: 'bg-blue-500/20 border-blue-500/50',
                                              });
                                            }
                                          } else {
                                            // Si no es un rango, mostrar los días individuales
                                            const formattedDays = daysStr
                                              .split('')
                                              .map((day) => dayMap[day] || day)
                                              .filter((day) => day) // Filtrar días vacíos
                                              .join(', ');

                                            if (formattedDays) {
                                              eventTags.push({
                                                label: formattedDays,
                                                class: 'bg-blue-500/20 border-blue-500/50',
                                              });
                                            }
                                          }
                                        }
                                      }

                                      // Procesar hora
                                      if (eventData.time) {
                                        eventTags.push({
                                          label: `Hora: ${eventData.time}`,
                                          class: 'bg-green-500/20 border-green-500/50',
                                        });
                                      }

                                      // Procesar raid leader (Armo) o mostrar 'Busco' - se muestra antes de la raid
                                      if (eventData.isRaidLeader) {
                                        eventTags.push({
                                          label: 'Armo',
                                          class: 'bg-yellow-500/20 border-yellow-500/50',
                                        });
                                      } else if (eventData.raid) {
                                        // Si hay raid pero no hay RL, mostrar 'Busco'
                                        eventTags.push({
                                          label: 'Busco',
                                          class: 'bg-red-500/20 border-red-500/50',
                                        });
                                      }

                                      // Procesar raid y dificultad
                                      if (eventData.raid) {
                                        const difficulty = eventData.difficulty
                                          ? ` ${eventData.difficulty}`
                                          : '';
                                        eventTags.push({
                                          label: `${eventData.raid}${difficulty}`,
                                          class: 'bg-purple-500/20 border-purple-500/50',
                                        });
                                      }

                                      // Verificar campos faltantes en evento
                                      const hasDays = eventData.days?.length > 0;
                                      const hasTime = !!eventData.time;
                                      const hasRaid = !!eventData.raid;

                                      if (!hasDays) eventMissingFields.push('Día/s');
                                      if (!hasTime) eventMissingFields.push('Hora');
                                      if (!hasRaid) eventMissingFields.push('Raid');

                                      // Agregar el evento procesado al array
                                      processedEvents.push({
                                        id: `event-${index}`,
                                        tags: [...eventTags],
                                        missingFields: [...eventMissingFields],
                                      });
                                    }
                                  });

                                  // Retornar los eventos procesados
                                  return {
                                    characterTags,
                                    processedEvents,
                                    missingCharacterFields,
                                    missingEventFields,
                                  };
                                }

                                return {
                                  characterTags,
                                  eventTags,
                                  missingCharacterFields,
                                  missingEventFields,
                                };
                              };

                              // Procesar los bloques de la nota
                              const processedBlocks = processNoteBlocks(validation);
                              const characterTags = processedBlocks.characterTags || [];
                              const processedEvents = processedBlocks.processedEvents || [];
                              const missingCharacterFields =
                                processedBlocks.missingCharacterFields || [];
                              const missingEventFields = processedBlocks.missingEventFields || [];

                              return `
                                <div class="space-y-3">
                                  <!-- Bloque de Personaje -->
                                  <div class="space-y-1">
                                    <div class="flex flex-wrap gap-1.5 mb-1">
                                      ${characterTags
                                        .map((item) => {
                                          // Verificar si es una profesión para aplicar estilos
                                          const professionEntry = Object.entries(
                                            professionNamesData
                                          ).find(([_, prof]) => prof?.name === item.label);

                                          if (professionEntry) {
                                            const [_, profData] = professionEntry;
                                            return `<span class="text-xs px-2 py-0.5 rounded border ${profData.bgColor || 'bg-indigo-500/20'} border-${profData.color.replace('text-', '')}">${item.label}</span>`;
                                          }

                                          return `<span class="text-xs px-2 py-0.5 rounded border ${item.class || ''}">${item.label}</span>`;
                                        })
                                        .join('')}
                                    </div>
                                    ${
                                      missingCharacterFields.length > 0
                                        ? `
                                      <div class="text-amber-400/90 text-xs">
                                        <span class="font-medium">Faltan:</span> ${missingCharacterFields.join(', ')}
                                      </div>
                                    `
                                        : ''
                                    }
                                  </div>
                                  
                                  <!-- Bloque de Eventos -->
                                  <div class="space-y-2">
                                    <div class="text-xs font-medium text-gray-400 mb-1">EVENTOS</div>
                                    ${
                                      processedEvents.length > 0
                                        ? processedEvents
                                            .map(
                                              (event) => `
                                        <div class="space-y-1.5 bg-gray-800/30 rounded-lg p-2 border border-gray-700/50">
                                          <div class="flex flex-wrap gap-1.5">
                                            ${event.tags
                                              .map(
                                                (tag) =>
                                                  `<span class="text-xs px-2 py-0.5 rounded border ${tag.class}">${tag.label}</span>`
                                              )
                                              .join('')}
                                          </div>
                                          ${
                                            event.missingFields.length > 0
                                              ? `
                                            <div class="text-amber-400/90 text-xs mt-1">
                                              <span class="font-medium">Faltan:</span> ${event.missingFields.join(', ')}
                                            </div>
                                          `
                                              : ''
                                          }
                                        </div>
                                      `
                                            )
                                            .join('')
                                        : '<div class="text-text-muted/70 text-xs italic">No hay eventos programados</div>'
                                    }
                                  </div>
                                </div>`;
                            } else {
                              const missingFields = validation.missingFields || [];
                              const errorMessage =
                                missingFields.length > 0
                                  ? `Faltan: ${missingFields.join(', ')}`
                                  : 'Formato inválido';

                              return `
                                <div class="space-y-1.5">
                                  <!-- Mensaje de error (alta prioridad) -->
                                  <div class="flex flex-wrap gap-1">
                                    <span class="text-sm font-medium text-red-300">
                                      Formato inválido
                                    </span>
                                  </div>
                                  
                                  <!-- Advertencias (baja prioridad) -->
                                  ${
                                    missingFields.length > 0
                                      ? `
                                    <div class="flex items-start gap-1 text-yellow-500/70 text-[11px] mt-0.5">
                                      <svg class="w-2.5 h-2.5 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                                      </svg>
                                      <span>Faltan: ${missingFields.join(', ')}</span>
                                    </div>
                                  `
                                      : ''
                                  }
                              `;
                            }
                          })()}
                        </div> 
                      `
                          : `
                        <div class="flex items-center gap-2">
                          <span class="text-text-muted/70 italic">Sin nota</span>
                          <div class="flex items-center justify-center w-5 h-5 rounded-full bg-gray-900/20 border border-gray-500/30">
                            <div class="w-2 h-2 rounded-full bg-gray-500"></div>
                          </div>
                        </div>
                      `
                      }
                    </div>
                    
                  </div>
                </div>
              </td>
            </tr>
          `;
          })
          .join('');

        updatePaginationInfo();
        updateSortIndicators();
      }

      // Función para ordenar los miembros
      function sortMembers(key) {
        if (sortConfig.key === key) {
          sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
        } else {
          sortConfig.key = key;
          sortConfig.direction = 'asc';
        }

        filteredMembers.sort((a, b) => {
          let aValue = a[key] || '';
          let bValue = b[key] || '';

          // Manejar valores nulos o indefinidos
          if (aValue === null || aValue === undefined) aValue = '';
          if (bValue === null || bValue === undefined) bValue = '';

          // Convertir a string para comparación segura
          aValue = String(aValue).toLowerCase();
          bValue = String(bValue).toLowerCase();

          if (aValue < bValue) {
            return sortConfig.direction === 'asc' ? -1 : 1;
          }
          if (aValue > bValue) {
            return sortConfig.direction === 'asc' ? 1 : -1;
          }
          return 0;
        });

        currentPage = 1; // Volver a la primera página al cambiar el orden
        updateTable();

        filteredMembers.sort((a, b) => {
          const aValue = a[sortConfig.key]?.toString().toLowerCase() || '';
          const bValue = b[sortConfig.key]?.toString().toLowerCase() || '';

          if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
          if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
          return 0;
        });

        currentPage = 1;
        updateTable();
      }

      // Función para actualizar la información de paginación
      function updatePaginationInfo() {
        if (!pageInfo) return;
        const totalPages = Math.ceil(filteredMembers.length / itemsPerPage);

        // Actualizar el contador de página
        pageInfo.textContent = `Página ${currentPage} de ${totalPages} (${filteredMembers.length} miembros)`;

        // Actualizar estado de los botones de paginación
        if (prevButton) {
          prevButton.disabled = currentPage <= 1;
        }
        if (nextButton) {
          nextButton.disabled = currentPage >= totalPages;
        }

        // Actualizar los botones de página
        updatePageButtons(totalPages);
      }

      // Función para manejar el cambio de página
      function handlePageChange(page) {
        if (page >= 1 && page <= Math.ceil(filteredMembers.length / itemsPerPage)) {
          currentPage = page;
          updateTable();
        }
      }

      // Función para actualizar los botones de página
      function updatePageButtons(totalPages) {
        const paginationContainer = document.getElementById('pagination-container');
        if (!paginationContainer || totalPages <= 0) {
          return;
        }

        // Usar event delegation en el contenedor de paginación
        const handlePaginationClick = (e) => {
          const target = e.target.closest('button');
          if (!target) return;

          e.preventDefault();
          e.stopPropagation();

          if (target.id === 'prev-button' && currentPage > 1) {
            handlePageChange(currentPage - 1);
          } else if (target.id === 'next-button' && currentPage < totalPages) {
            handlePageChange(currentPage + 1);
          } else if (target.classList.contains('page-button')) {
            const page = parseInt(target.getAttribute('data-page'));
            if (!isNaN(page)) {
              handlePageChange(page);
            }
          }
        };

        // Remover el event listener anterior si existe
        if (paginationContainer._clickHandler) {
          paginationContainer.removeEventListener('click', paginationContainer._clickHandler);
        }
        // Guardar la referencia a la función para poder eliminarla después
        paginationContainer._clickHandler = handlePaginationClick;
        paginationContainer.addEventListener('click', handlePaginationClick);

        let buttons = [];
        
        // Botón Anterior
        buttons.push(`
          <button 
            id="prev-button"
            class="px-3 py-1 rounded-md ${currentPage <= 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-amber-500/20 hover:text-amber-300'} transition-colors"
            title="Página anterior"
            ${currentPage <= 1 ? 'disabled' : ''}
          >
            &lt;
          </button>
        `);

        const maxVisiblePages = 5;
        let startPage, endPage;

        if (totalPages <= maxVisiblePages) {
          startPage = 1;
          endPage = totalPages;
        } else {
          // Calcular qué páginas mostrar
          if (currentPage <= Math.ceil(maxVisiblePages / 2)) {
            startPage = 1;
            endPage = maxVisiblePages - 2;
          } else if (currentPage + Math.floor(maxVisiblePages / 2) >= totalPages) {
            startPage = totalPages - maxVisiblePages + 3;
            endPage = totalPages;
          } else {
            startPage = currentPage - Math.floor((maxVisiblePages - 2) / 2);
            endPage = currentPage + Math.floor((maxVisiblePages - 2) / 2);
          }

          // Asegurarnos de no salirnos de los límites
          startPage = Math.max(1, startPage);
          endPage = Math.min(totalPages, endPage);
        }



        // Primera página
        if (startPage > 1) {
          buttons.push(`
            <button 
              class="px-3 py-1 rounded-md ${currentPage === 1 ? 'bg-accent/20 text-accent font-medium' : 'hover:bg-steel-dark'} transition-colors page-button"
              data-page="1"
            >
              1
            </button>
          `);

          if (startPage > 2) {
            buttons.push('<span class="px-2">...</span>');
          }
        }

        // Páginas intermedias
        for (let i = startPage; i <= endPage; i++) {
          buttons.push(`
            <button 
              class="px-3 py-1 rounded-md ${currentPage === i ? 'bg-amber-600 text-white' : 'hover:bg-amber-500/20 hover:text-amber-300 text-text-muted'} transition-colors page-button"
              data-page="${i}"
              title="Ir a la página ${i}"
            >
              ${i}
            </button>
          `);
        }

        // Última página
        if (endPage < totalPages) {
          if (endPage < totalPages - 1) {
            buttons.push('<span class="px-2">...</span>');
          }

          buttons.push(`
            <button 
              class="px-3 py-1 rounded-md ${currentPage === totalPages ? 'bg-accent/20 text-accent font-medium' : 'hover:bg-steel-dark'} transition-colors page-button"
              data-page="${totalPages}"
            >
              ${totalPages}
            </button>
          `);
        }

        // Botón Siguiente
        buttons.push(`
          <button 
            id="next-button"
            class="px-3 py-1 rounded-md ${currentPage >= totalPages ? 'opacity-50 cursor-not-allowed' : 'hover:bg-amber-500/20 hover:text-amber-300'} transition-colors"
            title="Página siguiente"
            ${currentPage >= totalPages ? 'disabled' : ''}
          >
            &gt;
          </button>
        `);

        paginationContainer.innerHTML = buttons.join('');
      }

      // Función para actualizar los indicadores de ordenación
      function updateSortIndicators() {
        document.querySelectorAll('th[data-sort]').forEach((th) => {
          const sortKey = th.getAttribute('data-sort');
          if (!sortKey) return;

          const indicator = th.querySelector('.sort-indicator');
          if (!indicator) return;

          if (sortConfig.key === sortKey) {
            indicator.textContent = sortConfig.direction === 'asc' ? '↑' : '↓';
          } else {
            indicator.textContent = '↕';
          }
        });
      }

      // Función para filtrar miembros según los filtros aplicados
      function filterMembers() {
        if (!searchInput || !classFilter || !rankFilter) return;

        const searchTerm = searchInput.value.toLowerCase();
        const selectedClass = classFilter.value;
        const selectedRank = rankFilter.value;

        filteredMembers = allMembers.filter((member) => {
          const matchesSearch =
            searchTerm === '' ||
            member.name.toLowerCase().includes(searchTerm) ||
            (member.publicNote && member.publicNote.toLowerCase().includes(searchTerm));
          const matchesClass = selectedClass === '' || member.class === selectedClass;
          const matchesRank = selectedRank === '' || member.rank === selectedRank;

          return matchesSearch && matchesClass && matchesRank;
        });

        currentPage = 1;
        updateTable();
      }

      // Event listeners
      if (searchInput) {
        searchInput.addEventListener('input', filterMembers);
      }

      if (classFilter) {
        classFilter.addEventListener('change', filterMembers);
      }

      if (rankFilter) {
        rankFilter.addEventListener('change', filterMembers);
      }

      if (prevButton) {
        prevButton.addEventListener('click', () => {
          if (currentPage > 1) {
            currentPage--;
            updateTable();
          }
        });
      }

      if (nextButton) {
        nextButton.addEventListener('click', () => {
          const totalPages = Math.ceil(filteredMembers.length / itemsPerPage);
          if (currentPage < totalPages) {
            currentPage++;
            updateTable();
          }
        });
      }

      // Inicializar encabezados ordenables
      document.querySelectorAll('th[data-sort]').forEach((th) => {
        th.addEventListener('click', () => {
          const sortKey = th.getAttribute('data-sort');
          if (sortKey) {
            sortMembers(sortKey);
          }
        });
      });

      // Inicializar la tabla
      initTable();

      // Inicializar tooltips después de actualizar la tabla
      initTooltips();

      // Función para actualizar la tabla después de cambios
      const originalUpdateTable = updateTable;
      updateTable = function () {
        originalUpdateTable.apply(this, arguments);
      };
    });
  </script>

  <!-- Estadísticas del Roster -->
  <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6 mt-2">
    <!-- Total de Miembros y Mains/Alts -->
    <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
      <div class="flex justify-between items-center">
        <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">
          Miembros Totales
        </h3>
        <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">{stats.totalMembers || 0}</p>
      </div>
      <div class="grid grid-cols-2 justify-items-center">
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{mainAltStats.M || 0}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Mains</p>
        </div>
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{mainAltStats.A || 0}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Alts</p>
        </div>
      </div>
    </div>

    <!-- Distribución de Roles -->
    <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
      <div class="flex justify-between items-center">
        <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">
          Roles Principales
        </h3>
        <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">
          {Object.values(roleStats).reduce((a, b) => a + b, 0) || 0}
        </p>
      </div>
      <div class="grid grid-cols-3 gap-1 mt-1">
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{roleStats.T || 0}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Tanks</p>
        </div>
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{roleStats.H || 0}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Healers</p>
        </div>
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{roleStats.D || 0}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">DPS</p>
        </div>
      </div>
    </div>

    <!-- Combinaciones de Roles Duales -->
    <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
      <div class="flex justify-between items-center">
        <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">
          Roles Duales
        </h3>
        <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">
          {dualRoleStats.TH + dualRoleStats.TD + dualRoleStats.HD}
        </p>
      </div>
      <div class="grid grid-cols-3 gap-1 mt-1">
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{dualRoleStats.TH}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Tank / Heal</p>
        </div>
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{dualRoleStats.TD}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Tank / DPS</p>
        </div>
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{dualRoleStats.HD}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Heal / DPS</p>
        </div>
      </div>
    </div>

    <!-- Gear Score -->
    <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
      <div class="flex justify-between items-center">
        <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">
          Gear Score
        </h3>
        <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">
          {averageGearScore !== 'N/A' ? averageGearScore : 'N/A'}
        </p>
      </div>
      <div class="grid grid-cols-2 gap-1 mt-1">
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">
            {minGearScore !== 'N/A' ? minGearScore : 'N/A'}
          </p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Mínimo</p>
        </div>
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">
            {maxGearScore !== 'N/A' ? maxGearScore : 'N/A'}
          </p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Máximo</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Tabla de miembros -->
  <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
    <div class="overflow-x-auto rounded-t-xl">
      <table
        class="min-w-full divide-y divide-accent bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 p-2 sm:p-3"
      >
        <thead class="bg-gradient-to-r from-amber-900/50 to-amber-800/30">
          <tr>
            <th
              data-column="name"
              class="text-center text-xs font-semibold text-amber-300/90 uppercase tracking-wider cursor-pointer hover:text-amber-200 transition-colors"
              data-sort="name"
            >
              <div class="flex items-center justify-center">
                <span class="py-2">Personaje</span>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="ml-1 h-3.5 w-3.5 opacity-70"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                </svg>
              </div>
            </th>
            <th
              data-column="details"
              class="text-center text-xs font-semibold text-amber-300/90 uppercase tracking-wider cursor-pointer hover:text-amber-200 transition-colors"
              data-sort="publicNote"
            >
              <div class="flex items-center justify-center">
                <span class="py-2">Detalles</span>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="ml-1 h-3.5 w-3.5 opacity-70"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                </svg>
              </div>
            </th>
          </tr>
        </thead>
        <tbody id="roster-table-body" class="divide-y divide-accent">
          <!-- Los miembros se cargarán aquí dinámicamente -->
        </tbody>
      </table>
    </div>
    <!-- Controles de paginación -->
    <div
      class="px-2 md:px-6 py-4 bg-gray-900/50 backdrop-blur-sm border-t border-amber-900/30 flex flex-col sm:flex-row items-center justify-between gap-4"
    >
      <div id="page-info" class="text-sm text-text-muted/70">
        Página <span class="font-medium text-white">1</span> de
        <span class="font-medium text-white">1</span>
        <span class="hidden sm:inline">
          (<span class="font-medium text-white">0</span> miembros)
        </span>
      </div>
      <div id="pagination-container" class="flex items-center gap-1">
        <!-- Los botones de paginación se generarán aquí dinámicamente -->
      </div>
    </div>
    <!-- Filtros -->
    <div class="p-6 bg-gray-900/50 backdrop-blur-sm border border-amber-900/30">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div class="relative">
          <label for="search" class="block text-sm font-medium text-text-muted/80 mb-2">
            Buscar por nombre
          </label>
          <input
            type="text"
            id="search"
            placeholder="Nombre..."
            class="w-full bg-transparent border border-accent rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-accent/50 focus:border-transparent placeholder-text-muted/50 transition-all duration-200"
          />
        </div>

        <div class="relative">
          <label for="class-filter" class="block text-sm font-medium text-text-muted/80 mb-2">
            Filtrar por clase
          </label>
          <select
            id="class-filter"
            class="w-full bg-transparent border border-accent rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-accent/50 focus:border-transparent appearance-none transition-all duration-200 cursor-pointer hover:border-accent/40"
          >
            <option value="">Todas las clases</option>
            {
              Object.entries(rosterData.classInfo).map(([key, info]) => (
                <option value={key} style={`color: #${info.color}`}>
                  {info.name}
                </option>
              ))
            }
          </select>
        </div>

        <div class="relative">
          <label for="rank-filter" class="block text-sm font-medium text-text-muted/80 mb-2">
            Filtrar por rango
          </label>
          <select
            id="rank-filter"
            class="w-full bg-transparent border border-accent rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-accent/50 focus:border-transparent appearance-none transition-all duration-200 cursor-pointer hover:border-accent/40"
          >
            <option value="">Todos los rangos</option>
            {
              ranks.map((rank) => (
                <option value={rank} class="text-white">
                  {rank}
                </option>
              ))
            }
          </select>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Sección de estadísticas -->
<div class="mt-8 bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6">
  <h2 class="text-xl font-semibold mb-6 text-center text-amber-200/90 uppercase tracking-wider">
    Estadísticas del Roster
  </h2>
  <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
    <!-- Columna 1: Distribución por Rango -->
    <div
      class="bg-gray-900/70 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6 hover:border-amber-800/50 transition-colors"
    >
      <h3 class="text-amber-300/90 text-lg font-medium mb-4 text-center uppercase tracking-wider">
        Por Rango
      </h3>
      <div class="space-y-3">
        {
          rankDistribution.map(({ name, count, percentage }) => {
            // Asignar colores según el rango
            let colorClass = 'from-accent to-accent-light';
            if (name === 'Guild Master') colorClass = 'from-yellow-400 to-yellow-600';
            else if (name === 'Alter') colorClass = 'from-purple-400 to-purple-600';
            else if (name === 'Explorador') colorClass = 'from-blue-400 to-blue-600';
            else if (name === 'Iniciado') colorClass = 'from-green-400 to-green-600';
            else if (name === 'Aspirante') colorClass = 'from-gray-400 to-gray-600';

            return (
              <div class="space-y-1.5">
                <div class="flex items-center justify-between text-xs">
                  <span class="text-amber-100/80">{name}</span>
                  <div class="flex items-center">
                    <span class="text-white font-semibold mr-1">{count}</span>
                    <span class="text-amber-100/60 text-[11px]">({percentage}%)</span>
                  </div>
                </div>
                <div class="w-full bg-amber-900/30 rounded-full h-1.5 overflow-hidden">
                  <div
                    class="h-full rounded-full bg-gradient-to-r transition-all duration-500 ease-out"
                    class:list={[colorClass]}
                    style={{ width: `${percentage}%` }}
                  />
                </div>
              </div>
            );
          })
        }
      </div>
    </div>

    <!-- Columna 2: Distribución por Clase -->
    <div
      class="bg-gray-900/70 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6 hover:border-amber-800/50 transition-colors"
    >
      <h3 class="text-amber-300/90 text-lg font-medium mb-4 text-center uppercase tracking-wider">
        Por Clase
      </h3>
      <div class="space-y-3">
        {
          classDistribution.map(({ name, count, color: classColor }) => {
            const percentage = Math.round((count / rosterData.members.length) * 100);
            return (
              <div class="space-y-1.5">
                <div class="flex items-center justify-between text-xs">
                  <div class="flex items-center">
                    <span
                      class="w-2.5 h-2.5 rounded-full mr-2 border border-amber-900/30"
                      style={`background-color: #${classColor}`}
                    />
                    <span class="text-amber-100/80">{name}</span>
                  </div>
                  <div class="flex items-center">
                    <span class="text-white font-semibold mr-1">{count}</span>
                    <span class="text-amber-100/60 text-[11px]">({percentage}%)</span>
                  </div>
                </div>
                <div class="w-full bg-amber-900/30 rounded-full h-1.5 overflow-hidden">
                  <div
                    class="h-full rounded-full transition-all duration-500 ease-out"
                    style={{
                      width: `${percentage}%`,
                      background: `linear-gradient(to right, #${classColor}cc, #${classColor}ff)`,
                    }}
                  />
                </div>
              </div>
            );
          })
        }
      </div>
    </div>

    <div
      class="bg-gray-900/70 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6 hover:border-amber-800/50 transition-colors"
    >
      <h3 class="text-amber-300/90 text-lg font-medium mb-4 text-center uppercase tracking-wider">
        Por Profesión
      </h3>
      <div class="space-y-3">
        {
          (() => {
            // Verificar si hay estadísticas de profesiones
            if (!stats.professions || Object.keys(stats.professions).length === 0) {
              return (
                <div class="text-center text-amber-100/60 text-sm py-4">
                  No hay datos de profesiones disponibles
                </div>
              );
            }

            // Obtener el total de miembros con profesiones válidas
            const totalWithProfessions = Object.values(stats.professions).reduce(
              (sum, count) => sum + count,
              0
            );

            // Mostrar todas las profesiones ordenadas por conteo (de mayor a menor)
            return Object.entries(PROFESSION_INFO)
              .map(([code, info]) => {
                const count = stats.professions[code] || 0;
                const percentage =
                  totalWithProfessions > 0
                    ? Math.min(100, Math.round((count / totalWithProfessions) * 100))
                    : 0;

                return {
                  code,
                  name: info.name,
                  count,
                  percentage,
                  colors: info.colors,
                  hasData: count > 0,
                };
              })
              .sort((a, b) => b.count - a.count)
              .map(({ code, name, count, percentage, colors, hasData }) => (
                <div class="space-y-1.5">
                  <div class="flex items-center justify-between text-xs">
                    <div class="flex items-center">
                      <span
                        class="w-2.5 h-2.5 rounded-full mr-2 border border-amber-900/30"
                        style={`background-color: ${colors.dark}`}
                      />
                      <span class="text-amber-100/80">{name}</span>
                    </div>
                    <div class="flex items-center">
                      <span class="text-white font-semibold mr-1">{count}</span>
                      <span class="text-amber-100/60 text-[11px]">({percentage}%)</span>
                    </div>
                  </div>
                  <div class="w-full bg-amber-900/30 rounded-full h-1.5 overflow-hidden">
                    <div
                      class="h-full rounded-full transition-all duration-500 ease-out"
                      style={{
                        width: `${percentage}%`,
                        background: `linear-gradient(to right, ${colors.light}, ${colors.dark})`,
                        opacity: hasData ? 1 : 0.5,
                      }}
                    />
                  </div>
                </div>
              ));
          })()
        }
      </div>
    </div>
  </div>

  <!-- Script para el manejo de pestañas -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const tabButtons = document.querySelectorAll<HTMLButtonElement>('.tab-button');
      const tabPanes = document.querySelectorAll<HTMLElement>('.tab-pane');
      const defaultTab = document.getElementById('legend-tab');

      // Activar la pestaña por defecto
      if (defaultTab) {
        defaultTab.classList.remove('hidden');
      }

      tabButtons.forEach((button) => {
        button.addEventListener('click', () => {
          // Remover clases activas
          tabButtons.forEach((btn) => {
            btn.classList.remove('active', 'border-accent', 'text-white');
            btn.classList.add('text-text-muted');
          });

          tabPanes.forEach((pane) => pane.classList.add('hidden'));

          // Activar pestaña clickeada
          button.classList.remove('text-text-muted');
          button.classList.add('active', 'border-accent', 'text-white');

          const tabId = button.getAttribute('data-tab');
          if (tabId) {
            const tabPane = document.getElementById(`${tabId}-tab`);
            if (tabPane) {
              tabPane.classList.remove('hidden');

              // Forzar reflow para activar la animación
              void tabPane.offsetWidth;
              tabPane.style.animation = 'fadeIn 0.3s ease';

              // Remover la animación después de que termine
              setTimeout(() => {
                tabPane.style.animation = '';
              }, 300);
            }
          }
        });
      });
    });
  </script>

  <style>
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .tab-pane {
      animation: fadeIn 0.3s ease-out;
    }
  </style>

  <!-- Estilos para las pestañas -->
  <style>
    .tab-button {
      transition: all 0.2s ease;
      margin-bottom: -1px;
    }
    .tab-button:hover {
      color: white;
    }
    .tab-button.active {
      border-bottom-color: #3b82f6;
      color: white;
    }
    .tab-pane {
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</div>
