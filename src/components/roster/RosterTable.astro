---
import rosterJson from '../../data/roster.json';
import {
  calculateRosterStats,
  getRolePercentage,
  getRoleColor,
  getRoleName,
} from '../../utils/rosterStats';
import { validatePublicNote } from '../../utils/rosterUtils';
import { ROLES, STATUS, PROFESSIONS, RAIDS, DIFFICULTIES } from '../../types/roster';

// Calcular estadísticas del roster
const rosterStats = calculateRosterStats(rosterJson);

// Mapeo de roles a nombres completos y colores
const roleNames: Record<Role, { name: string; color: string; bgColor: string }> = {
  T: { name: 'Tanque', color: 'text-blue-300', bgColor: 'bg-blue-500/20' },
  H: { name: 'Sanador', color: 'text-green-300', bgColor: 'bg-green-500/20' },
  D: { name: 'DPS', color: 'text-red-300', bgColor: 'bg-red-500/20' },
};

// Mapeo de profesiones a colores
const professionColors: Record<string, string> = {
  AL: 'bg-green-500/20 text-green-300',
  HB: 'bg-green-500/20 text-green-300',
  TL: 'bg-pink-500/20 text-pink-300',
  EN: 'bg-purple-500/20 text-purple-300',
  EG: 'bg-blue-500/20 text-blue-300',
  JC: 'bg-yellow-500/20 text-yellow-300',
  BS: 'bg-gray-500/20 text-gray-300',
  IN: 'bg-indigo-500/20 text-indigo-300',
  MN: 'bg-gray-600/20 text-gray-400',
  SK: 'bg-orange-500/20 text-orange-300',
};

// Mapeo de dificultades a colores
const difficultyColors: Record<string, string> = {
  '10N': 'bg-blue-500/20 text-blue-300',
  '25N': 'bg-purple-500/20 text-purple-300',
  '25H': 'bg-red-500/20 text-red-300',
};

// Función para obtener el color de fondo basado en la clase del personaje
function getClassColor(className: string): string {
  const classColors: Record<string, string> = {
    Guerrero: 'bg-[#C79C6E]',
    Paladín: 'bg-[#F58CBA]',
    Cazador: 'bg-[#ABD473]',
    Pícaro: 'bg-[#FFF569]',
    Sacerdote: 'bg-[#FFFFFF]',
    'Caballero de la Muerte': 'bg-[#C41F3B]',
    Chamán: 'bg-[#0070DE]',
    Mago: 'bg-[#69CCF0]',
    Brujo: 'bg-[#9482C9]',
    Monje: 'bg-[#00FF96]',
    Druida: 'bg-[#FF7D0A]',
    'Cazador de demonios': 'bg-[#A330C9]',
  };
  return classColors[className] || 'bg-gray-500';
}

// Función para obtener el color de la profesión
function getProfessionColor(profCode: ProfessionCode): string {
  const professionColors = {
    JC: { light: 'bg-yellow-500/20', dark: 'text-yellow-300' },
    BS: { light: 'bg-gray-500/20', dark: 'text-gray-300' },
    EN: { light: 'bg-purple-500/20', dark: 'text-purple-300' },
    EG: { light: 'bg-blue-500/20', dark: 'text-blue-300' },
    LW: { light: 'bg-amber-500/20', dark: 'text-amber-300' },
    AL: { light: 'bg-green-500/20', dark: 'text-green-300' },
    TL: { light: 'bg-pink-500/20', dark: 'text-pink-300' },
    IN: { light: 'bg-indigo-500/20', dark: 'text-indigo-300' },
    HB: { light: 'bg-green-500/20', dark: 'text-green-300' },
    MN: { light: 'bg-gray-600/20', dark: 'text-gray-400' },
    SK: { light: 'bg-orange-500/20', dark: 'text-orange-300' },
  };

  const color = professionColors[profCode] || { light: 'bg-gray-500/20', dark: 'text-gray-400' };
  return `${color.light} ${color.dark}`;
}

// Define RosterMember interface
interface RosterMember {
  name: string;
  class: ClassName;
  rank: string;
  publicNote?: string;
  noteValidation: ReturnType<typeof validatePublicNote>;
  [key: string]: any; // For other properties that might exist
}

// Procesar datos del roster con prioridad para Guild Master y Oficiales
const rosterMembers: RosterMember[] = rosterJson
  .map((member: any) => ({
    ...member,
    class: member.class as ClassName,
    noteValidation: validatePublicNote(member.publicNote, member.name),
    // Agregar campo de prioridad para ordenación inicial
    _priority: member.rank === 'Guild Master' ? 0 : member.rank === 'Oficial' ? 1 : 2,
  }))
  // Ordenar por prioridad (Guild Master -> Oficiales -> Resto) y luego por nombre
  .sort((a, b) => {
    if (a._priority !== b._priority) {
      return a._priority - b._priority;
    }
    return a.name.localeCompare(b.name);
  });

// Definir la estructura de rosterData
const rosterData: RosterData = {
  members: rosterMembers,
  classInfo: {
    Guerrero: { color: 'C79C6E', name: 'Guerrero' },
    Paladín: { color: 'F58CBA', name: 'Paladín' },
    Cazador: { color: 'ABD473', name: 'Cazador' },
    Pícaro: { color: 'FFF569', name: 'Pícaro' },
    Sacerdote: { color: 'FFFFFF', name: 'Sacerdote' },
    'Caballero de la Muerte': { color: 'C41F3B', name: 'Caballero de la Muerte' },
    Chamán: { color: '0070DE', name: 'Chamán' },
    Mago: { color: '69CCF0', name: 'Mago' },
    Brujo: { color: '9482C9', name: 'Brujo' },
    Monje: { color: '00FF96', name: 'Monje' },
    Druida: { color: 'FF7D0A', name: 'Druida' },
    'Cazador de demonios': { color: 'A330C9', name: 'Cazador de demonios' },
  },
  ranks: [],
  classes: [],
  totalMembers: rosterMembers.length,
  rankInfo: {}
};

// Calcular distribución de roles (separando roles únicos, duales y dobles)
const roleDistribution: RoleDistributionItem[] = [
  // Roles únicos
  { role: 'T', name: 'Tanque', count: 0, percentage: 0 },
  { role: 'H', name: 'Sanador', count: 0, percentage: 0 },
  { role: 'D', name: 'DPS', count: 0, percentage: 0 },
  // Roles duales
  { role: 'TH', name: 'Tanque/Sanador', count: 0, percentage: 0 },
  { role: 'TD', name: 'Tanque/DPS', count: 0, percentage: 0 },
  { role: 'HD', name: 'Sanador/DPS', count: 0, percentage: 0 },
  // Roles dobles
  { role: 'TT', name: 'Doble Tanque', count: 0, percentage: 0 },
  { role: 'HH', name: 'Doble Sanador', count: 0, percentage: 0 },
  { role: 'DD', name: 'Doble DPS', count: 0, percentage: 0 },
];

// Contar roles únicos, duales y dobles
rosterData.members.forEach((member) => {
  const validation = member.noteValidation;

  if (validation?.isValid && validation.role) {
    // Asegurarse de que los roles estén en mayúsculas
    const mainRoleUpper = validation.role.toUpperCase() as Role;
    const dualRoleUpper = validation.dualRole?.toUpperCase() as Role | undefined;
    
    // Contar rol principal
    const mainRole = roleDistribution.find((r) => r.role === mainRoleUpper);
    if (mainRole) {
      mainRole.count++;
    }

    // Si tiene rol dual, contarlo como rol dual (combinación de ambos roles)
    if (dualRoleUpper) {
      // Ordenar los roles alfabéticamente para asegurar consistencia (ej: 'HT' se convierte en 'TH')
      const roles = [mainRoleUpper, dualRoleUpper].sort().join('');

      // Buscar el rol dual en la distribución (comparación insensible a mayúsculas/minúsculas)
      const roleCombo = roleDistribution.find((r) => r.role === roles);
      
      if (roleCombo) {
        roleCombo.count++;
      } else {
        // Si no se encuentra, intentar con el orden inverso
        const reversedRoles = roles.split('').reverse().join('');
        const reversedCombo = roleDistribution.find((r) => r.role === reversedRoles);
        if (reversedCombo) {
          reversedCombo.count++;
        }
      }
    }
  }
});

// Calcular porcentajes basados en el total de roles (no de miembros)
const totalRoles = roleDistribution.reduce(
  (sum: number, role: { count: number }) => sum + role.count,
  0
);
roleDistribution.forEach((role: { count: number; percentage?: number }) => {
  role.percentage = totalRoles > 0 ? Math.round((role.count / totalRoles) * 100) : 0;
});

// Filtrar solo roles con conteo mayor a 0
const filteredRoleDistribution = roleDistribution.filter((r) => r.count > 0);

// Inicializamos las variables que se usan más adelante
let totalMains = 0;
let totalAlts = 0;
let totalUnspecified = 0;

// Calcular estadísticas de gear score
const gearScores = rosterData.members
  .map((m) => {
    const gs = m.noteValidation?.gearScore ? parseFloat(m.noteValidation.gearScore) : 0;
    return isNaN(gs) ? 0 : gs;
  })
  .filter((gs) => gs > 0);

const gearScoreStats = {
  min: gearScores.length > 0 ? Math.min(...gearScores) : 0,
  max: gearScores.length > 0 ? Math.max(...gearScores) : 0,
  avg:
    gearScores.length > 0
      ? Math.round((gearScores.reduce((a, b) => a + b, 0) / gearScores.length) * 10) / 10
      : 0,
  total: gearScores.length,
};

// Contar raid leaders
const raidLeaders = rosterData.members.filter((m) => m.noteValidation?.isRaidLeader).length;

// Expresiones regulares comunes
const REGEX = {
  GEAR_SCORE: /(\d+\.\d+)/,
  HOUR: /(\d{1,2})h/gi,
  PROFESSIONS: new RegExp(
    `(${Object.keys(PROFESSIONS).join('|')})\s*[\/\s]\s*(${Object.keys(PROFESSIONS).join('|')})`,
    'i'
  ),
  // Ajustada para capturar raids con o sin espacio antes de la dificultad
  RAID_WITH_DIFFICULTY: new RegExp(
    `(${Object.keys(RAIDS).join('|')})\s*(${Object.keys(DIFFICULTIES).join('|')}|H)`,
    'gi'
  ),
  // Añadida para capturar raids seguidas de dificultad sin espacio
  RAID_WITH_DIFFICULTY_NO_SPACE: new RegExp(
    `(${Object.keys(RAIDS).join('|')})(${Object.keys(DIFFICULTIES).join('|')}|H)`,
    'gi'
  ),
  RAID_ONLY: new RegExp(`(${Object.keys(RAIDS).join('|')})(?![0-9A-Za-z])`, 'gi'), // Negative lookahead para evitar falsos positivos
};

// ==========================================
// TIPOS
// ==========================================

type ClassName =
  | 'Guerrero'
  | 'Paladín'
  | 'Cazador'
  | 'Pícaro'
  | 'Sacerdote'
  | 'Caballero de la Muerte'
  | 'Chamán'
  | 'Mago'
  | 'Brujo'
  | 'Druida';

type Role = keyof typeof ROLES;
type MainAlt = keyof typeof STATUS;
type ProfessionCode = keyof typeof PROFESSIONS;
type RaidCode = keyof typeof RAIDS;
type DifficultyCode = keyof typeof DIFFICULTIES;

interface RaidInfo {
  name: string;
  difficulty?: string;
  code: string;
  difficultyCode?: string;
}

interface PublicNoteValidation {
  isValid: boolean;
  mainAlt?: MainAlt;
  role?: Role;
  dualRole?: Role;
  gearScore?: string;
  professions?: string[];
  schedules?: string[];
  raids?: RaidInfo[];
  isRaidLeader?: boolean;
  error?: string;
  missingFields?: string[];
}

interface ClassInfo {
  color: string;
  name: string;
}

interface RosterData {
  members: RosterMember[];
  classInfo: Record<string, ClassInfo>;
  rankInfo: Record<string, { name: string; order: number }>;
}

// Class info is already defined in the RosterData interface

// Validar nota pública según el formato requerido
function validatePublicNote(note: string | undefined, characterName: string = 'Desconocido'): PublicNoteValidation {
  const errors: string[] = [];
  const missingFields: string[] = [];
  const result: PublicNoteValidation = {
    isValid: false,
    raids: [],
  };

  if (!note?.trim()) {
    return { ...result, error: 'La nota pública no puede estar vacía' };
  }

  const trimmedNote = note.trim();
  const parts = trimmedNote.split(/\s+/); // Dividir por cualquier espacio en blanco

  // 1. Detección de Main/Alt (M/A) - Prioridad a patrones con roles
  
  // Patrón 1: M o A seguido de rol (ej: 'MT', 'AD', 'MH', 'AH')
  const mainAltWithRole = trimmedNote.match(/^([MA])([THD])(?:[^a-zA-Z]|$)/i);
  if (mainAltWithRole) {
    result.mainAlt = mainAltWithRole[1].toUpperCase() as MainAlt;
    result.role = mainAltWithRole[2].toUpperCase() as Role;
  } 
  
  // Patrón 2: M o A al inicio de la nota (ej: 'M 5.9', 'A TL/EN')
  if (!result.mainAlt) {
    const startWithMainAlt = trimmedNote.match(/^([MA])(?:\s+|$)/i);
    if (startWithMainAlt) {
      result.mainAlt = startWithMainAlt[1].toUpperCase() as MainAlt;
    }
  }
  
  // Patrón 3: M o A con separador (ej: 'M/Tank', 'A-Healer')
  if (!result.mainAlt) {
    const mainAltWithSeparator = trimmedNote.match(/(?:^|[\s/\-|])([MA])(?=$|[\s/\-|])/i);
    if (mainAltWithSeparator) {
      result.mainAlt = mainAltWithSeparator[1].toUpperCase() as MainAlt;
    }
  }
  
  // Patrón 4: M o A en cualquier parte como palabra completa (último recurso)
  if (!result.mainAlt) {
    const mainAltAnywhere = trimmedNote.match(/(?:^|\s)([MA])(?:\s|$)/i);
    if (mainAltAnywhere) {
      result.mainAlt = mainAltAnywhere[1].toUpperCase() as MainAlt;
    }
  }

  // 2. Buscar si es Raid Leader (RL o rl)
  // Buscar patrones como 'RL', 'rl', 'RaidLeader', 'raid leader', etc.
  result.isRaidLeader = /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl)(?=\s|$)/i.test(trimmedNote);
  
  // También verificar si está en formato como '18xrl' (común en notas)
  if (!result.isRaidLeader) {
    result.isRaidLeader = /\d*[xX]\s*rl\b/i.test(trimmedNote);
  }

  // 3. Buscar roles (T, H, D) y rol dual
  // Primero buscar formato de 3 letras que comience con A o M (ej: MDT, AHT, etc.)
  const threeLetterRoleMatch = trimmedNote.match(/\b([MA]?)([THD])([THD]?)\b/i);

  if (threeLetterRoleMatch) {
    const [, mainAlt, primaryRole, dualRole] = threeLetterRoleMatch;
    
    // Si hay un prefijo M o A, establecer mainAlt
    if (mainAlt) {
      result.mainAlt = mainAlt.toUpperCase() as MainAlt;
    } else if (!result.mainAlt && threeLetterRoleMatch[0].startsWith('M')) {
      // Si no hay mainAlt pero el match empieza con M, asumir que es Main
      result.mainAlt = 'M';
    }
    
    // Establecer rol principal
    result.role = primaryRole.toUpperCase() as Role;
    
    // Si hay un rol dual, establecerlo
    if (dualRole) {
      const dual = dualRole.toUpperCase() as Role;
      if (dual !== result.role) {
        result.dualRole = dual;
      } else {
        errors.push('El rol secundario no puede ser igual al principal');
      }
    }
  }
  
  // Si no se encontró un rol dual, buscar cualquier otro rol en la nota
  if (!result.dualRole) {
    // Buscar cualquier letra T, H o D que no sea parte de otra palabra
    const roleMatches = [...trimmedNote.matchAll(/\b([THD])\b/gi)];
    const roles = Array.from(new Set(roleMatches.map((m) => m[1].toUpperCase())));
    
    // Si hay más de un rol, establecer el segundo como dual
    if (roles.length > 1) {
      const primary = result.role || roles[0];
      const secondary = roles.find(r => r !== primary) as Role;
      
      if (secondary) {
        if (!result.role) result.role = primary as Role;
        result.dualRole = secondary;
      }
    } else if (roles.length === 1 && !result.role) {
      // Si solo hay un rol y no se ha establecido, usarlo como principal
      result.role = roles[0] as Role;
    }
  }
  
  // Si aún no se ha encontrado un rol, buscar en otros formatos
  if (!result.role) {
    // Último intento: buscar cualquier combinación de roles (ej: TH, HD, DT, etc.)
    const dualRoleMatch = trimmedNote.match(/\b([THD]{2,})\b/i);
    if (dualRoleMatch) {
      const rolesStr = dualRoleMatch[1].toUpperCase();
      result.role = rolesStr[0] as Role;
      if (rolesStr.length > 1 && rolesStr[1] !== rolesStr[0]) {
        result.dualRole = rolesStr[1] as Role;
      }
    }
  }

  if (!result.role) {
    missingFields.push(`Rol principal (${Object.keys(ROLES).join(', ')})`);
  }

  // 2. Extraer Gear Score - Múltiples formatos soportados:
  //    - Números de 4 dígitos (ej: 5585 -> 5.5)
  //    - Números decimales con punto o coma (ej: 5.9, 6,2)
  //    - Números rodeados de cualquier carácter
  //    - Prefijos comunes como 'GS', 'gs', 'ilvl', 'iLvl', etc.
  let gsValue: string | null = null;
  
  // Patrón 1: Buscar formato XXXX (4 dígitos) en cualquier parte
  const fourDigitMatch = trimmedNote.match(/\b(\d{4})\b/);
  if (fourDigitMatch) {
    const num = parseInt(fourDigitMatch[1]);
    gsValue = (num / 1000).toFixed(1);
  } 
  // Patrón 2: Buscar números decimales con punto o coma
  else {
    const decimalMatch = trimmedNote.match(/(\d[\.,]\d\d?)/);
    if (decimalMatch) {
      gsValue = decimalMatch[1].replace(',', '.');
    }
  }
  
  // Patrón 3: Buscar después de prefijos comunes (GS, ilvl, etc.)
  if (!gsValue) {
    const prefixMatch = trimmedNote.match(/(?:GS|gs|ilvl|iLvl|gear|Gear|gs:?\s*)(?:\s*[:=]?\s*)(\d[\.,]?\d?\d?)/i);
    if (prefixMatch) {
      gsValue = prefixMatch[1].replace(',', '.');
      // Asegurar formato decimal correcto
      if (!gsValue.includes('.')) {
        gsValue = gsValue + '.0';
      }
    }
  }
  
  // Validar y guardar el Gear Score encontrado
  if (gsValue) {
    const gsNumber = parseFloat(gsValue);
    if (!isNaN(gsNumber) && gsNumber >= 0.1 && gsNumber <= 10) {
      result.gearScore = gsNumber.toFixed(1);
    } else {
      errors.push('El Gear Score debe estar entre 0.1 y 10');
    }
  } else if (!trimmedNote.match(/GS|gs|ilvl|iLvl|gear|Gear|\d[\.,]\d|\d{4}/i)) {
    // Solo marcar como faltante si no hay ningún indicio de GS en la nota
    missingFields.push('Gear Score (ej: 5.9, 6.2, 5585)');
  }

  // 3. Extraer Profesiones - Opcionales pero recomendadas
  const profCodes = Object.keys(PROFESSIONS).join('|');
  
  const foundProfs = new Set<string>();
  
  // Patrón 1: Buscar códigos juntos sin separador (ej: 'TLen')
  // Primero buscamos cualquier secuencia de 4-6 letras mayúsculas
  const combinedProfRegex = /[A-Z]{4,6}/g;
  let combinedMatch;
  
  while ((combinedMatch = combinedProfRegex.exec(trimmedNote.toUpperCase())) !== null) {
    const combinedText = combinedMatch[0];
    
    // Buscar códigos de profesión dentro del texto combinado
    let remainingText = combinedText;
    while (remainingText.length >= 2) {
      let found = false;
      // Probar con códigos de 2 caracteres primero (y luego 3 si es necesario)
      for (let i = 2; i <= 3 && i <= remainingText.length; i++) {
        const possibleCode = remainingText.substring(0, i);
        if (profCodes.includes(possibleCode)) {
          foundProfs.add(possibleCode as ProfessionCode);
          remainingText = remainingText.substring(i);
          found = true;
          break;
        }
      }
      // Si no se encontró un código válido, avanzar un carácter
      if (!found) {
        remainingText = remainingText.substring(1);
      }
      // No buscar más de 3 profesiones (máximo razonable)
      if (foundProfs.size >= 3) break;
    }
    
    
    // Si ya encontramos 2 profesiones, no es necesario seguir buscando
    if (foundProfs.size >= 2) break;
  }
  
  // Si no encontramos códigos juntos, buscar otros patrones
  if (foundProfs.size < 2) {
    // Patrón 2: Buscar el patrón específico 'TL/en' o similar
    const directProfRegex = new RegExp(`\b(${profCodes})[/,\s-](${profCodes})\b`, 'i');
    const directMatch = directProfRegex.exec(trimmedNote);
    
    if (directMatch) {
      const code1 = directMatch[1].toUpperCase() as ProfessionCode;
      const code2 = directMatch[2].toUpperCase() as ProfessionCode;
      if (PROFESSIONS[code1]) foundProfs.add(code1);
      if (PROFESSIONS[code2]) foundProfs.add(code2);
    }
    
    // Patrón 3: Buscar códigos individuales
    if (foundProfs.size < 2) {
      const singleProfRegex = new RegExp(`(?:^|[^a-zA-Z])(${profCodes})(?![a-zA-Z])`, 'gi');
      let singleMatch;
      
      while ((singleMatch = singleProfRegex.exec(trimmedNote)) !== null && foundProfs.size < 2) {
        const code = singleMatch[1].toUpperCase() as ProfessionCode;
        if (PROFESSIONS[code]) {
          foundProfs.add(code);
        }
      }
    }
  }
  
  // Si encontramos al menos una profesión, actualizar el resultado
  if (foundProfs.size > 0) {
    result.professions = Array.from(foundProfs);
  }
  // Convertimos a array y tomamos las dos primeras profesiones únicas
  const uniqueProfs = Array.from(foundProfs);

  
  if (uniqueProfs.length >= 2) {
    const prof1 = uniqueProfs[0] as ProfessionCode;
    const prof2 = uniqueProfs[1] as ProfessionCode;
    
    if (prof1 !== prof2) {
      result.professions = [PROFESSIONS[prof1], PROFESSIONS[prof2]];
    } else {
      errors.push('Las profesiones no pueden ser iguales');
    }
  } else if (uniqueProfs.length === 1) {
    const prof = uniqueProfs[0] as ProfessionCode;
    result.professions = [PROFESSIONS[prof]];
  }

  // 4. Extraer horarios (pueden ser individuales o rangos con formato HHX-HHX)
  const uniqueHours = new Set<string>();

  // Primero buscamos rangos completos (ej: 20X-23X, 20X-23X, 20-23X, etc.)
  // Excluimos que estén pegados a números (para evitar confusión con GS o dificultades)
  const rangeRegex =
    /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X?\s*-\s*(\d{1,2})(?::(\d{2}))?X(?:$|[^\d])/gi;
  const rangeMatches = [];
  let rangeMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((rangeMatch = rangeRegex.exec(trimmedNote)) !== null) {
    rangeMatches.push(rangeMatch);
  }

  // Procesar rangos de horas (ej: 20X-23X, 20-23X, 20X-23, 20-23)
  rangeMatches.forEach((match) => {
    const startHour = parseInt(match[1], 10);
    const startMinutes = match[2] ? parseInt(match[2], 10) : 0;
    const endHour = parseInt(match[3], 10);
    const endMinutes = match[4] ? parseInt(match[4], 10) : 0;

    // Validar que las horas y minutos estén en rango
    if (
      startHour >= 0 &&
      startHour <= 23 &&
      endHour >= 0 &&
      endHour <= 23 &&
      startMinutes >= 0 &&
      startMinutes <= 59 &&
      endMinutes >= 0 &&
      endMinutes <= 59
    ) {
      const formattedStart = `${startHour.toString().padStart(2, '0')}${startMinutes > 0 ? ':' + startMinutes.toString().padStart(2, '0') : ''}X`;
      const formattedEnd = `${endHour.toString().padStart(2, '0')}${endMinutes > 0 ? ':' + endMinutes.toString().padStart(2, '0') : ''}X`;

      uniqueHours.add(formattedStart);
      uniqueHours.add(formattedEnd);
      hasSchedule = true;
    }
  });

  // Luego buscamos horas individuales (que no sean parte de un rango)
  // Ahora detecta con o sin espacios alrededor de la X, pero evita falsos positivos
  const hourRegex = /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X(?:$|[^\d-])/gi;
  const hourMatches = [];
  let hourMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((hourMatch = hourRegex.exec(trimmedNote)) !== null) {
    hourMatches.push(hourMatch);
  }

  hourMatches.forEach((match) => {
    const hour = parseInt(match[1], 10);
    const minutes = match[2] ? parseInt(match[2], 10) : 0;

    if (hour >= 0 && hour <= 23 && minutes >= 0 && minutes <= 59) {
      const formattedHour = hour.toString().padStart(2, '0');
      const formattedMinutes = minutes > 0 ? `:${minutes.toString().padStart(2, '0')}` : '';
      uniqueHours.add(`${formattedHour}${formattedMinutes}X`);
    }
  });

  if (uniqueHours.size > 0) {
    result.schedules = Array.from(uniqueHours).sort();
  } else if (!trimmedNote.match(/\d{1,2}(?::\d{2})?X/)) {
    // Solo agregar el mensaje si no hay ningún formato de horario en la nota
    missingFields.push('Horario de conexión (ej: 18X, 21:30X)');
  }

  // 5. Extraer raids y dificultades por separado
  const allRaidCodes = Object.keys(RAIDS) as RaidCode[];
  const raidCodesPattern = allRaidCodes.map(rc => rc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
  
  // Log para depuración
  console.log(`\n=== INICIO DE DETECCIÓN PARA ${characterName.toUpperCase()} ===`);
  console.log('Nota original:', note);
  console.log('Nota recortada:', trimmedNote);
  console.log('Códigos de raid disponibles:', allRaidCodes);
  
  // Inicializar el conjunto de raids encontradas
  result.raids = [];
  const usedRaids = new Set<string>();
  const usedIndices = new Set<string>();
  
  // 1. Buscar menciones directas de raids
  const raidPattern = new RegExp(`\\b(${raidCodesPattern})\\b`, 'gi');
  let raidMatch;
  
  console.log(`\n[${characterName}] Buscando menciones directas de raids...`);
  while ((raidMatch = raidPattern.exec(trimmedNote)) !== null) {
    const raidCode = raidMatch[1].toUpperCase();
    console.log(`[${characterName}] Raid encontrada:`, raidCode);
    
    if (raidCode in RAIDS && !usedRaids.has(raidCode)) {
      console.log(`[${characterName}] Añadiendo raid:`, raidCode);
      result.raids.push({
        code: raidCode as RaidCode,
        difficultyCode: undefined, // Sin dificultad específica
        difficulty: undefined,
        name: RAIDS[raidCode as keyof typeof RAIDS],
      });
      usedRaids.add(raidCode);
    } else {
      console.log(`[${characterName}] Raid ya añadida o no válida:`, raidCode);
    }
  }
  
  // 2. Buscar dificultades (10n, 25h, etc.)
  const difficultyPattern = /\b(10|25)([hn])\b/gi;
  const foundDifficulties = new Set<string>();
  let diffMatch;
  
  console.log(`\n[${characterName}] Buscando dificultades...`);
  while ((diffMatch = difficultyPattern.exec(trimmedNote)) !== null) {
    const number = diffMatch[1];
    const difficulty = diffMatch[2].toUpperCase() as 'N' | 'H';
    const difficultyCode = `${number}${difficulty}` as DifficultyCode;
    console.log(`[${characterName}] Dificultad encontrada:`, difficultyCode);
    foundDifficulties.add(difficultyCode);
  }

  // Si no encontramos raids con los patrones anteriores, buscar solo los códigos de raid
  console.log(`\n[${characterName}] Verificando si no se encontraron raids...`);
  if (result.raids.length === 0) {
    console.log(`[${characterName}] No se encontraron raids en la primera pasada, buscando con patrón alternativo...`);
    const raidCodePattern = new RegExp(`(?:^|[^a-zA-Z])(${raidCodesPattern})(?=$|[^a-zA-Z0-9])`, 'gi');
    const raidCodeMatches = trimmedNote.matchAll(raidCodePattern);
    console.log(`[${characterName}] Coincidencias encontradas:`, Array.from(raidCodeMatches).map(m => m[1]));
    
    for (const match of raidCodeMatches) {
      const raidCode = match[0].toUpperCase() as RaidCode;
      if (!usedRaids.has(raidCode)) {
        // Type assertion to handle the indexing
        const raidName = raidCode in RAIDS ? RAIDS[raidCode as keyof typeof RAIDS] : raidCode;
        result.raids.push({
          code: raidCode,
          difficultyCode: undefined,
          difficulty: undefined,
          name: raidName,
        });
        usedRaids.add(raidCode);
      }
    }
  }

  // Si no encontramos raids aún, intentar con un patrón más flexible
  if (result.raids.length === 0) {
    const escapedRaidCodes = allRaidCodes.map(raid => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
    const raidPatterns = [
      // Patrón para 'icc10n' o 'voa25h' (sin espacios)
      new RegExp(`(${escapedRaidCodes})(\\d+)([NH])`, 'gi'),
      // Patrón para 'icc 10n' o 'voa 25h' (con espacios)
      new RegExp(`(${escapedRaidCodes})\\s*(\\d+)([NH])`, 'gi'),
      // Patrón para solo el código de raid
      new RegExp(`\\b(${escapedRaidCodes})\\b`, 'gi')
    ];
    
    for (const pattern of raidPatterns) {
      let match;
      while ((match = pattern.exec(trimmedNote)) !== null) {
        const raidCode = match[1]?.toUpperCase() as RaidCode;
        if (!raidCode) continue;
        
        // Type assertion to handle the indexing
        const raidName = raidCode in RAIDS ? RAIDS[raidCode as keyof typeof RAIDS] : raidCode;
        
        // Si es un patrón con dificultad (ej: 'icc10n' o 'icc 10n')
        if (match[2] && match[3]) {
          const difficultyNumber = match[2];
          const difficultyLetter = match[3].toUpperCase();
          const difficultyCode = `${difficultyNumber}${difficultyLetter}` as DifficultyCode;
          
          if (['10N', '10H', '25N', '25H'].includes(difficultyCode)) {
            const raidKey = `${raidCode}${difficultyCode}`;
            if (!usedRaids.has(raidKey)) {
              result.raids.push({
                code: raidCode,
                difficultyCode,
                difficulty: difficultyLetter === 'N' ? 'Normal' : 'Heroic',
                name: raidName,
              });
              usedRaids.add(raidKey);
            }
          }
        } else if (!usedRaids.has(raidCode)) {
          // Si es solo el código de raid sin dificultad
          result.raids.push({
            code: raidCode,
            difficultyCode: undefined,
            difficulty: undefined,
            name: raidName,
          });
          usedRaids.add(raidCode);
        }
        
        if (match.index === pattern.lastIndex) {
          pattern.lastIndex++; // Evitar bucle infinito
        }
      }
    }
  }

  // Verificar si faltan raids o su dificultad (solo como advertencia, no invalida)
  if (result.raids.length === 0) {
    // Verificar si hay algún código de raid sin dificultad
    const raidPatterns = [
      // Patrones para detectar menciones de raid con o sin dificultad
      new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodesPattern})(?![a-z0-9])(?:$|\\s|\\)|\\]|\/)`, 'i'),
      new RegExp(`(${raidCodesPattern})\\s*\\d+[NH]`, 'i'),
      new RegExp(`(${raidCodesPattern})\\d+[NH]`, 'i'),
      new RegExp(`(10|25)[NH](${raidCodesPattern})`, 'i')  // Para formato 10Nicc, 25Hvoa
    ];
    
    const hasAnyRaidMention = raidPatterns.some(pattern => pattern.test(trimmedNote));
    const hasRaidWithDifficulty = new RegExp(`(?:${raidCodesPattern})(?:\\s*\\d+[NH]|\\d+[NH]|(?:10|25)[NH](?=${raidCodesPattern}))`, 'i').test(trimmedNote);
    
    if (hasAnyRaidMention && !hasRaidWithDifficulty) {
      // Solo agregar el mensaje de dificultad faltante si no está ya en el array
      if (!missingFields.some((mf) => mf.includes('Dificultad'))) {
        missingFields.push('Dificultad (ej: 10N, 25H)');
      }
    } else if (!hasAnyRaidMention) {
      // Verificar si hay menciones de raid en el texto sin formato específico
      const raidMentionPattern = new RegExp(`(?:^|\\s|\\(|\\[)(${allRaidCodes.join('|')})(?=$|[^a-zA-Z0-9])`, 'i');
      if (!raidMentionPattern.test(trimmedNote)) {
        missingFields.push('Raids que busca/arma (ej: ICC, TOC)');
      }
    }
  } else if (result.raids.some((raid) => !raid.difficultyCode)) {
    // Verificar si hay alguna mención de dificultad en la nota
    const hasDifficultyMention = /(?:^|\s)(\d+[NH])(?:\s|$)/i.test(trimmedNote);
    if (!hasDifficultyMention && !missingFields.some((mf) => mf.includes('Dificultad'))) {
      missingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 6. Verificar campos faltantes en el orden especificado
  const orderedMissingFields: string[] = [];

  // 1. Main/Alt
  if (!result.mainAlt) {
    orderedMissingFields.push('Main/Alt (M/A)');
  }

  // 2. Rol principal
  if (!result.role) {
    orderedMissingFields.push('Rol (T/H/D)');
  }

  // 3. Dual - Solo mostrar si no se ha detectado un rol dual
  if (!result.dualRole) {
    orderedMissingFields.push('Dual (T/H/D)');
  }

  // 4. Gear Score
  if (!result.gearScore) {
    orderedMissingFields.push('Gear Score (ej: 6.2)');
  }

  // 5. Profesiones
  if (!result.professions || result.professions.length === 0) {
    orderedMissingFields.push('Profesiones (ej: JC/BS)');
  }

  // 6. Horario de juego
  if (!result.schedules || result.schedules.length === 0) {
    orderedMissingFields.push('Horario de juego (ej: 18X, 21:30X)');
  }

  // 7. Verificar raids en la nota
  console.log(`\n=== VERIFICACIÓN FINAL DE RAIDS PARA ${characterName.toUpperCase()} ===`);
  const raidCodes = Object.keys(RAIDS).map(raid => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
  
  // Buscar cualquier mención de raid, con o sin dificultad
  const raidSearchPattern = new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodes})(?![a-z0-9])(?:$|\\s|\\)|\\]|\\/|\\d|\\s*\\d*[NH])`, 'i');
  const hasAnyRaid = raidSearchPattern.test(trimmedNote);
  console.log(`[${characterName}] ¿Se encontró alguna mención de raid?`, hasAnyRaid);
  
  // Buscar específicamente patrones como 'icc10n' o 'voa25h'
  const raidWithNumberPattern = new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodes})\\s*\\d+[NH]`, 'i');
  const hasAnyRaidWithNumber = raidWithNumberPattern.test(trimmedNote);
  console.log(`[${characterName}] ¿Se encontró alguna raid con número?`, hasAnyRaidWithNumber);
  
  // Mostrar las raids encontradas hasta ahora
  console.log(`[${characterName}] Raids encontradas:`, result.raids.map(r => r.code));
  
  if (!hasAnyRaid && !hasAnyRaidWithNumber) {
    orderedMissingFields.push('Raids que busca (ej: ICC 25H)');
  } else if (!result.raids || result.raids.length === 0) {
    // Si no se detectaron raids pero hay menciones de raids con números, asumir que el formato es correcto
    if (!hasAnyRaidWithNumber) {
      orderedMissingFields.push('Formato de raid (ej: ICC 25H)');
    }
  } else {
    // Verificar dificultad para cada raid
    const raidsWithoutDifficulty = result.raids.filter((raid) => !raid.difficultyCode);
    if (raidsWithoutDifficulty.length > 0 && !hasAnyRaidWithNumber) {
      orderedMissingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 8. Raid Leader (opcional, solo si se especifica RL pero no está marcado)
  const hasRLNotation = /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl|\d*[xX]\s*rl)\b/i.test(trimmedNote);
  if (hasRLNotation && !result.isRaidLeader) {
    // Verificar si el formato es válido pero no se pudo marcar
    orderedMissingFields.push('RaidLeader (RL) - Verificar formato (ej: RL, rl, RaidLeader, 18xrl)');
  }

  // Agregar cualquier otro campo faltante que no esté en la lista ordenada
  const otherMissingFields = missingFields.filter(
    (field) => !orderedMissingFields.some((omf) => field.includes(omf.split(' ')[0]))
  );

  // Combinar los campos ordenados con los demás campos faltantes
  const allMissingFields = [...orderedMissingFields, ...otherMissingFields];
  const missingFieldsSet = new Set(allMissingFields);

  // Actualizar el array de missingFields
  result.missingFields = Array.from(missingFieldsSet);

  // 7. Determinar si la nota es válida
  // La nota es válida si tiene al menos un campo válido
  result.isValid = true;

  // Mostrar resumen de lo encontrado
  console.log(`\n=== RESUMEN FINAL PARA ${characterName.toUpperCase()} ===`);
  console.log(`[${characterName}] Raids detectadas:`, result.raids);
  console.log(`[${characterName}] Dificultades detectadas:`, Array.from(foundDifficulties));
  console.log(`[${characterName}] Campos faltantes:`, missingFields);
  console.log(`[${characterName}] Es válido:`, result.isValid);
  console.log('='.repeat(50) + '\n');

  // Si no hay ningún campo válido, marcar como inválido
  const hasAnyValidField =
    result.role ||
    result.mainAlt ||
    result.gearScore ||
    (result.professions && result.professions.length > 0) ||
    (result.schedules && result.schedules.length > 0) ||
    (result.raids && result.raids.length > 0);

  if (!hasAnyValidField) {
    result.isValid = false;
    errors.push('Formato inválido - No se detectaron campos válidos');
  }

  // Verificar si es un formato simple (MT, MTH, etc.)
  const isSimpleFormat = /^[MA]?[THD]+$/i.test(trimmedNote) || /^[MA]$/i.test(trimmedNote);

  // Si es un formato simple o tiene los campos requeridos, es válido
  const finalIsValid = isSimpleFormat || (errors.length === 0 && hasAnyValidField);

  if (!finalIsValid) {
    return {
      ...result,
      isValid: false,
      error: [
        ...(missingFields.length > 0 ? [`Falta: ${missingFields.join(', ')}`] : []),
        ...errors,
      ].join('\n'),
      missingFields,
    };
  }

  return {
    ...result,
    isValid: true,
    mainAlt: result.mainAlt as MainAlt,
    role: result.role as Role,
    dualRole: result.dualRole as Role | undefined,
    gearScore: result.gearScore,
    professions: result.professions,
    schedules: result.schedules,
    raids: result.raids || [],
  };
}

// Mapeo de nombres de profesiones para mostrar
const professionNames = {
  JC: 'Joyería',
  BS: 'Herrería',
  EN: 'Encantamiento',
  EG: 'Ingeniería',
  TL: 'Peletería',
  AL: 'Alquimia',
  IN: 'Inscripción',
  HB: 'Herrería Sagrada',
  MN: 'Minería',
  SK: 'Desuello',
} as const;

// Mapeo de profesiones a nombres completos y colores
const professionInfo: Record<ProfessionCode, { name: string; color: string; bgColor: string }> = {
  JC: { name: 'Joyería', color: 'text-yellow-300', bgColor: 'bg-yellow-500/20' },
  BS: { name: 'Herrería', color: 'text-gray-300', bgColor: 'bg-gray-500/20' },
  EN: { name: 'Encantamiento', color: 'text-purple-300', bgColor: 'bg-purple-500/20' },
  EG: { name: 'Ingeniería', color: 'text-blue-200', bgColor: 'bg-blue-500/20' },
  AL: { name: 'Alquimia', color: 'text-green-200', bgColor: 'bg-green-500/20' },
  TL: { name: 'Peletería', color: 'text-pink-300', bgColor: 'bg-pink-500/20' },
  IN: { name: 'Inscripción', color: 'text-indigo-300', bgColor: 'bg-indigo-500/20' },
  HB: { name: 'Herrería Sagrada', color: 'text-lime-300', bgColor: 'bg-lime-500/20' },
  MN: { name: 'Minería', color: 'text-gray-400', bgColor: 'bg-gray-600/20' },
  SK: { name: 'Desuello', color: 'text-orange-300', bgColor: 'bg-orange-500/20' },
} as const;

const totalMembers = rosterMembers.length;

// Calcular estadísticas de roles individuales y combinaciones de roles duales
const roleStats = rosterMembers.reduce(
  (acc, member) => {
    const validation = member.noteValidation;
    if (validation?.isValid) {
      // Contar rol principal
      if (validation.role) {
        acc[validation.role] = (acc[validation.role] || 0) + 1;
      }
      // Contar rol secundario si existe
      if (validation.dualRole) {
        acc[validation.dualRole] = (acc[validation.dualRole] || 0) + 1;
      }
    }
    return acc;
  },
  {} as Record<Role, number>
);

// Usar roleDistribution para obtener los conteos de roles duales
const dualRoleStats = [
  {
    combo: 'TH',
    label: 'Tank / Heal',
    count: roleDistribution.find(r => r.role === 'TH')?.count || 0,
    color: 'bg-blue-400/20',
    textColor: 'text-blue-400'
  },
  {
    combo: 'TD',
    label: 'Tank / DPS',
    count: roleDistribution.find(r => r.role === 'TD')?.count || 0,
    color: 'bg-purple-400/20',
    textColor: 'text-purple-400'
  },
  {
    combo: 'HD',
    label: 'Heal / DPS',
    count: roleDistribution.find(r => r.role === 'HD')?.count || 0,
    color: 'bg-green-400/20',
    textColor: 'text-green-400'
  }
];

// Ordenar por cantidad (de mayor a menor)
const sortedDualRoles = [...dualRoleStats].sort((a, b) => b.count - a.count);

// Calcular estadísticas de mains/alts
const mainAltStats = rosterMembers.reduce(
  (acc, member) => {
    const validation = member.noteValidation;
    if (validation?.isValid && validation.mainAlt) {
      acc[validation.mainAlt] = (acc[validation.mainAlt] || 0) + 1;
    } else {
      // Si no está especificado, asumir que es main
      acc['M'] = (acc['M'] || 0) + 1;
    }
    return acc;
  },
  {} as Record<MainAlt, number>
);

// Usamos gearScoreStats ya definido anteriormente

// Contar líderes de raid
const raidLeaderCount = rosterData.members.filter(
  (member) => member.noteValidation?.isRaidLeader
).length;

// Obtener lista de rangos únicos
const ranks = [...new Set(rosterData.members.map((member) => member.rank))].sort();

// Obtener lista de clases únicas
const rosterClassInfo = rosterData?.classInfo || {};
const classList = Object.keys(rosterClassInfo) as ClassName[];

// Datos para el cliente
const rosterClientData: RosterData = {
  members: rosterMembers,
  classInfo: rosterData.classInfo,
  ranks: ranks,
  classes: classList,
  totalMembers: rosterMembers.length,
  rankInfo: {},
};

// Definir tipos para las distribuciones
interface DistributionItem {
  name: string;
  count: number;
  percentage?: number;
  color?: string;
}

interface RoleDistributionItem extends DistributionItem {
  role: string;
}

type MainAltType = 'M' | 'A';
interface MainAltDistribution {
  M: number;
  A: number;
}

interface ClassDistributionItem extends DistributionItem {
  color: string;
}

interface MainAltDistributionItem extends DistributionItem {
  type: 'M' | 'A';
}

// Función para calcular la distribución por rango
function calculateRankDistribution(
  members: any[] = []
): Array<{ name: string; count: number; percentage: number }> {
  if (!members || !Array.isArray(members)) {
    return [];
  }
  const totalMembers = members.length;
  if (totalMembers === 0) return [];
  const rankCounts = members.reduce((acc: Record<string, number>, member) => {
    acc[member.rank] = (acc[member.rank] || 0) + 1;
    return acc;
  }, {});

  // Definir tipos de rangos válidos
  type RankType = 'Oficial' | 'Veterano' | 'Miembro' | 'Iniciado' | 'Recluta';

  // Calcular porcentajes y redondear a 1 decimal
  return Object.entries(rankCounts).map(([name, count]) => {
    const rankName = name as RankType;
    return {
      name: rankName,
      count: count as number,
      percentage:
        totalMembers > 0
          ? Math.round(((count as number) / totalMembers) * 100 * 10) / 10 // Redondear a 1 decimal
          : 0,
    };
  });
}

// Función para calcular la distribución por clase
function calculateClassDistribution(
  members: any[] = [],
  classInfo: any = {}
): ClassDistributionItem[] {
  if (!Array.isArray(members) || !classInfo) {
    return [];
  }

  const classCounts = members.reduce((acc: Record<string, number>, member) => {
    if (member && member.class) {
      acc[member.class] = (acc[member.class] || 0) + 1;
    }
    return acc;
  }, {});

  return Object.entries(classCounts)
    .filter(([className]) => className && classInfo[className])
    .map(([className, count]) => ({
      name: className,
      count: count as number,
      color: classInfo[className].color || 'FFFFFF',
    }));
}

// Calcular distribuciones
// RosterData interface is already defined above

const rankDistribution = calculateRankDistribution(rosterData.members);
const classDistribution = calculateClassDistribution(rosterData.members, rosterData.classInfo);

// Calcular estadísticas del formato de notas
const stats = rosterData.members.reduce(
  (
    acc: {
      roles: Record<string, number>;
      mainAlt: Record<string, number>;
      professions: Record<string, number>;
      gearScores: number[];
      totalGearScore: number;
      minGearScore: number;
      maxGearScore: number;
      validNotesCount: number;
    },
    member
  ) => {
    const validation = member.noteValidation;

    if (validation?.isValid) {
      // Contar roles (incluyendo duales)
      if (validation.role) {
        acc.roles[validation.role] = (acc.roles[validation.role] || 0) + 1;

        // Si tiene rol dual, contarlo también
        if (validation.dualRole) {
          acc.roles[validation.dualRole] = (acc.roles[validation.dualRole] || 0) + 1;
        }
      }

      // Contar main/alt
      if (validation.mainAlt) {
        acc.mainAlt[validation.mainAlt] = (acc.mainAlt[validation.mainAlt] || 0) + 1;
      }

      // Acumular gear score
      if (validation.gearScore) {
        const gs = parseFloat(validation.gearScore);
        if (!isNaN(gs)) {
          acc.gearScores.push(gs);
          acc.totalGearScore += gs;
          if (gs < acc.minGearScore) acc.minGearScore = gs;
          if (gs > acc.maxGearScore) acc.maxGearScore = gs;
        }
      }

      // Contar profesiones
      if (validation.professions && Array.isArray(validation.professions)) {

        
        // Crear un mapa inverso de nombre a código de profesión
        const nameToCode = Object.entries(PROFESSIONS).reduce((acc, [code, name]) => {
          acc[name.toLowerCase()] = code;
          return acc;
        }, {} as Record<string, string>);
        
        validation.professions.forEach((prof: any) => {
          const profName = String(prof).trim();

          
          // Buscar el código de la profesión por nombre o usar el valor directamente
          const code = nameToCode[profName.toLowerCase()] || profName;
          const codeUpper = code.toUpperCase();
          
          // Verificar si el código de profesión es válido
          if (codeUpper in PROFESSIONS) {

            acc.professions[codeUpper] = (acc.professions[codeUpper] || 0) + 1;
          } else {

          }
        });
        

      }

      acc.validNotesCount++;
    }

    return acc;
  },
  {
    roles: { T: 0, H: 0, D: 0 },
    mainAlt: { M: 0, A: 0 },
    professions: Object.keys(PROFESSIONS).reduce((acc, prof) => {
      acc[prof] = 0;
      return acc;
    }, {} as Record<string, number>),
    gearScores: [],
    totalGearScore: 0,
    minGearScore: Infinity,
    maxGearScore: 0,
    validNotesCount: 0,
  }
);

// Calcular porcentajes para las distribuciones
const totalValid = stats.validNotesCount || 1; // Evitar división por cero



const mainAltDistribution: MainAltDistributionItem[] = Object.entries(stats.mainAlt)
  .filter(([_, count]) => count > 0)
  .map(([type, count]) => ({
    type: type as 'M' | 'A',
    name: type === 'M' ? 'Main' : 'Alt',
    count: count as number,
    percentage: Math.round(((count as number) / totalValid) * 100),
  }));

// Calcular estadísticas de gear score
const averageGearScore =
  stats.validNotesCount > 0 ? (stats.totalGearScore / stats.validNotesCount).toFixed(1) : 'N/A';

const minGearScore = stats.minGearScore !== Infinity ? stats.minGearScore.toFixed(1) : 'N/A';
const maxGearScore = stats.maxGearScore > 0 ? stats.maxGearScore.toFixed(1) : 'N/A';
const gearScorePercentage =
  stats.validNotesCount > 0
    ? Math.min(100, Math.max(0, (parseFloat(averageGearScore) / 6.8) * 100))
    : 0;

const validNotesCount = stats.validNotesCount;

// Procesar datos de miembros
const sortedMembers = [...rosterData.members].sort((a, b) => a.name.localeCompare(b.name));
const filteredMembers = [...sortedMembers];
const totalRaiders = rosterData.members.filter(
  (m) =>
    m.rank.toLowerCase().includes('élite') ||
    m.rank.toLowerCase().includes('oficial') ||
    m.rank.toLowerCase().includes('comandante')
).length;
---

<div class="space-y-6">
  <style>
    /* Estilos para los tooltips */
    .tooltip-container {
      position: relative;
      display: inline-block;
    }

    .tooltip-container:hover .tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .tooltip {
      transform: translateY(-5px);
      transition: all 0.2s ease-in-out;
      box-shadow:
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Estilos para los dropdowns */
    select option {
      background-color: #1a202c; /* Fondo oscuro */
      color: #e2e8f0; /* Texto claro */
      padding: 0.5rem;
    }

    select:focus option:checked {
      background-color: #4a5568; /* Color de fondo para la opción seleccionada */
      color: white;
    }

    /* Estilo para el hover en las opciones */
    select option:hover {
      background-color: #4a5568 !important;
    }
  </style>
  <!-- Script del cliente con la lógica de JavaScript -->
  <script
    define:vars={{
      rosterData: JSON.stringify(rosterClientData),
      roleNames: JSON.stringify(roleNames),
      professionNames: JSON.stringify(professionNames),
    }}
  >
    // Analizar los datos del roster
    const rosterInfo = JSON.parse(rosterData);
    const roleNamesData = JSON.parse(roleNames);
    const professionNamesData = JSON.parse(professionNames);

    // Función para inicializar tooltips
    function initTooltips() {
      document.querySelectorAll('.tooltip-container').forEach((container) => {
        const tooltip = container.querySelector('.tooltip');
        if (!tooltip) return;

        // Posicionamiento del tooltip
        const updatePosition = () => {
          const rect = container.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();

          // Centrar horizontalmente
          const left = rect.left + rect.width / 2 - tooltipRect.width / 2;

          // Ajustar para que no se salga de la pantalla
          const adjustedLeft = Math.max(
            10,
            Math.min(window.innerWidth - tooltipRect.width - 10, left)
          );

          tooltip.style.left = `${adjustedLeft}px`;
        };

        // Actualizar posición al mostrar
        container.addEventListener('mouseenter', updatePosition);

        // Actualizar posición al redimensionar
        window.addEventListener('resize', updatePosition);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Inicializar tooltips después de cargar la tabla
      initTooltips();
      // Obtener elementos del DOM
      const searchInput = document.getElementById('search');
      const classFilter = document.getElementById('class-filter');
      const rankFilter = document.getElementById('rank-filter');
      const tableBody = document.getElementById('roster-table-body');
      const prevButton = document.getElementById('prev-button');
      const nextButton = document.getElementById('next-button');
      const pageInfo = document.getElementById('page-info');

      let currentPage = 1;
      const itemsPerPage = 6;
      let allMembers = [];
      let filteredMembers = [];
      let sortConfig = { key: 'name', direction: 'asc' };

      // Inicializar la tabla con los datos
      function initTable() {
        if (!tableBody || !pageInfo) {

          return;
        }

        allMembers = [...rosterInfo.members];
        filteredMembers = [...allMembers];

        // Llenar filtros
        if (classFilter && rankFilter) {
          // No necesitamos llenar los dropdowns aquí ya que se generan en el template
        }

        updateTable();
        updatePaginationInfo();
      }

      // Actualizar la tabla con los miembros filtrados y ordenados
      function updateTable() {
        if (!tableBody) return;

        const startIndex = (currentPage - 1) * itemsPerPage;
        const paginatedMembers = filteredMembers.slice(startIndex, startIndex + itemsPerPage);

        tableBody.innerHTML = paginatedMembers
          .map((member) => {
            const classData = rosterInfo.classInfo[member.class] || {
              color: 'FFFFFF',
              name: member.class,
            };
            const className = classData.name;
            const classColor = classData.color;

            return `
            <tr class="hover:bg-steel-dark transition-colors duration-200 hover:border-accent">
              <td class="px-2 md:px-6 py-4 whitespace-nowrap text-center">
                <div class="flex items-center sm:flex-row flex-col">
                  <img src="/images/avatars/class_${className}.jpg" alt="${className}" class="w-8 h-8 rounded-full sm:mr-3 border border-accent/30" onerror="this.src='/images/avatars/default.png'"/>
                  <div class="flex-grow">
                    <div class="text-xs" style="color: #${classColor}">${className}</div>
                    <div class="font-medium text-text-primary">${member.name}</div>
                    <div class="mt-1">
                      <span class="px-2 py-0.5 text-xs font-medium rounded-full ${member.rank === 'Guild Master' ? 'bg-yellow-500/20 text-yellow-300' : member.rank === 'Oficial' ? 'bg-purple-500/20 text-purple-300' : 'bg-gray-500/20 text-gray-300'}">
                        ${member.rank}
                      </span>
                    </div>
                    <!-- Nota real (media prioridad) -->
                    <div class="w-full text-text-muted/60 text-xs mt-1.5 font-normal break-words whitespace-normal">${member.publicNote}</div>
                  </div>
                </div>
              </td>
              <td class="px-2 md:px-6 py-4 relative overflow-visible">
                <div class="relative">
                  <div class="flex items-start gap-2">
                    <div class="relative inline-flex items-center">
                      ${
                        member.publicNote
                          ? `
                        <div class="space-y-1">
                          ${(() => {
                            const validation = member.noteValidation;
                            if (validation?.isValid) {
                              // Formatear la información validada
                              const formattedInfo = [];

                              // 1. Main/Alt
                              if (validation.mainAlt) {
                                formattedInfo.push({
                                  label: validation.mainAlt === 'M' ? 'Main' : 'Alt',
                                  class:
                                    validation.mainAlt === 'M'
                                      ? 'text-blue-300 font-medium'
                                      : 'text-purple-300 font-medium',
                                });
                              }

                              // 2. Rol principal
                              if (validation.role) {
                                const roleName =
                                  roleNamesData[validation.role]?.name || validation.role;
                                formattedInfo.push({
                                  label: roleName,
                                  class:
                                    validation.role === 'T'
                                      ? 'text-blue-300 font-medium'
                                      : validation.role === 'H'
                                        ? 'text-green-300 font-medium'
                                        : 'text-red-300 font-medium',
                                });
                              }

                              // 3. Gear Score
                              if (validation.gearScore) {
                                formattedInfo.push({
                                  label: `GS ${validation.gearScore}`,
                                  class: 'text-amber-300 font-medium',
                                });
                              }

                              // 4. Rol secundario (dual role)
                              if (validation.dualRole) {
                                const dualRoleName =
                                  roleNamesData[validation.dualRole]?.name || validation.dualRole;
                                formattedInfo.push({
                                  label: `Dual ${dualRoleName}`,
                                  class: 'text-yellow-300 font-medium',
                                });
                              }

                              // 4. Profesiones
                              if (validation.professions?.length) {
                                formattedInfo.push({
                                  label: validation.professions.join(' / '),
                                  class: 'text-indigo-300 font-medium',
                                });
                              }

                              // 5. Horarios
                              if (validation.schedules?.length) {
                                // Convertir X a h para visualización
                                const formattedSchedules = validation.schedules.map((time) =>
                                  time.replace(/X$/g, 'h').replace(/(\d{2}):(\d{2})X/g, '$1:$2h')
                                );
                                formattedInfo.push({
                                  label: `Online a las: ${formattedSchedules.join(' o ')}`,
                                  class: 'text-emerald-300 font-medium',
                                });
                              }

                              // 6. Raids y dificultades
                              if (validation.raids?.length) {
                                // Separar las raids de sus dificultades
                                const raidNames = [];
                                const raidDifficulties = [];

                                validation.raids.forEach((raid) => {
                                  if (raid.difficultyCode) {
                                    // Usar difficultyCode (ej: 10N, 25H) en lugar de difficulty (Normal, Heroic)
                                    if (!raidDifficulties.includes(raid.difficultyCode)) {
                                      raidDifficulties.push(raid.difficultyCode);
                                    }
                                  } else if (
                                    raid.difficulty &&
                                    raid.difficulty !== 'Sin especificar'
                                  ) {
                                    // Si no hay difficultyCode pero sí difficulty, usamos este como respaldo
                                    if (!raidDifficulties.includes(raid.difficulty)) {
                                      raidDifficulties.push(raid.difficulty);
                                    }
                                  }
                                  if (!raidNames.includes(raid.name)) {
                                    raidNames.push(raid.name);
                                  }
                                });

                                // Mostrar nombres de raids
                                if (raidNames.length > 0) {
                                  const isRaidLeader = validation.isRaidLeader;
                                  formattedInfo.push({
                                    label: `${isRaidLeader ? 'Armo' : 'Busco'}: ${raidNames.join(' o ')}`,
                                    class: isRaidLeader
                                      ? 'text-purple-300 font-medium border-b border-purple-500/60 pb-0.5'
                                      : 'text-purple-300 font-medium',
                                  });

                                  // Si es raid leader, añadir etiqueta especial
                                  if (isRaidLeader) {
                                    formattedInfo.unshift({
                                      label: 'Raid Leader',
                                      class:
                                        'text-yellow-300 font-bold border-b border-yellow-500/60 pb-0.5',
                                    });
                                  }
                                }

                                // Mostrar dificultades si hay alguna definida o si hay raids sin dificultad
                                const validDifficulties = raidDifficulties.filter(
                                  (d) => d && d.trim() !== ''
                                );
                                
                                // Si hay dificultades válidas, mostrarlas
                                if (validDifficulties.length > 0) {
                                  formattedInfo.push({
                                    label: `Dificultad: ${validDifficulties.join(' o ')}`,
                                    class: 'text-indigo-300 font-medium',
                                  });
                                } 
                                // Si no hay dificultades pero sí raids, buscar dificultades en la nota
                                else if (validation.raids?.length > 0) {
                                  // Buscar dificultades directamente en la nota
                                  const noteDifficulties = [];
                                  const difficultyMatch = member.publicNote.match(/\b(10N|25N|10H|25H|H)\b/gi);
                                  
                                  if (difficultyMatch) {
                                    const uniqueDifficulties = [...new Set(difficultyMatch.map(d => d.toUpperCase()))];
                                    if (uniqueDifficulties.length > 0) {
                                      formattedInfo.push({
                                        label: `Dificultad: ${uniqueDifficulties.join(' o ')}`,
                                        class: 'text-indigo-300 font-medium',
                                      });
                                    }
                                  }
                                }
                              }

                              // Verificar si hay campos faltantes incluso si la nota es válida
                              const missingFields = validation.missingFields || [];

                              // Renderizar las etiquetas formateadas
                              return `
                                <div class="space-y-1.5">
                                  <!-- Nota generada (alta prioridad) -->
                                  <div class="flex flex-wrap gap-1.5">
                                    ${formattedInfo
                                      .map(
                                        (info) =>
                                          `<span class="text-sm font-medium ${info.class}">
                                            ${info.label}
                                          </span>`
                                      )
                                      .join('')}
                                  </div>
                                  
                                  <!-- Advertencias (baja prioridad) -->
                                  ${
                                    missingFields.length > 0
                                      ? `
                                    <div class="flex items-start gap-1 text-yellow-500/70 text-[11px] mt-0.5">
                                      <svg class="w-2.5 h-2.5 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                                      </svg>
                                      <span>Faltan: ${missingFields.join(', ')}</span>
                                    </div>
                                  `
                                      : ''
                                  }
                                </div>
                              `;
                            } else {
                              const missingFields = validation.missingFields || [];
                              const errorMessage =
                                missingFields.length > 0
                                  ? `Faltan: ${missingFields.join(', ')}`
                                  : 'Formato inválido';

                              return `
                                <div class="space-y-1.5">
                                  <!-- Mensaje de error (alta prioridad) -->
                                  <div class="flex flex-wrap gap-1">
                                    <span class="text-sm font-medium text-red-300">
                                      Formato inválido
                                    </span>
                                  </div>
                                  
                                  <!-- Advertencias (baja prioridad) -->
                                  ${
                                    missingFields.length > 0
                                      ? `
                                    <div class="flex items-start gap-1 text-yellow-500/70 text-[11px] mt-0.5">
                                      <svg class="w-2.5 h-2.5 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                                      </svg>
                                      <span>Faltan: ${missingFields.join(', ')}</span>
                                    </div>
                                  `
                                      : ''
                                  }
                              `;
                            }
                          })()}
                        </div> 
                      `
                          : `
                        <div class="flex items-center gap-2">
                          <span class="text-text-muted/70 italic">Sin nota</span>
                          <div class="flex items-center justify-center w-5 h-5 rounded-full bg-gray-900/20 border border-gray-500/30">
                            <div class="w-2 h-2 rounded-full bg-gray-500"></div>
                          </div>
                        </div>
                      `
                      }
                    </div>
                    
                  </div>
                </div>
              </td>
            </tr>
          `;
          })
          .join('');

        updatePaginationInfo();
        updateSortIndicators();
      }

      // Función para ordenar los miembros
      function sortMembers(key) {
        if (sortConfig.key === key) {
          sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
        } else {
          sortConfig.key = key;
          sortConfig.direction = 'asc';
        }

        filteredMembers.sort((a, b) => {
          let aValue = a[key] || '';
          let bValue = b[key] || '';

          // Manejar valores nulos o indefinidos
          if (aValue === null || aValue === undefined) aValue = '';
          if (bValue === null || bValue === undefined) bValue = '';

          // Convertir a string para comparación segura
          aValue = String(aValue).toLowerCase();
          bValue = String(bValue).toLowerCase();

          if (aValue < bValue) {
            return sortConfig.direction === 'asc' ? -1 : 1;
          }
          if (aValue > bValue) {
            return sortConfig.direction === 'asc' ? 1 : -1;
          }
          return 0;
        });

        currentPage = 1; // Volver a la primera página al cambiar el orden
        updateTable();

        filteredMembers.sort((a, b) => {
          const aValue = a[sortConfig.key]?.toString().toLowerCase() || '';
          const bValue = b[sortConfig.key]?.toString().toLowerCase() || '';

          if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
          if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
          return 0;
        });

        currentPage = 1;
        updateTable();
      }

      // Función para actualizar la información de paginación
      function updatePaginationInfo() {
        if (!pageInfo) return;
        const totalPages = Math.ceil(filteredMembers.length / itemsPerPage);

        // Actualizar el contador de página
        pageInfo.textContent = `Página ${currentPage} de ${totalPages} (${filteredMembers.length} miembros)`;

        // Actualizar estado de los botones de paginación
        if (prevButton) {
          prevButton.disabled = currentPage <= 1;
        }
        if (nextButton) {
          nextButton.disabled = currentPage >= totalPages;
        }

        // Actualizar los botones de página
        updatePageButtons(totalPages);
      }

      // Función para actualizar los botones de página
      function updatePageButtons(totalPages) {
        const paginationContainer = document.getElementById('pagination-buttons');
        if (!paginationContainer) return;

        let buttons = [];
        const maxVisiblePages = 5; // Número máximo de páginas visibles
        let startPage, endPage;

        if (totalPages <= maxVisiblePages) {
          // Mostrar todas las páginas
          startPage = 1;
          endPage = totalPages;
        } else {
          // Calcular qué páginas mostrar
          if (currentPage <= Math.ceil(maxVisiblePages / 2)) {
            // Estamos cerca del inicio
            startPage = 1;
            endPage = maxVisiblePages - 2; // Dejamos espacio para "..." y la última página
          } else if (currentPage + Math.floor(maxVisiblePages / 2) >= totalPages) {
            // Estamos cerca del final
            startPage = totalPages - maxVisiblePages + 3; // Dejamos espacio para la primera página y "..."
            endPage = totalPages;
          } else {
            // Estamos en el medio
            startPage = currentPage - Math.floor((maxVisiblePages - 2) / 2);
            endPage = currentPage + Math.floor((maxVisiblePages - 2) / 2);
          }

          // Asegurarnos de no salirnos de los límites
          if (startPage < 1) startPage = 1;
          if (endPage > totalPages) endPage = totalPages;
        }

        // Botón Anterior
        buttons.push(`
          <button 
            id="prev-button"
            class="px-3 py-1 rounded-md ${currentPage <= 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-steel-dark'} transition-colors"
            ${currentPage <= 1 ? 'disabled' : ''}
          >
            &lt;
          </button>
        `);

        // Primera página
        if (startPage > 1) {
          buttons.push(`
            <button 
              class="px-3 py-1 rounded-md ${currentPage === 1 ? 'bg-accent/20 text-accent font-medium' : 'hover:bg-steel-dark'} transition-colors page-button"
              data-page="1"
            >
              1
            </button>
          `);

          if (startPage > 2) {
            buttons.push('<span class="px-2">...</span>');
          }
        }

        // Páginas intermedias
        for (let i = startPage; i <= endPage; i++) {
          buttons.push(`
            <button 
              class="px-3 py-1 rounded-md ${currentPage === i ? 'bg-accent/20 text-accent font-medium' : 'hover:bg-steel-dark'} transition-colors page-button"
              data-page="${i}"
            >
              ${i}
            </button>
          `);
        }

        // Última página
        if (endPage < totalPages) {
          if (endPage < totalPages - 1) {
            buttons.push('<span class="px-2">...</span>');
          }

          buttons.push(`
            <button 
              class="px-3 py-1 rounded-md ${currentPage === totalPages ? 'bg-accent/20 text-accent font-medium' : 'hover:bg-steel-dark'} transition-colors page-button"
              data-page="${totalPages}"
            >
              ${totalPages}
            </button>
          `);
        }

        // Botón Siguiente
        buttons.push(`
          <button 
            id="next-button"
            class="px-3 py-1 rounded-md ${currentPage >= totalPages ? 'opacity-50 cursor-not-allowed' : 'hover:bg-steel-dark'} transition-colors"
            ${currentPage >= totalPages ? 'disabled' : ''}
          >
            &gt;
          </button>
        `);

        paginationContainer.innerHTML = buttons.join('');

        // Agregar event listeners a los botones de página
        document.querySelectorAll('.page-button').forEach((button) => {
          button.addEventListener('click', (e) => {
            const page = parseInt(e.target.getAttribute('data-page'));
            if (page && !isNaN(page)) {
              currentPage = page;
              updateTable();
            }
          });
        });

        // Actualizar botones anterior/siguiente
        const prevBtn = document.getElementById('prev-button');
        const nextBtn = document.getElementById('next-button');

        if (prevBtn) {
          prevBtn.addEventListener('click', () => {
            if (currentPage > 1) {
              currentPage--;
              updateTable();
            }
          });
        }

        if (nextBtn) {
          nextBtn.addEventListener('click', () => {
            if (currentPage < totalPages) {
              currentPage++;
              updateTable();
            }
          });
        }
      }

      // Función para actualizar los indicadores de ordenación
      function updateSortIndicators() {
        document.querySelectorAll('th[data-sort]').forEach((th) => {
          const sortKey = th.getAttribute('data-sort');
          if (!sortKey) return;

          const indicator = th.querySelector('.sort-indicator');
          if (!indicator) return;

          if (sortConfig.key === sortKey) {
            indicator.textContent = sortConfig.direction === 'asc' ? '↑' : '↓';
          } else {
            indicator.textContent = '↕';
          }
        });
      }

      // Función para filtrar miembros según los filtros aplicados
      function filterMembers() {
        if (!searchInput || !classFilter || !rankFilter) return;

        const searchTerm = searchInput.value.toLowerCase();
        const selectedClass = classFilter.value;
        const selectedRank = rankFilter.value;

        filteredMembers = allMembers.filter((member) => {
          const matchesSearch =
            searchTerm === '' ||
            member.name.toLowerCase().includes(searchTerm) ||
            (member.publicNote && member.publicNote.toLowerCase().includes(searchTerm));
          const matchesClass = selectedClass === '' || member.class === selectedClass;
          const matchesRank = selectedRank === '' || member.rank === selectedRank;

          return matchesSearch && matchesClass && matchesRank;
        });

        currentPage = 1;
        updateTable();
      }

      // Event listeners
      if (searchInput) {
        searchInput.addEventListener('input', filterMembers);
      }

      if (classFilter) {
        classFilter.addEventListener('change', filterMembers);
      }

      if (rankFilter) {
        rankFilter.addEventListener('change', filterMembers);
      }

      if (prevButton) {
        prevButton.addEventListener('click', () => {
          if (currentPage > 1) {
            currentPage--;
            updateTable();
          }
        });
      }

      if (nextButton) {
        nextButton.addEventListener('click', () => {
          const totalPages = Math.ceil(filteredMembers.length / itemsPerPage);
          if (currentPage < totalPages) {
            currentPage++;
            updateTable();
          }
        });
      }

      // Inicializar encabezados ordenables
      document.querySelectorAll('th[data-sort]').forEach((th) => {
        th.addEventListener('click', () => {
          const sortKey = th.getAttribute('data-sort');
          if (sortKey) {
            sortMembers(sortKey);
          }
        });
      });

      // Inicializar la tabla
      initTable();

      // Inicializar tooltips después de actualizar la tabla
      initTooltips();

      // Función para actualizar la tabla después de cambios
      const originalUpdateTable = updateTable;
      updateTable = function () {
        originalUpdateTable.apply(this, arguments);
      };
    });
  </script>

  <!-- Estadísticas del Roster -->
  <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6 mt-2">
  <!-- Total de Miembros y Mains/Alts -->
  <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
    <div class="flex justify-between items-center">
      <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">Miembros Totales</h3>
      <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">{totalMembers}</p>
    </div>
    <div class="grid grid-cols-2 justify-items-center">
      <div class="text-center">
        <p class="text-[18px] sm:text-2xl font-bold text-white">{mainAltStats.M || 0}</p>
        <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Mains</p>
      </div>
      <div class="text-center">
        <p class="text-[18px] sm:text-2xl font-bold text-white">{mainAltStats.A || 0}</p>
        <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Alts</p>
      </div>
    </div>
  </div>

  <!-- Distribución de Roles -->
  <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
    <div class="flex justify-between items-center">
      <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">Roles Principales</h3>
      <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">{Object.values(roleStats).reduce((a, b) => a + b, 0) || 0}</p>
    </div>
    <div class="grid grid-cols-3 gap-1 mt-1">
      <div class="text-center">
        <p class="text-[18px] sm:text-2xl font-bold text-white">{roleStats.T || 0}</p>
        <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Tanks</p>
      </div>
      <div class="text-center">
        <p class="text-[18px] sm:text-2xl font-bold text-white">{roleStats.H || 0}</p>
        <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Healers</p>
      </div>
      <div class="text-center">
        <p class="text-[18px] sm:text-2xl font-bold text-white">{roleStats.D || 0}</p>
        <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">DPS</p>
      </div>
    </div>
  </div>

  <!-- Combinaciones de Roles Duales -->
  <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
    <div class="flex justify-between items-center">
      <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">Roles Duales</h3>
      <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">
        {sortedDualRoles.reduce((sum, { count }) => sum + count, 0) || 0}
      </p>
    </div>
    <div class="grid grid-cols-3 gap-1 mt-1">
      {sortedDualRoles.map(({ combo, label, count, textColor }) => (
        <div class="text-center">
          <p class="text-[18px] sm:text-2xl font-bold text-white">{count}</p>
          <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">{label}</p>
        </div>
      ))}
    </div>
  </div>

  <!-- Gear Score Promedio -->
  <div class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
    <div class="flex justify-between items-center">
      <h3 class="text-text-muted/90 text-[10px] sm:text-base font-bold text-amber-300">Gear Score</h3>
      <p class="text-[22px] sm:text-2xl font-bold text-amber-200/80">
        {gearScoreStats.avg > 0 ? gearScoreStats.avg.toFixed(1) : 'N/A'}
      </p>
    </div>
    <div class="grid grid-cols-2 gap-1 mt-1">
      <div class="text-center">
        <p class="text-[18px] sm:text-2xl font-bold text-white">
          {gearScoreStats.max > 0 ? gearScoreStats.max : 'N/A'}
        </p>
        <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Máx</p>
      </div>
      <div class="text-center">
        <p class="text-[18px] sm:text-2xl font-bold text-white">
          {gearScoreStats.min > 0 ? gearScoreStats.min : 'N/A'}
        </p>
        <p class="text-[7px] sm:text-[10px] text-amber-100/90 font-bold">Mín</p>
      </div>
    </div>
  </div>
</div>



  <!-- Tabla de miembros -->
  <div
    class="bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3"
  >
    <div class="overflow-x-auto rounded-t-xl">
      <table class="min-w-full divide-y divide-accent bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 p-2 sm:p-3">
        <thead class="bg-gradient-to-r from-amber-900/50 to-amber-800/30">
          <tr>
            <th data-column="name" class="text-center text-xs font-semibold text-amber-300/90 uppercase tracking-wider cursor-pointer hover:text-amber-200 transition-colors" data-sort="name">
              <div class="flex items-center justify-center">
                <span class="py-2">Personaje</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="ml-1 h-3.5 w-3.5 opacity-70" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                </svg>
              </div>
            </th>
            <th data-column="details" class="text-center text-xs font-semibold text-amber-300/90 uppercase tracking-wider cursor-pointer hover:text-amber-200 transition-colors" data-sort="publicNote">
              <div class="flex items-center justify-center">
                <span class="py-2">Detalles</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="ml-1 h-3.5 w-3.5 opacity-70" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                </svg>
              </div>
            </th>
          </tr>
        </thead>
        <tbody id="roster-table-body" class="divide-y divide-accent bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-2 sm:p-3">
          <!-- Los miembros se cargarán aquí dinámicamente -->
        </tbody>
      </table>
    </div>
    <!-- Controles de paginación -->
    <div
      class="px-2 md:px-6 py-4 bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 flex flex-col sm:flex-row items-center justify-between gap-4"
    >
      <div id="page-info" class="text-text-muted text-sm order-2 sm:order-1">
        Página 1 de 1 (0 miembros)
      </div>

      <div
        id="pagination-buttons"
        class="flex items-center gap-1 bg-steel-darker/50 border border-accent/20 rounded-lg p-1 order-1 sm:order-2"
      >
        <!-- Los botones de página se generarán aquí dinámicamente -->
        <button
          id="prev-button"
          class="px-3 py-1 rounded-md opacity-50 cursor-not-allowed transition-colors"
          disabled
        >
          &lt;
        </button>
        <button class="px-3 py-1 rounded-md bg-accent/20 text-accent font-medium">1</button>
        <button
          id="next-button"
          class="px-3 py-1 rounded-md opacity-50 cursor-not-allowed transition-colors"
          disabled
        >
          &gt;
        </button>
      </div>
    </div>

    
  <!-- Filtros -->
  <div
  class="p-6 bg-gray-900/50 backdrop-blur-sm border border-amber-900/30"
>
  <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
    <div class="relative">
      <label for="search" class="block text-sm font-medium text-text-muted/80 mb-2">
        Buscar por nombre o nota
      </label>
      <input
        type="text"
        id="search"
        placeholder="Nombre o nota..."
        class="w-full bg-transparent border border-accent rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-accent/50 focus:border-transparent placeholder-text-muted/50 transition-all duration-200"
      />
    </div>

    <div class="relative">
      <label for="class-filter" class="block text-sm font-medium text-text-muted/80 mb-2">
        Filtrar por clase
      </label>
      <select
        id="class-filter"
        class="w-full bg-transparent border border-accent rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-accent/50 focus:border-transparent appearance-none transition-all duration-200 cursor-pointer hover:border-accent/40"
      >
        <option value="">Todas las clases</option>
        {
          Object.entries(rosterData.classInfo).map(([key, info]) => (
            <option value={key} style={`color: #${info.color}`}>
              {info.name}
            </option>
          ))
        }
      </select>
    </div>

    <div class="relative">
      <label for="rank-filter" class="block text-sm font-medium text-text-muted/80 mb-2">
        Filtrar por rango
      </label>
      <select
        id="rank-filter"
        class="w-full bg-transparent border border-accent rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-accent/50 focus:border-transparent appearance-none transition-all duration-200 cursor-pointer hover:border-accent/40"
      >
        <option value="">Todos los rangos</option>
        {
          ranks.map((rank) => (
            <option value={rank} class="text-white">
              {rank}
            </option>
          ))
        }
      </select>
    </div>
  </div>
</div>
  </div>

  <!-- Sección de estadísticas -->
  <div class="mt-8 bg-gray-900/50 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6">
    <h2
      class="text-xl font-semibold mb-6 text-center text-amber-200/90 uppercase tracking-wider"
    >
      Estadísticas del Roster
    </h2>
    <div class="grid grid-cols-3 gap-6">
      <!-- Columna 1: Distribución por Rango -->
      <div class="bg-gray-900/70 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6 hover:border-amber-800/50 transition-colors">
        <h3 class="text-amber-300/90 text-lg font-medium mb-4 text-center uppercase tracking-wider">
          Por Rango
        </h3>
          <div class="space-y-3">
            {
              rankDistribution.map(({ name, count, percentage }) => {
                // Asignar colores directamente
                let colorClass = 'from-accent to-accent-light';
                if (name === 'Oficial') colorClass = 'from-blue-400 to-blue-600';
                else if (name === 'Veterano') colorClass = 'from-purple-400 to-purple-600';
                else if (name === 'Miembro') colorClass = 'from-green-400 to-green-600';
                else if (name === 'Iniciado') colorClass = 'from-yellow-400 to-yellow-600';
                else if (name === 'Recluta') colorClass = 'from-gray-400 to-gray-600';

                return (
                  <div class="space-y-1.5">
                    <div class="flex items-center justify-between text-xs">
                      <span class="text-amber-100/80">{name}</span>
                      <div class="flex items-center">
                        <span class="text-white font-semibold mr-1">{count}</span>
                        <span class="text-amber-100/60 text-[11px]">({percentage}%)</span>
                      </div>
                    </div>
                    <div class="w-full bg-amber-900/30 rounded-full h-1.5 overflow-hidden">
                      <div
                        class="h-full rounded-full bg-gradient-to-r transition-all duration-500 ease-out"
                        class:list={[colorClass]}
                        style={{ width: `${percentage}%` }}
                      />
                    </div>
                  </div>
                );
              })
            }
          </div>
        </div>

      <!-- Columna 2: Distribución por Clase -->
      <div class="bg-gray-900/70 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6 hover:border-amber-800/50 transition-colors">
        <h3 class="text-amber-300/90 text-lg font-medium mb-4 text-center uppercase tracking-wider">
          Por Clase
        </h3>
          <div class="space-y-3">
            {
              classDistribution.map(({ name, count, color: classColor }) => {
                const percentage = Math.round((count / rosterData.members.length) * 100);
                return (
                  <div class="space-y-1.5">
                    <div class="flex items-center justify-between text-xs">
                      <div class="flex items-center">
                        <span
                          class="w-2.5 h-2.5 rounded-full mr-2 border border-amber-900/30"
                          style={`background-color: #${classColor}`}
                        />
                        <span class="text-amber-100/80">{name}</span>
                      </div>
                      <div class="flex items-center">
                        <span class="text-white font-semibold mr-1">{count}</span>
                        <span class="text-amber-100/60 text-[11px]">({percentage}%)</span>
                      </div>
                    </div>
                    <div class="w-full bg-amber-900/30 rounded-full h-1.5 overflow-hidden">
                      <div
                        class="h-full rounded-full transition-all duration-500 ease-out"
                        style={{
                          width: `${percentage}%`,
                          background: `linear-gradient(to right, #${classColor}cc, #${classColor}ff)`,
                        }}
                      />
                    </div>
                  </div>
                );
              })
            }
          </div>
        </div>

      <div class="bg-gray-900/70 backdrop-blur-sm border border-amber-900/30 rounded-xl p-4 sm:p-6 hover:border-amber-800/50 transition-colors">
        <h3 class="text-amber-300/90 text-lg font-medium mb-4 text-center uppercase tracking-wider">
          Por Profesión
        </h3>
        <div class="space-y-3">
          {
            Object.entries(stats.professions || {})
              .filter(([_, count]) => count > 0)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 11)
              .map(([code, count]) => {
                const profName = PROFESSIONS[code as keyof typeof PROFESSIONS] || code;
                const percentage = Math.min(100, Math.round((count / stats.validNotesCount) * 100));
                
                // Mapa de colores por código de profesión
                const colorsMap = {
                  JC: { light: '#fde047', dark: '#d97706' },  // Joyería
                  BS: { light: '#60a5fa', dark: '#1d4ed8' },  // Herrería
                  EN: { light: '#c084fc', dark: '#7e22ce' },  // Encantamiento
                  EG: { light: '#2dd4bf', dark: '#0d9488' },  // Ingeniería
                  AL: { light: '#4ade80', dark: '#15803d' },  // Alquimia
                  TL: { light: '#f472b6', dark: '#db2777' },  // Sastrería
                  IN: { light: '#818cf8', dark: '#4f46e5' },  // Inscripción
                  HB: { light: '#84cc16', dark: '#65a30d' },  // Herboristería
                  LW: { light: '#f59e0b', dark: '#d97706' },  // Peletería
                  MN: { light: '#f97316', dark: '#c2410c' },  // Minería
                  SK: { light: '#f43f5e', dark: '#be123c' }   // Desuello
                };
                
                // Obtener los colores para la profesión
                const colors = colorsMap[code as keyof typeof colorsMap] || { light: '#d1d5db', dark: '#6b7280' };
                
                return (
                  <div class="space-y-1.5">
                    <div class="flex items-center justify-between text-xs">
                      <div class="flex items-center">
                        <span
                          class="w-2.5 h-2.5 rounded-full mr-2 border border-amber-900/30"
                          style={`background-color: ${colors.dark}`}
                        />
                        <span class="text-amber-100/80">{profName}</span>
                      </div>
                      <div class="flex items-center">
                        <span class="text-white font-semibold mr-1">{count}</span>
                        <span class="text-amber-100/60 text-[11px]">({percentage}%)</span>
                      </div>
                    </div>
                    <div class="w-full bg-amber-900/30 rounded-full h-1.5 overflow-hidden">
                      <div
                        class="h-full rounded-full transition-all duration-500 ease-out"
                        style={{
                          width: `${percentage}%`,
                          background: `linear-gradient(90deg, ${colors.light}, ${colors.dark})`,
                        }}
                      />
                    </div>
                  </div>
                );
              })
          }
        </div>
      </div>
  </div>

  <!-- Script para el manejo de pestañas -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const tabButtons = document.querySelectorAll<HTMLButtonElement>('.tab-button');
      const tabPanes = document.querySelectorAll<HTMLElement>('.tab-pane');
      const defaultTab = document.getElementById('legend-tab');

      // Activar la pestaña por defecto
      if (defaultTab) {
        defaultTab.classList.remove('hidden');
      }

      tabButtons.forEach((button) => {
        button.addEventListener('click', () => {
          // Remover clases activas
          tabButtons.forEach((btn) => {
            btn.classList.remove('active', 'border-accent', 'text-white');
            btn.classList.add('text-text-muted');
          });

          tabPanes.forEach((pane) => pane.classList.add('hidden'));

          // Activar pestaña clickeada
          button.classList.remove('text-text-muted');
          button.classList.add('active', 'border-accent', 'text-white');

          const tabId = button.getAttribute('data-tab');
          if (tabId) {
            const tabPane = document.getElementById(`${tabId}-tab`);
            if (tabPane) {
              tabPane.classList.remove('hidden');

              // Forzar reflow para activar la animación
              void tabPane.offsetWidth;
              tabPane.style.animation = 'fadeIn 0.3s ease';

              // Remover la animación después de que termine
              setTimeout(() => {
                tabPane.style.animation = '';
              }, 300);
            }
          }
        });
      });
    });
  </script>

  <style>
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .tab-pane {
      animation: fadeIn 0.3s ease-out;
    }
  </style>

  <!-- Estilos para las pestañas -->
  <style>
    .tab-button {
      transition: all 0.2s ease;
      margin-bottom: -1px;
    }
    .tab-button:hover {
      color: white;
    }
    .tab-button.active {
      border-bottom-color: #3b82f6;
      color: white;
    }
    .tab-pane {
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</div>
