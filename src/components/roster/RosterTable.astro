---
// Definir las props del componente
interface Props {
  initialRosterData?: any[];
}

// Obtener las props
const { initialRosterData: rosterDataFromProps = [] } = Astro.props;

// Define default class info with TypeScript type
const defaultClassInfo: Record<string, { name: string; color: string }> = {
  Guerrero: { color: 'C79C6E', name: 'Guerrero' },
  Paladín: { color: 'F58CBA', name: 'Paladín' },
  Cazador: { color: 'ABD473', name: 'Cazador' },
  Pícaro: { color: 'FFF569', name: 'Pícaro' },
  Sacerdote: { color: 'FFFFFF', name: 'Sacerdote' },
  'Caballero de la Muerte': { color: 'C41F3B', name: 'Caballero de la Muerte' },
  Chamán: { color: '0070DE', name: 'Chamán' },
  Mago: { color: '69CCF0', name: 'Mago' },
  Brujo: { color: '9482C9', name: 'Brujo' },
  Druida: { color: 'FF7D0A', name: 'Druida' },
};

// Import types and constants from roster types
import type {
  RosterMember as RosterMemberType,
  RosterData as RosterDataType,
  ClassName as ClassNameType,
  Role,
  MainAlt,
  ProfessionCode,
  RaidCode,
  DifficultyCode,
  PublicNoteValidation as RosterPublicNoteValidation,
  MainAltDistributionItem as MainAltDistItem,
  NoteBlock,
  Member,
  RosterStats,
  RaidInfo,
} from '../../types/roster';

// Usar los tipos directamente desde la importación

// Import roster utilities
import {
  validatePublicNote as validateRosterNote,
  calculateRoleDistribution as calculateRoleDistro,
  calculateGearScoreStats as calculateGSStats,
  countRaidLeaders as countLeaders,
  calculateMainAltDistribution as calculateMainAlts,
  PROFESSION_CODES,
} from '../../utils/rosterUtils';

type ProfessionCode = (typeof PROFESSION_CODES)[number];

// Variables para las estadísticas de Gear Score
let gearScoreStats = {
  min: 0,
  max: 0,
  avg: 0,
  total: 0,
  mainGearScore: 0,
  dualGearScore: null as number | null,
};
let averageGearScore = 'N/A';
let minGearScore = 'N/A';
let maxGearScore = 'N/A';
let mainGearScore = 'N/A';
let dualGearScore = 'N/A';

// Import constants
import {
  ROLES,
  PROFESSIONS,
  RAID_NAMES,
  DIFFICULTY_NAMES,
  DAY_NAMES,
  RAID_CODES,
  DIFFICULTIES,
  STATUS,
} from '../../types/roster';

// Define initial stats structure
const initialStats: RosterStats = {
  totalMembers: 0,
  roleDistribution: { tank: 0, healer: 0, melee: 0, ranged: 0 },
  gearScoreStats: {
    min: 0,
    max: 0,
    avg: 0,
    total: 0,
  },
  raidLeadersCount: 0,
  mainAltDistribution: { M: 0, A: 0 },
  professions: {},
  validNotesCount: 0,
};

// Define RAIDS constant with proper typing
const RAIDS: Array<{ code: RaidCode; name: string }> = Object.entries(RAID_NAMES).map(
  ([code, name]) => ({
    code: code as RaidCode,
    name: String(name),
  })
);

// Initialize stats with default values
let stats: RosterStats = { ...initialStats };

// Type definitions for the component
interface RoleInfo {
  name: string;
  color: string;
  icon: string;
}

// Usar RosterMemberType importado directamente

// Component props interface
export interface RosterTableProps {
  rosterData: RosterDataType;
  status?: {
    isLoading: boolean;
    error: string | null;
  };
}

// Get props from Astro
const { rosterData: initialRosterData, status = { isLoading: false, error: null } } =
  Astro.props as RosterTableProps;

// Define default roster data structure
const defaultRosterData: RosterData = {
  members: [],
  classInfo: {},
  rankInfo: {},
  classes: [],
  totalMembers: 0,
  guildInfo: {
    name: '',
    realm: '',
    faction: 0,
    level: 25,
    memberCount: 0,
    achievementPoints: 0,
  },
  stats: {
    ...initialStats,
    total: 0,
    raidLeadersCount: 0,
    mainAltDistribution: { M: 0, A: 0 },
    professions: {},
    validNotesCount: 0,
  },
} as const;

// Usar directamente las funciones importadas con sus alias

// Process members with proper typing
const processRosterMember = (member: any): RosterMemberType => {
  const className = (Object.keys(defaultClassInfo) as (keyof typeof defaultClassInfo)[]).includes(
    member.class
  )
    ? (member.class as keyof typeof defaultClassInfo)
    : ('Desconocido' as const);

  // Ensure mainAlt is either 'M' or 'A'
  const mainAlt =
    member.mainAlt === 'main' ? 'M' : member.mainAlt === 'alt' ? 'A' : member.mainAlt || 'A';

  // Validar la nota pública usando el alias importado
  const noteValidation = validateRosterNote(
    member.publicNote || '',
    member.name || '',
    member.officerNote || ''
  );

  // Asegurar que noteValidation cumpla con PublicNoteValidation
  const validNoteValidation: RosterPublicNoteValidation = {
    isValid: noteValidation.isValid || false,
    blocks: noteValidation.blocks || [],
    mainAlt: noteValidation.mainAlt || 'A', // Valor por defecto 'A' si no está definido
    role: noteValidation.role,
    dualRole: noteValidation.dualRole,
    gearScore: noteValidation.gearScore || 0,
    dualGearScore: noteValidation.dualGearScore,
    professions: noteValidation.professions || [],
    isRaidLeader: noteValidation.isRaidLeader || false,
    hasSchedule: noteValidation.hasSchedule || false,
    hasRaids: noteValidation.hasRaids || false,
    schedules: noteValidation.schedules || [],
    raids: noteValidation.raids || [],
    error: noteValidation.error,
    missingFields: noteValidation.missingFields || [],
  };

  // Create a valid RosterMember object with required properties
  const processedMember: RosterMemberType = {
    ...member,
    name: member.name || '',
    class: className,
    rank: member.rank || '',
    publicNote: member.publicNote || '',
    officerNote: member.officerNote || '',
    noteValidation: validNoteValidation,
    mainAlt: mainAlt as MainAlt,
  };

  return processedMember;
};

// Las funciones de cálculo ahora se importan desde rosterUtils.ts

// Define the roster data with proper typing
// Procesar los miembros del roster
const members = rosterDataFromProps.map(processRosterMember);
const totalMembers = members.length;
const validNotesCount = members.filter((m) => m.publicNote).length;

// Utility function to get role percentage
const getRolePercentage = (count: number, total: number = totalMembers) => {
  return total > 0 ? Math.round((count / total) * 100) : 0;
};

// Calcular las estadísticas de Gear Score
const updateGearScoreStats = () => {
  try {
    const stats = calculateGSStats(members as unknown as RosterMemberType[]);
    gearScoreStats = stats;
    averageGearScore = stats.avg > 0 ? stats.avg.toFixed(1) : 'N/A';
    minGearScore = stats.min > 0 ? stats.min.toFixed(1) : 'N/A';
    maxGearScore = stats.max > 0 ? stats.max.toFixed(1) : 'N/A';
    mainGearScore = stats.mainGearScore > 0 ? stats.mainGearScore.toFixed(1) : 'N/A';
    dualGearScore =
      stats.dualGearScore !== null && stats.dualGearScore > 0
        ? stats.dualGearScore.toFixed(1)
        : 'N/A';
  } catch (error) {
    gearScoreStats = { min: 0, max: 0, avg: 0, total: 0 };
    averageGearScore = 'N/A';
    minGearScore = 'N/A';
    maxGearScore = 'N/A';
  }
};

// Ejecutar el cálculo inicial
updateGearScoreStats();

// Function to ensure roster members have all required properties
function ensureRosterMember(member: Partial<RosterMember>): RosterMember {
  return {
    name: member.name || 'Unknown',
    class: member.class || 'Guerrero',
    rank: member.rank || 'Aspirante',
    publicNote: member.publicNote || '',
    officerNote: member.officerNote || '',
    noteValidation: member.noteValidation || {
      isValid: false,
      mainAlt: 'M',
      role: 'D',
      gearScore: 0,
      professions: [],
      raids: [],
      schedules: [],
      missingFields: [],
      error: 'No note provided',
    },
    ...member,
  };
}

// Process members to ensure they have required properties
const processedMembers = members.map((member) =>
  ensureRosterMember(member as Partial<RosterMember>)
);

// Create the rosterData object with the expected structure
const rosterData: RosterDataWithRankInfo = {
  ...defaultRosterData,
  members: processedMembers,
  totalMembers,
  classInfo: {
    ...defaultClassInfo,
  },
  stats: {
    ...initialStats,
    totalMembers,
    validNotesCount,
    roleDistribution: calculateRoleDistro(processedMembers),
    gearScoreStats: calculateGSStats(processedMembers),
    raidLeadersCount: countLeaders(processedMembers),
    mainAltDistribution: calculateMainAlts(processedMembers),
    professions: {},
  },
  raids: [],
  raidDays: {},
  raidTimes: {},
  rankInfo: {},
} as unknown as RosterDataWithRankInfo;

// Calculate statistics - single implementation
const calculateStats = (members: RosterMember[]): RosterStats => {
  if (!members.length)
    return {
      ...initialStats,
      totalMembers: 0,
      roleDistribution: {},
      gearScoreStats: { min: 0, max: 0, avg: 0, total: 0, mainGearScore: 0, dualGearScore: null },
      raidLeadersCount: 0,
      mainAltDistribution: { M: 0, A: 0 },
      professions: {},
      validNotesCount: 0,
    } as RosterStats;

  // Use members directly with proper type
  const roleDistribution = calculateRoleDistro(members);
  const gearScoreStats = calculateGSStats(members);
  const raidLeadersCount = countLeaders(members);
  const mainAltDistribution = calculateMainAlts(members);
  const validNotesCount = members.filter((m) => m.noteValidation?.isValid).length;

  // Initialize professions object with all possible profession codes set to 0
  const professions: Record<string, number> = {
    JC: 0,
    BS: 0,
    EN: 0,
    EG: 0,
    LW: 0,
    AL: 0,
    TL: 0,
    IN: 0,
    HB: 0,
    MN: 0,
    SK: 0,
  };

  // Initialize profession counts to 0
  PROFESSION_CODES.forEach((code) => {
    professions[code] = 0;
  });

  let totalProcessed = 0;
  let membersWithValidNotes = 0;

  // Process each member's professions
  for (const member of members) {
    // Only process if the note is valid
    if (!member.noteValidation?.isValid) {
      continue;
    }

    membersWithValidNotes++;

    // Get professions from all possible sources
    const profSources: string[] = [];

    // 1. Get professions directly from noteValidation
    if (member.noteValidation?.professions?.length) {
      profSources.push(...member.noteValidation.professions);
    }

    // 2. Get professions from character blocks
    const characterBlocks = (member.noteValidation?.blocks || []).filter(
      (b) => b.type === 'character' && b.parsedData?.professions?.length
    );

    if (characterBlocks.length > 0) {
      characterBlocks.forEach((block) => {
        if (block.parsedData?.professions?.length) {
          profSources.push(...block.parsedData.professions);
        }
      });
    }

    // Filter and normalize profession codes
    const allProfs: string[] = [...new Set(profSources)]
      .filter((code): code is string => Boolean(code)) // Filter and ensure they are strings
      .map((code) => {
        const normalizedCode = code.trim().toUpperCase();
        // Ensure the code has exactly 2 characters
        return normalizedCode.length === 2 ? normalizedCode : null;
      })
      .filter((code): code is string => Boolean(code)) // Remove null codes after normalization
      .filter((code): code is ProfessionCode => {
        const isValid = PROFESSION_CODES.includes(code as ProfessionCode);
        if (!isValid && code) {
          console.warn(`  Unrecognized profession code: "${code}"`);
        }
        return isValid;
      }) as ProfessionCode[]; // Ensure TypeScript knows these are valid profession codes

    // Count the professions
    allProfs.forEach((profCode) => {
      if (profCode in professions) {
        professions[profCode]++;
        totalProcessed++;
      } else {
        console.warn(`  Unrecognized profession code: ${profCode}`);
      }
    });
  }

  // Verificar si hay alguna profesión con conteo > 0
  const hasProfessions = Object.values(professions).some((count) => count > 0);

  if (!hasProfessions) {
    console.warn('No se encontraron profesiones en ninguna nota. Revisar el formato de las notas.');
  }

  // Actualizar las estadísticas globales
  stats.validNotesCount = membersWithValidNotes;
  stats.professions = professions;

  return {
    totalMembers: members.length,
    roleDistribution,
    gearScoreStats,
    raidLeadersCount,
    mainAltDistribution,
    professions,
    validNotesCount: membersWithValidNotes,
  };
};

// mainAltStats se define más abajo con un cálculo más completo

// Calcular estadísticas completas del roster
const calculatedStats = calculateStats(rosterData.members);

// Actualizar las estadísticas del roster
stats = {
  ...stats,
  totalMembers: rosterData.totalMembers,
  validNotesCount: calculatedStats.validNotesCount || 0,
  professions: calculatedStats.professions || {},
};

// Asegurarse de que rosterData.stats tenga las estadísticas actualizadas
rosterData.stats = {
  ...rosterData.stats,
  ...calculatedStats,
};

// Inicializar roleStats contando cada rol (T, H, D) independientemente de si es rol principal o dual
// Un jugador puede contribuir a múltiples roles si tiene un rol dual
const roleStats = {
  T: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'T' || member.noteValidation?.dualRole === 'T'
  ).length,
  H: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'H' || member.noteValidation?.dualRole === 'H'
  ).length,
  D: rosterData.members.filter(
    (member) => member.noteValidation?.role === 'D' || member.noteValidation?.dualRole === 'D'
  ).length,
};

// Contar roles duales por separado
const dualRoleStats = {
  TH: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'T' && member.noteValidation?.dualRole === 'H') ||
      (member.noteValidation?.role === 'H' && member.noteValidation?.dualRole === 'T')
  ).length,
  TD: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'T' && member.noteValidation?.dualRole === 'D') ||
      (member.noteValidation?.role === 'D' && member.noteValidation?.dualRole === 'T')
  ).length,
  HD: rosterData.members.filter(
    (member) =>
      (member.noteValidation?.role === 'H' && member.noteValidation?.dualRole === 'D') ||
      (member.noteValidation?.role === 'D' && member.noteValidation?.dualRole === 'H')
  ).length,
};

// Format role distribution for display
const formattedRoleDistribution = Object.entries(rosterData.stats.roleDistribution || {})
  .filter(([_, count]) => count > 0)
  .map(([role, count]) => ({
    role,
    count: Number(count) || 0,
    percentage: getRolePercentage(Number(count) || 0, stats.totalMembers),
  }));

// Mapeo de roles a nombres completos y colores
interface RoleInfo {
  name: string;
  color: string;
  bgColor: string;
}

// Use the imported ROLES constant instead of redefining it

// Mapeo de colores para las profesiones
const professionColors: Record<string, string> = {
  AL: 'bg-green-500/20 text-green-300',
  HB: 'bg-green-500/20 text-green-300',
  TL: 'bg-pink-500/20 text-pink-300',
  EN: 'bg-purple-500/20 text-purple-300',
  EG: 'bg-blue-500/20 text-blue-300',
  JC: 'bg-yellow-500/20 text-yellow-300',
  BS: 'bg-gray-500/20 text-gray-300',
  IN: 'bg-indigo-500/20 text-indigo-300',
  MN: 'bg-gray-600/20 text-gray-400',
  SK: 'bg-orange-500/20 text-orange-300',
  LW: 'bg-amber-500/20 text-amber-300',
};

// Mapeo de colores para las dificultades
const difficultyColors: Record<string, string> = {
  '10N': 'bg-blue-500/20 text-blue-300',
  '10H': 'bg-blue-700/20 text-blue-400',
  '25N': 'bg-purple-500/20 text-purple-300',
  '25H': 'bg-red-500/20 text-red-300',
};

// Función para obtener el color de fondo basado en la clase del personaje
function getClassColor(className: string): string {
  const classColors: Record<string, string> = {
    Guerrero: 'bg-[#C79C6E]',
    Paladín: 'bg-[#F58CBA]',
    Cazador: 'bg-[#ABD473]',
    Pícaro: 'bg-[#FFF569]',
    Sacerdote: 'bg-[#FFFFFF]',
    'Caballero de la Muerte': 'bg-[#C41F3B]',
    Chamán: 'bg-[#0070DE]',
    Mago: 'bg-[#69CCF0]',
    Brujo: 'bg-[#9482C9]',
    Monje: 'bg-[#00FF96]',
    Druida: 'bg-[#FF7D0A]',
    'Cazador de demonios': 'bg-[#A330C9]',
  };
  return classColors[className] || 'bg-gray-500';
}

// Función para obtener el color de la profesión
function getProfessionColor(profCode: ProfessionCode): string {
  const professionColors = {
    JC: { light: 'bg-yellow-500/20', dark: 'text-yellow-300' },
    BS: { light: 'bg-gray-500/20', dark: 'text-gray-300' },
    EN: { light: 'bg-purple-500/20', dark: 'text-purple-300' },
    EG: { light: 'bg-blue-500/20', dark: 'text-blue-300' },
    LW: { light: 'bg-amber-500/20', dark: 'text-amber-300' },
    AL: { light: 'bg-green-500/20', dark: 'text-green-300' },
    TL: { light: 'bg-pink-500/20', dark: 'text-pink-300' },
    IN: { light: 'bg-indigo-500/20', dark: 'text-indigo-300' },
    HB: { light: 'bg-green-500/20', dark: 'text-green-300' },
    MN: { light: 'bg-gray-600/20', dark: 'text-gray-400' },
    SK: { light: 'bg-orange-500/20', dark: 'text-orange-300' },
  };

  const color = professionColors[profCode] || { light: 'bg-gray-500/20', dark: 'text-gray-400' };
  return `${color.light} ${color.dark}`;
}

// Extend RosterMemberType with additional properties
interface MainAltDistributionItem extends DistributionItem {
  type: 'M' | 'A';
  name: string;
  count: number;
  percentage: number;
  color?: string;
}

// Import types from the types file
import type {
  RosterMember as RosterMemberType,
  PublicNoteValidation as RosterPublicNoteValidation,
  RosterData as BaseRosterData,
  RosterStats,
  ClassName,
  Role,
  MainAlt,
  Member,
  PublicNoteValidation,
} from '../../types/roster';

// Define the default note validation object
const defaultNoteValidation: PublicNoteValidation = {
  isValid: false,
  blocks: [],
  isRaidLeader: false,
  hasSchedule: false,
  hasRaids: false,
};

// Define a type for the roster member with all required properties
type RosterMember = Omit<RosterMemberType, 'noteValidation'> & {
  name: string;
  class: ClassName;
  rank: string;
  publicNote?: string;
  officerNote?: string;
  noteValidation: PublicNoteValidation;
  _priority?: number;
  mainAlt: MainAlt;
  role?: Role;
  // Add index signature to allow dynamic property access with type safety
  [key: string]: unknown;
};

// Type guard to check if a member has noteValidation
function hasNoteValidation(
  member: RosterMember
): member is RosterMember & { noteValidation: RosterPublicNoteValidation } {
  return member.noteValidation !== undefined;
}

// Type for the member parameter in array methods
type MemberCallback = (member: RosterMember) => void;

// Extend the base RosterData type to include rankInfo
type RosterDataWithRankInfo = Omit<BaseRosterData, 'members' | 'stats' | 'rankInfo'> & {
  members: RosterMember[];
  stats: RosterStats;
  rankInfo: Record<string, { name: string; order: number }>;
  // Add missing properties from BaseRosterData
  classInfo: Record<string, ClassInfo>;
  name: string;
  order: number;
  classes: string[];
  totalMembers: number;
  raids: any[];
  raidDays: Record<string, unknown>;
  raidTimes: Record<string, unknown>;
};

// Type for the member parameter in array methods
type MemberCallback = (member: RosterMember) => void;

// Calculate main/alt distribution
const calculateMainAltDistribution = (members: Member[]): { M: number; A: number } => {
  const result = { M: 0, A: 0 };

  for (const member of members) {
    const mainAlt = member.noteValidation?.mainAlt || 'A'; // Default to 'A' if not specified
    if (mainAlt === 'M') {
      result.M++;
    } else {
      // Count as Alt if not explicitly marked as Main
      result.A++;
    }
  }

  return result;
};

// ==========================================
// TIPOS Y UTILIDADES
// ==========================================

type ClassName =
  | 'Guerrero'
  | 'Paladín'
  | 'Cazador'
  | 'Pícaro'
  | 'Sacerdote'
  | 'Caballero de la Muerte'
  | 'Chamán'
  | 'Mago'
  | 'Brujo'
  | 'Druida';

// Use imported types from roster.ts

interface RaidInfo {
  name: string;
  difficulty?: string;
  code: string;
  difficultyCode?: string;
}

interface PublicNoteValidation {
  isValid: boolean;
  mainAlt?: MainAlt;
  role?: Role;
  dualRole?: Role;
  gearScore?: string;
  professions?: string[];
  schedules?: string[];
  raids?: RaidInfo[];
  isRaidLeader?: boolean;
  error?: string;
  missingFields?: string[];
  days?: string[];
}

interface ClassInfo {
  color: string;
  name: string;
}

interface RosterData {
  members: RosterMember[];
  classInfo: Record<string, ClassInfo>;
  rankInfo: Record<string, { name: string; order: number }>;
}

// Validar nota pública según el formato requerido
function validatePublicNote(
  note: string | undefined,
  characterName: string = 'Desconocido',
  officerNote: string = ''
): RosterPublicNoteValidation {
  // Usar la función importada que combina notas públicas y oficiales
  const result = validateRosterNote(note, characterName, officerNote);

  // Crear un objeto con los valores por defecto según la interfaz
  const validated: RosterPublicNoteValidation = {
    isValid: result.isValid || false,
    blocks: result.blocks || [],
    isRaidLeader: result.isRaidLeader || false,
    hasSchedule: result.hasSchedule || false,
    hasRaids: result.hasRaids || false,
    missingFields: result.missingFields || [],
    // Propiedades opcionales
    mainAlt: result.mainAlt,
    role: result.role,
    dualRole: result.dualRole,
    gearScore: result.gearScore,
    professions: result.professions,
    schedules: result.schedules,
    raids: result.raids,
    error: result.error,
  };

  return validated;
}

// Función auxiliar para validar notas (mantener para compatibilidad)
function validateNoteLegacy(
  note: string | undefined,
  characterName: string = 'Desconocido'
): RosterPublicNoteValidation {
  const errors: string[] = [];
  const missingFields: string[] = [];
  const result: RosterPublicNoteValidation & { blocks?: Array<{ type: string; parsedData: any }> } =
    {
      isValid: false,
      raids: [],
      blocks: [],
    };

  if (!note?.trim()) {
    return { ...result, error: 'La nota pública no puede estar vacía' };
  }

  const trimmedNote = note.trim();
  const parts = trimmedNote.split(/\s+/); // Dividir por cualquier espacio en blanco

  // 1. Detección de Main/Alt (M/A) - Prioridad a patrones con roles

  // Patrón 1: M o A seguido de rol (ej: 'MT', 'AD', 'MH', 'AH', 'at', 'md')
  const mainAltWithRole = trimmedNote.match(/^([MA])([THD])(?![a-zA-Z])/i);

  // Patrón para notas con gear score (ej: 'AD5.9', 'at5.7')
  const gearScorePattern = trimmedNote.match(/^([MA])([THD])(\d+(?:\.\d+)?)/i);

  // Patrón para notas con profesiones (ej: 'adALHB', 'ad6.6TLBS')
  const professionPattern = trimmedNote.match(/^([MA])([THD])(\d+(?:\.\d+)?)?([A-Za-z]{2,})/i);

  // Patrón para notas de raid (ej: 'AT5.9 M20RLTOC25N')
  const raidPatternMatch = trimmedNote.match(
    /^([MA])([THD])(\d+(?:\.\d+)?)?(?:\s+([A-Za-z0-9]+))?/i
  );

  if (mainAltWithRole || gearScorePattern || professionPattern || raidPatternMatch) {
    // Extraer la información del patrón coincidente
    let mainAlt,
      role,
      gearScore = 0,
      professions = [];
    let raidInfo = null;

    if (mainAltWithRole) {
      mainAlt = mainAltWithRole[1].toUpperCase() as MainAlt;
      role = mainAltWithRole[2].toUpperCase() as Role;
    } else if (gearScorePattern) {
      mainAlt = gearScorePattern[1].toUpperCase() as MainAlt;
      role = gearScorePattern[2].toUpperCase() as Role;
      gearScore = parseFloat(gearScorePattern[3]);
    } else if (professionPattern) {
      mainAlt = professionPattern[1].toUpperCase() as MainAlt;
      role = professionPattern[2].toUpperCase() as Role;
      if (professionPattern[3]) {
        gearScore = parseFloat(professionPattern[3]);
      }
      // Extraer códigos de profesión (2 letras cada uno)
      const profCodes = (professionPattern[4] || '').match(/[A-Za-z]{2}/g) || [];
      professions = profCodes.map((p) => p.toUpperCase() as ProfessionCode);
    } else if (raidPatternMatch) {
      mainAlt = raidPatternMatch[1].toUpperCase() as MainAlt;
      role = raidPatternMatch[2].toUpperCase() as Role;
      if (raidPatternMatch[3]) {
        gearScore = parseFloat(raidPatternMatch[3]);
      }
      // Procesar información de raid si está presente
      if (raidPatternMatch[4]) {
        const raidMatch = raidPatternMatch[4].match(/([A-Za-z]+)(\d+)([NH])?/i);
        if (raidMatch) {
          raidInfo = {
            code: raidMatch[1].toUpperCase(),
            difficulty: raidMatch[3] ? `${raidMatch[2]}${raidMatch[3]}` : undefined,
            isRaidLeader: raidPattern[4].toLowerCase().includes('rl'),
          };
        }
      }
    }

    // Crear el bloque de personaje
    const characterBlock: NoteBlock = {
      type: 'character',
      content: trimmedNote,
      isValid: true,
      parsedData: {
        mainAlt,
        role,
        mainRole: role,
        mainGearScore: gearScore,
        professions: professions,
      },
    };

    // Crear el objeto de resultado
    const validationResult: RosterPublicNoteValidation = {
      isValid: true,
      blocks: [characterBlock],
      mainAlt,
      role,
      mainRole: role,
      gearScore: gearScore,
      professions: professions,
      schedules: [],
      raids: raidInfo
        ? [
            {
              code: raidInfo.code as RaidCode,
              difficulty: (raidInfo.difficulty as DifficultyCode) || '10N',
              name: raidInfo.code,
              difficultyCode: (raidInfo.difficulty as DifficultyCode) || '10N',
              isRaidLeader: raidInfo.isRaidLeader || false,
            },
          ]
        : [],
      isRaidLeader: raidInfo?.isRaidLeader || false,
      hasSchedule: false,
      hasRaids: !!raidInfo,
      missingFields: [],
    };

    // Si es un patrón simple (AD, AT, etc.), marcar como válido y salir
    if (trimmedNote.length === 2 || (gearScore && trimmedNote.length <= 10)) {
      // Asegurarse de que el bloque de personaje tenga toda la información necesaria
      const charBlock: NoteBlock = {
        type: 'character',
        content: trimmedNote,
        isValid: true,
        parsedData: {
          mainAlt,
          role,
          mainRole: role,
          mainGearScore: 0,
          professions: [],
        },
      };

      // Crear el resultado final
      const finalResult: RosterPublicNoteValidation = {
        isValid: true,
        blocks: [charBlock],
        mainAlt,
        role,
        mainRole: role,
        gearScore: 0,
        professions: [],
        schedules: [],
        raids: [],
        isRaidLeader: false,
        hasSchedule: false,
        hasRaids: false,
        missingFields: [],
      };

      return finalResult;
    }

    // Actualizar el resultado actual
    Object.assign(result, validationResult);
  } else {
    // Si no coincide el primer patrón, intentar con el patrón de dos letras
    const twoLetterPattern = trimmedNote.match(/^([a-zA-Z]{2})(?:\s|$)/i);
    if (twoLetterPattern) {
      const code = twoLetterPattern[1].toUpperCase();

      // Verificar si el código es un patrón de rol (primera letra M/A, segunda T/H/D)
      const roleMatch = code.match(/^([MA])([THD])$/i);
      if (roleMatch) {
        const mainAlt = roleMatch[1].toUpperCase() as MainAlt;
        const role = roleMatch[2].toUpperCase() as Role;

        const charBlock: NoteBlock = {
          type: 'character',
          content: code,
          isValid: true,
          parsedData: {
            mainAlt,
            role,
            mainRole: role,
            mainGearScore: 0,
            professions: [],
          },
        };

        return {
          isValid: true,
          blocks: [charBlock],
          mainAlt,
          role,
          mainRole: role,
          gearScore: 0,
          professions: [],
          schedules: [],
          raids: [],
          isRaidLeader: false,
          hasSchedule: false,
          hasRaids: false,
          missingFields: [],
        };
      }
    }
  }

  // Patrones adicionales...
  if (!result.role) {
    const twoLetterPattern = trimmedNote.match(/^([a-zA-Z]{2})(?:\s|$)/i);
    if (twoLetterPattern) {
      const [_, code] = twoLetterPattern;
      const upperCode = code.toUpperCase();
      const validRoles = ['T', 'H', 'D'];
      const validMains = ['M', 'A'];

      const firstChar = upperCode[0];
      const secondChar = upperCode[1];

      // Caso 1: Primera letra es M/A y segunda es T/H/D (ej: MT, AD, MH, MD)
      if (validMains.includes(firstChar) && validRoles.includes(secondChar)) {
        result.mainAlt = firstChar as MainAlt;
        result.role = secondChar as Role;
        result.mainRole = secondChar as Role;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              role: result.role,
              mainRole: result.role,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 2: Primera letra es T/H/D y segunda es M/A (ej: TM, HA, DM)
      else if (validRoles.includes(firstChar) && validMains.includes(secondChar)) {
        result.role = firstChar as Role;
        result.mainRole = firstChar as Role;
        result.mainAlt = secondChar as MainAlt;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              role: result.role,
              mainRole: result.role,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 3: Cualquier combinación de dos letras de rol (ej: TH, HD, DT)
      else if (validRoles.includes(firstChar) && validRoles.includes(secondChar)) {
        result.role = firstChar as Role;
        result.mainRole = firstChar as Role;
        result.dualRole = secondChar as Role;
        result.isValid = true;

        // Crear bloque de personaje para el renderizado
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              role: result.role,
              mainRole: result.role,
              dualRole: result.dualRole,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }
      // Caso 4: Primera letra es M/A y segunda es M/A (ej: MA, AM)
      else if (validMains.includes(firstChar) && validMains.includes(secondChar)) {
        result.mainAlt = firstChar as MainAlt;
        result.isValid = true;

        // Crear bloque de personaje mínimo
        result.blocks = [
          {
            type: 'character',
            parsedData: {
              mainAlt: result.mainAlt,
              mainGearScore: 0,
              professions: [],
            },
          },
        ];
      }

      // Si encontramos un patrón válido de dos letras, asegurar que los campos requeridos estén establecidos
      if (result.isValid) {
        // Asegurar que siempre haya un valor para mainRole
        result.mainRole = result.mainRole || result.role;
        return result;
      }
    }
  }

  // Patrón 2: M o A al inicio de la nota (ej: 'M 5.9', 'A TL/EN', 'a')
  if (!result.mainAlt) {
    const startWithMainAlt = trimmedNote.match(/^([MA])(?:\s+|$)/i);
    if (startWithMainAlt) {
      result.mainAlt = startWithMainAlt[1].toUpperCase() as MainAlt;

      // Si es solo 'a' o 'm', marcar como válido
      if (trimmedNote.match(/^[ma]$/i)) {
        result.isValid = true;
      }
    }
  }

  // Patrón 3: M o A con separador (ej: 'M/Tank', 'A-Healer')
  if (!result.mainAlt) {
    const mainAltWithSeparator = trimmedNote.match(/(?:^|[\s/\-|])([MA])(?=$|[\s/\-|])/i);
    if (mainAltWithSeparator) {
      result.mainAlt = mainAltWithSeparator[1].toUpperCase() as MainAlt;
    }
  }

  // Patrón 4: M o A en cualquier parte como palabra completa (último recurso)
  if (!result.mainAlt) {
    const mainAltAnywhere = trimmedNote.match(/(?:^|\s)([MA])(?:\s|$)/i);
    if (mainAltAnywhere) {
      result.mainAlt = mainAltAnywhere[1].toUpperCase() as MainAlt;
    }
  }

  // 2. Buscar si es Raid Leader (RL o rl)
  // Primero buscar el formato específico '20:00xRLICC25N' o similar
  result.isRaidLeader = /\d{1,2}[:.]?\d{0,2}xRL/.test(trimmedNote);

  // Si no se encontró, buscar otros patrones comunes
  if (!result.isRaidLeader) {
    // Buscar patrones como 'RL', 'rl', 'RaidLeader', 'raid leader', etc.
    result.isRaidLeader = /(?:^|\s|\d*[xX]?\s*)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl)\b/i.test(
      trimmedNote
    );
  }

  // 3. Buscar roles (T, H, D) y rol dual
  // Primero buscar formato de rol con GS (ej: d5.8, t6.2, D5.8, T6.2)
  const roleWithGS = trimmedNote.match(/^([thdTHD])(\d\.?\d?\d?)$/);
  if (roleWithGS && !result.role) {
    result.role = roleWithGS[1].toUpperCase() as Role;
    result.gearScore = roleWithGS[2];
    result.isValid = true;
  }

  // Buscar formato de 3 letras que comience con A o M (ej: MDT, AHT, etc.)
  const threeLetterRoleMatch = trimmedNote.match(/\b([MA]?)([THD])([THD]?)\b/i);

  if (threeLetterRoleMatch) {
    const [, mainAlt, primaryRole, dualRole] = threeLetterRoleMatch;

    // Si hay un prefijo M o A, establecer mainAlt
    if (mainAlt) {
      result.mainAlt = mainAlt.toUpperCase() as MainAlt;
    } else if (!result.mainAlt && threeLetterRoleMatch[0].startsWith('M')) {
      // Si no hay mainAlt pero el match empieza con M, asumir que es Main
      result.mainAlt = 'M';
    }

    // Establecer rol principal
    result.role = primaryRole.toUpperCase() as Role;

    // Si hay un rol dual, establecerlo
    if (dualRole) {
      const dual = dualRole.toUpperCase() as Role;
      if (dual !== result.role) {
        result.dualRole = dual;
      } else {
        errors.push('El rol secundario no puede ser igual al principal');
      }
    }
  }

  // Si no se encontró un rol dual, buscar cualquier otro rol en la nota
  if (!result.dualRole) {
    // Buscar cualquier letra T, H o D que no sea parte de otra palabra
    const roleMatches = [...trimmedNote.matchAll(/\b([THD])\b/gi)];
    const roles = Array.from(new Set(roleMatches.map((m) => m[1].toUpperCase())));

    // Si hay más de un rol, establecer el segundo como dual
    if (roles.length > 1) {
      const primary = result.role || roles[0];
      const secondary = roles.find((r) => r !== primary) as Role;

      if (secondary) {
        if (!result.role) result.role = primary as Role;
        result.dualRole = secondary;
      }
    } else if (roles.length === 1 && !result.role) {
      // Si solo hay un rol y no se ha establecido, usarlo como principal
      result.role = roles[0] as Role;
    }
  }

  // Si aún no se ha encontrado un rol, buscar en otros formatos
  if (!result.role) {
    // Último intento: buscar cualquier combinación de roles (ej: TH, HD, DT, etc.)
    const dualRoleMatch = trimmedNote.match(/\b([THD]{2,})\b/i);
    if (dualRoleMatch) {
      const rolesStr = dualRoleMatch[1].toUpperCase();
      result.role = rolesStr[0] as Role;
      if (rolesStr.length > 1 && rolesStr[1] !== rolesStr[0]) {
        result.dualRole = rolesStr[1] as Role;
      }
    }
  }

  if (!result.role) {
    missingFields.push(`Rol principal (${Object.keys(ROLES).join(', ')})`);
  }

  // 2. Extraer Gear Score - Múltiples formatos soportados:
  //    - Números de 4 dígitos (ej: 5585 -> 5.5)
  //    - Números decimales con punto o coma (ej: 5.9, 6,2)
  //    - Números después de rol (ej: d5.8, t6.2)
  //    - Números rodeados de cualquier carácter
  //    - Prefijos comunes como 'GS', 'gs', 'ilvl', 'iLvl', etc.
  let gsValue: string | null = null;

  // Patrón 1: Buscar formato XXXX (4 dígitos) en cualquier parte
  const fourDigitMatch = trimmedNote.match(/\b(\d{4})\b/);
  if (fourDigitMatch) {
    const num = parseInt(fourDigitMatch[1]);
    gsValue = (num / 1000).toFixed(1);
  }
  // Patrón 2: Buscar números decimales con punto o coma
  else {
    const decimalMatch = trimmedNote.match(/(\d[\.,]\d\d?)/);
    if (decimalMatch) {
      gsValue = decimalMatch[1].replace(',', '.');
    }
  }

  // Patrón 3: Buscar después de prefijos comunes (GS, ilvl, etc.)
  if (!gsValue) {
    const prefixMatch = trimmedNote.match(
      /(?:GS|gs|ilvl|iLvl|gear|Gear|gs:?\s*)(?:\s*[:=]?\s*)(\d[\.,]?\d?\d?)/i
    );
    if (prefixMatch) {
      gsValue = prefixMatch[1].replace(',', '.');
      // Asegurar formato decimal correcto
      if (!gsValue.includes('.')) {
        gsValue = gsValue + '.0';
      }
    }
  }

  // Validar y guardar el Gear Score encontrado
  if (gsValue) {
    const gsNumber = parseFloat(gsValue);
    if (!isNaN(gsNumber) && gsNumber >= 0.1 && gsNumber <= 10) {
      result.gearScore = gsNumber.toFixed(1);
    } else {
      errors.push('El Gear Score debe estar entre 0.1 y 10');
    }
  } else if (!trimmedNote.match(/GS|gs|ilvl|iLvl|gear|Gear|\d[\.,]\d|\d{4}/i)) {
    // Solo marcar como faltante si no hay ningún indicio de GS en la nota
    missingFields.push('Gear Score (ej: 5.9, 6.2, 5585)');
  }

  // 3. Extraer días de la semana (formato L-V, LMXJV, etc.)
  const dayPattern = /([LMXJVSD])(?:-([LMXJVSD]))?/g;
  const daysSet = new Set<string>();
  let dayMatch;

  while ((dayMatch = dayPattern.exec(trimmedNote)) !== null) {
    const startDay = dayMatch[1];
    const endDay = dayMatch[2];

    if (endDay) {
      // Es un rango de días (ej: L-V)
      const dayOrder = ['L', 'M', 'X', 'J', 'V', 'S', 'D'];
      const startIndex = dayOrder.indexOf(startDay);
      const endIndex = dayOrder.indexOf(endDay);

      if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {
        for (let i = startIndex; i <= endIndex; i++) {
          daysSet.add(dayOrder[i]);
        }
      } else {
        // Si el rango no es válido, agregar solo los días individuales
        daysSet.add(startDay);
        daysSet.add(endDay);
      }
    } else {
      // Es un día individual
      daysSet.add(startDay);
    }
  }

  // Convertir a array y ordenar según el orden de la semana
  const daysArray = Array.from(daysSet).sort((a, b) => {
    const order = { L: 1, M: 2, X: 3, J: 4, V: 5, S: 6, D: 7 };
    return (order[a as keyof typeof order] || 0) - (order[b as keyof typeof order] || 0);
  });

  // Agregar los días al resultado
  if (daysArray.length > 0) {
    result.days = daysArray;
  }

  // 4. Extraer Profesiones - Opcionales pero recomendadas
  const profCodes = Object.keys(PROFESSIONS);
  const profCodesStr = profCodes.join('|');

  const foundProfs = new Set<string>();

  // Caso especial para 'ALMN' (Alquimia + Minería)
  if (trimmedNote.includes('ALMN')) {
    foundProfs.add('AL');
    foundProfs.add('MN');
  } else {
    // Búsqueda normal de códigos de profesión
    const singleProfRegex = new RegExp(
      `(?:^|[^a-zA-Z])(${profCodesStr})(?![a-zA-Z])|(${profCodesStr})$`,
      'gi'
    );
    let singleMatch;

    singleProfRegex.lastIndex = 0;

    while ((singleMatch = singleProfRegex.exec(trimmedNote)) !== null) {
      const code = (singleMatch[1] || singleMatch[2]).toUpperCase() as ProfessionCode;

      if (profCodes.includes(code) && !foundProfs.has(code)) {
        foundProfs.add(code);
        if (foundProfs.size >= 2) break;
      }
    }
  }

  // Si no encontramos códigos individuales, buscar códigos juntos sin separador
  if (foundProfs.size < 2) {
    const combinedProfRegex = /[A-Z]{4,6}/g;
    let combinedMatch;

    while ((combinedMatch = combinedProfRegex.exec(trimmedNote.toUpperCase())) !== null) {
      const combinedText = combinedMatch[0];

      // Buscar códigos de profesión dentro del texto combinado
      let index = 0;
      while (index < combinedText.length) {
        let found = false;

        // Probar con códigos de 2 caracteres primero (más comunes)
        if (index + 2 <= combinedText.length) {
          const possibleCode = combinedText.substring(index, index + 2);
          if (profCodes.includes(possibleCode) && !foundProfs.has(possibleCode)) {
            foundProfs.add(possibleCode as ProfessionCode);
            index += 2;
            found = true;
          }
        }

        // Si no se encontró un código de 2 caracteres, probar con 3
        if (!found && index + 3 <= combinedText.length) {
          const possibleCode = combinedText.substring(index, index + 3);
          if (profCodes.includes(possibleCode) && !foundProfs.has(possibleCode)) {
            foundProfs.add(possibleCode as ProfessionCode);
            index += 3;
            found = true;
          }
        }

        // Si no se encontró ningún código, avanzar un carácter
        if (!found) {
          index++;
        }

        // No buscar más de 2 profesiones (máximo razonable)
        if (foundProfs.size >= 2) break;
      }

      // Si ya encontramos 2 profesiones, no es necesario seguir buscando
      if (foundProfs.size >= 2) break;
    }
  }

  // Si no encontramos códigos juntos, buscar otros patrones
  if (foundProfs.size < 2) {
    // Patrón 2: Buscar el patrón específico 'TL/en' o similar
    const directProfRegex = new RegExp(
      `(?:^|[^a-zA-Z])(${profCodesStr})[/,\s-](${profCodesStr})(?![a-zA-Z])`,
      'gi'
    );
    let directMatch;

    while ((directMatch = directProfRegex.exec(trimmedNote)) !== null) {
      const code1 = directMatch[1].toUpperCase() as ProfessionCode;
      const code2 = directMatch[2].toUpperCase() as ProfessionCode;
      if (profCodes.includes(code1)) foundProfs.add(code1);
      if (profCodes.includes(code2)) foundProfs.add(code2);
      if (foundProfs.size >= 2) break;
    }

    // Patrón 3: Buscar códigos individuales
    if (foundProfs.size < 2) {
      const singleProfRegex = new RegExp(`(?:^|[^a-zA-Z])(${profCodesStr})(?![a-zA-Z])`, 'gi');
      let singleMatch;

      while ((singleMatch = singleProfRegex.exec(trimmedNote)) !== null) {
        const code = singleMatch[1].toUpperCase() as ProfessionCode;
        if (profCodes.includes(code)) {
          foundProfs.add(code);
          if (foundProfs.size >= 2) break;
        }
      }
    }
  }

  // Si encontramos al menos una profesión, actualizar el resultado
  if (foundProfs.size > 0) {
    // Guardamos los códigos de profesión directamente
    result.professions = Array.from(foundProfs);

    // Si solo hay una profesión y es una abreviatura de 2 letras (ej: 'EN'), marcar como válido
    if (foundProfs.size === 1 && Array.from(foundProfs)[0].length === 2) {
      result.isValid = true;
    }
  }

  // La extracción de días ya se realizó anteriormente en la sección 3 del código
  // y ya está disponible en result.days

  // 5. Extraer horarios (pueden ser individuales o rangos con formato HHX-HHX)
  const uniqueHours = new Set<string>();

  // Primero buscamos rangos de días con horario (ej: L-V20:00x, L-V20:00, L-V20x, etc.)
  const dayRangeWithTimeRegex = /([LMXJVS])(?:-([LMXJVS]))?(\d{1,2}:?\d{0,2})X?/gi;
  let dayRangeMatch;

  // Buscar rangos de días con horario
  while ((dayRangeMatch = dayRangeWithTimeRegex.exec(trimmedNote)) !== null) {
    const startDay = dayRangeMatch[1];
    const endDay = dayRangeMatch[2] || startDay; // Si no hay día final, usamos el día inicial
    const timePart = dayRangeMatch[3] || '';

    // Formatear la hora correctamente
    let formattedTime = '';
    if (timePart.includes(':')) {
      const [hours, minutes = '00'] = timePart.split(':');
      formattedTime = `${hours.padStart(2, '0')}:${minutes.padEnd(2, '0')}`;
    } else if (timePart) {
      formattedTime = `${timePart.padStart(2, '0')}:00`;
    }

    if (formattedTime) {
      // Si hay un rango de días (ej: L-V)
      if (startDay && endDay && startDay !== endDay) {
        uniqueHours.add(`${startDay}-${endDay} ${formattedTime}`);
      } else {
        // Si es un solo día (ej: L20:00)
        uniqueHours.add(`${startDay} ${formattedTime}`);
      }
    }
  }

  // Luego buscamos rangos de horas (ej: 20X-23X, 20-23X, 20X-23, 20-23)
  const rangeRegex =
    /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X?\s*-\s*(\d{1,2})(?::(\d{2}))?X(?:$|[^\d])/gi;
  const rangeMatches = [];
  let rangeMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((rangeMatch = rangeRegex.exec(trimmedNote)) !== null) {
    rangeMatches.push(rangeMatch);
  }

  // Procesar rangos de horas (ej: 20X-23X, 20-23X, 20X-23, 20-23)
  rangeMatches.forEach((match) => {
    const startHour = parseInt(match[1], 10);
    const startMinutes = match[2] ? parseInt(match[2], 10) : 0;
    const endHour = parseInt(match[3], 10);
    const endMinutes = match[4] ? parseInt(match[4], 10) : 0;

    // Validar que las horas y minutos estén en rango
    if (
      startHour >= 0 &&
      startHour <= 23 &&
      endHour >= 0 &&
      endHour <= 23 &&
      startMinutes >= 0 &&
      startMinutes <= 59 &&
      endMinutes >= 0 &&
      endMinutes <= 59
    ) {
      const formattedStart = `${startHour.toString().padStart(2, '0')}${startMinutes > 0 ? ':' + startMinutes.toString().padStart(2, '0') : ''}X`;
      const formattedEnd = `${endHour.toString().padStart(2, '0')}${endMinutes > 0 ? ':' + endMinutes.toString().padStart(2, '0') : ''}X`;

      uniqueHours.add(formattedStart);
      uniqueHours.add(formattedEnd);
    }
  });

  // Luego buscamos horas individuales (que no sean parte de un rango)
  // Ahora detecta con o sin espacios alrededor de la X, pero evita falsos positivos
  const hourRegex = /(?:^|[^\d])(\d{1,2})(?::(\d{2}))?X(?:$|[^\d-])/gi;
  const hourMatches = [];
  let hourMatch;

  // Usamos un bucle para evitar problemas con el flag /g
  while ((hourMatch = hourRegex.exec(trimmedNote)) !== null) {
    hourMatches.push(hourMatch);
  }

  hourMatches.forEach((match) => {
    const hour = parseInt(match[1], 10);
    const minutes = match[2] ? parseInt(match[2], 10) : 0;

    if (hour >= 0 && hour <= 23 && minutes >= 0 && minutes <= 59) {
      const formattedHour = hour.toString().padStart(2, '0');
      const formattedMinutes = minutes > 0 ? `:${minutes.toString().padStart(2, '0')}` : '';
      uniqueHours.add(`${formattedHour}${formattedMinutes}X`);
    }
  });

  if (uniqueHours.size > 0) {
    result.schedules = Array.from(uniqueHours).sort();
  } else if (!trimmedNote.match(/\d{1,2}(?::\d{2})?X/)) {
    // Solo agregar el mensaje si no hay ningún formato de horario en la nota
    missingFields.push('Horario de conexión (ej: 18X, 21:30X)');
  }

  // 5. Extraer raids y dificultades por separado
  const allRaidCodes = Object.keys(RAID_NAMES) as RaidCode[];
  const raidCodesPattern = allRaidCodes
    .map((rc) => rc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join('|');

  // Inicializar el conjunto de raids encontradas
  result.raids = [];
  const usedRaids = new Set<string>();
  const usedIndices = new Set<string>();

  // 1. Buscar menciones directas de raids
  const raidPattern = new RegExp(`\\b(${raidCodesPattern})\\b`, 'gi');
  let raidMatch;

  while ((raidMatch = raidPattern.exec(trimmedNote)) !== null) {
    const raidCode = raidMatch[1].toUpperCase();

    if (raidCode in RAID_NAMES && !usedRaids.has(raidCode)) {
      result.raids.push({
        code: raidCode as RaidCode,
        difficultyCode: undefined, // Sin dificultad específica
        difficulty: undefined,
        name: RAID_NAMES[raidCode as RaidCode],
      });
      usedRaids.add(raidCode);
    }
  }

  // 2. Buscar dificultades (10n, 25h, etc.)
  const difficultyPattern = /\b(10|25)([hn])\b/gi;
  const foundDifficulties = new Set<string>();
  let diffMatch;

  while ((diffMatch = difficultyPattern.exec(trimmedNote)) !== null) {
    const number = diffMatch[1];
    const difficulty = diffMatch[2].toUpperCase() as 'N' | 'H';
    const difficultyCode = `${number}${difficulty}` as DifficultyCode;
    foundDifficulties.add(difficultyCode);
  }

  // Si no encontramos raids con los patrones anteriores, buscar solo los códigos de raid
  if (result.raids.length === 0) {
    const raidCodePattern = new RegExp(
      `(?:^|[^a-zA-Z])(${raidCodesPattern})(?=$|[^a-zA-Z0-9])`,
      'gi'
    );
    const raidCodeMatches = Array.from(trimmedNote.matchAll(raidCodePattern));

    for (const match of raidCodeMatches) {
      const raidCodeStr = match[0].toUpperCase();
      // Verificar que el código de raid sea uno de los permitidos
      const validRaidCodes: RaidCode[] = [
        'ICC',
        'TOC',
        'ULD',
        'NAX',
        'OS',
        'VOA',
        'EOE',
        'ONY',
        'RS',
      ];
      if (validRaidCodes.includes(raidCodeStr as RaidCode)) {
        const raidCode = raidCodeStr as RaidCode;
        if (!usedRaids.has(raidCode)) {
          // Buscar el raid en el array RAIDS
          const raidInfo = RAIDS.find((r) => r.code === raidCode);
          const raidName = raidInfo ? raidInfo.name : raidCode;

          const raidData: RaidInfo = {
            code: raidCode,
            difficulty: 'Normal', // Valor por defecto
            name: raidName,
            difficultyCode: '10N' as DifficultyCode, // Valor por defecto
            isRaidLeader: false, // Propiedad opcional
          };
          result.raids.push(raidData);
          usedRaids.add(raidCode);
        }
      }
    }
  }

  // Si no encontramos raids aún, intentar con un patrón más flexible
  if (result.raids.length === 0) {
    const escapedRaidCodes = allRaidCodes
      .map((raid) => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
      .join('|');
    const raidPatterns2 = [
      // Patrón para 'icc10n' o 'voa25h' (sin espacios)
      new RegExp(`(${escapedRaidCodes})(\\d+)([NH])`, 'gi'),
      // Patrón para 'icc 10n' o 'voa 25h' (con espacios)
      new RegExp(`(${escapedRaidCodes})\\s*(\\d+)([NH])`, 'gi'),
      // Patrón para solo el código de raid
      new RegExp(`\\b(${escapedRaidCodes})\\b`, 'gi'),
    ];

    for (const pattern of raidPatterns) {
      let match;
      while ((match = pattern.exec(trimmedNote)) !== null) {
        const raidCode = match[1]?.toUpperCase() as RaidCode;
        if (!raidCode) continue;

        // Type assertion to handle the indexing
        const raidName = raidCode in RAIDS ? RAIDS[raidCode as keyof typeof RAIDS] : raidCode;

        // Si es un patrón con dificultad (ej: 'icc10n' o 'icc 10n')
        if (match[2] && match[3]) {
          const difficultyNumber = match[2];
          const difficultyLetter = match[3].toUpperCase();
          const difficultyCode = `${difficultyNumber}${difficultyLetter}` as DifficultyCode;

          if (['10N', '10H', '25N', '25H'].includes(difficultyCode)) {
            const raidKey = `${raidCode}${difficultyCode}`;
            if (!usedRaids.has(raidKey)) {
              result.raids.push({
                code: raidCode,
                difficultyCode,
                difficulty: difficultyLetter === 'N' ? 'Normal' : 'Heroic',
                name: raidName,
              });
              usedRaids.add(raidKey);
            }
          }
        } else if (!usedRaids.has(raidCode)) {
          // Si es solo el código de raid sin dificultad
          result.raids.push({
            code: raidCode,
            difficultyCode: undefined,
            difficulty: undefined,
            name: raidName,
          });
          usedRaids.add(raidCode);
        }

        if (match.index === pattern.lastIndex) {
          pattern.lastIndex++; // Evitar bucle infinito
        }
      }
    }
  }

  // Verificar si faltan raids o su dificultad (solo como advertencia, no invalida)
  if (result.raids.length === 0) {
    // Verificar si hay algún código de raid sin dificultad
    const raidPatterns = [
      // Patrones para detectar menciones de raid con o sin dificultad
      new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodesPattern})(?![a-z0-9])(?:$|\\s|\\)|\\]|\/)`, 'i'),
      new RegExp(`(${raidCodesPattern})\\s*\\d+[NH]`, 'i'),
      new RegExp(`(${raidCodesPattern})\\d+[NH]`, 'i'),
      new RegExp(`(10|25)[NH](${raidCodesPattern})`, 'i'), // Para formato 10Nicc, 25Hvoa
    ];

    const hasAnyRaidMention = raidPatterns.some((pattern) => pattern.test(trimmedNote));
    const hasRaidWithDifficulty = new RegExp(
      `(?:${raidCodesPattern})(?:\\s*\\d+[NH]|\\d+[NH]|(?:10|25)[NH](?=${raidCodesPattern}))`,
      'i'
    ).test(trimmedNote);

    if (hasAnyRaidMention && !hasRaidWithDifficulty) {
      // Solo agregar el mensaje de dificultad faltante si no está ya en el array
      if (!missingFields.some((mf) => mf.includes('Dificultad'))) {
        missingFields.push('Dificultad (ej: 10N, 25H)');
      }
    } else if (!hasAnyRaidMention) {
      // Verificar si hay menciones de raid en el texto sin formato específico
      const raidMentionPattern = new RegExp(
        `(?:^|\\s|\\(|\\[)(${allRaidCodes.join('|')})(?=$|[^a-zA-Z0-9])`,
        'i'
      );
      if (!raidMentionPattern.test(trimmedNote)) {
        missingFields.push('Raids que busca/arma (ej: ICC, TOC)');
      }
    }
  } else if (result.raids.some((raid) => !raid.difficultyCode)) {
    // Verificar si hay alguna mención de dificultad en la nota
    const hasDifficultyMention = /(?:^|\s)(\d+[NH])(?:\s|$)/i.test(trimmedNote);
    if (!hasDifficultyMention && !missingFields.some((mf) => mf.includes('Dificultad'))) {
      missingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 6. Verificar campos faltantes en el orden especificado
  const orderedMissingFields: string[] = [];

  // 1. Main/Alt
  if (!result.mainAlt) {
    orderedMissingFields.push('Main/Alt (M/A)');
  }

  // 2. Rol principal
  if (!result.role) {
    orderedMissingFields.push('Rol (T/H/D)');
  }

  // 3. Dual - Solo mostrar si no se ha detectado un rol dual
  if (!result.dualRole) {
    orderedMissingFields.push('Dual (T/H/D)');
  }

  // 4. Gear Score
  if (!result.gearScore) {
    orderedMissingFields.push('Gear Score (ej: 6.2)');
  }

  // 5. Profesiones
  if (!result.professions || result.professions.length === 0) {
    orderedMissingFields.push('Profesiones (ej: JC/BS)');
  }

  // 6. Horario de juego
  if (!result.schedules || result.schedules.length === 0) {
    orderedMissingFields.push('Horario de juego (ej: 18X, 21:30X)');
  }

  // 7. Verificar raids en la nota
  const raidCodes = Object.keys(RAID_NAMES)
    .map((raid) => raid.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
    .join('|');

  // Buscar cualquier mención de raid, con o sin dificultad
  const raidSearchPattern = new RegExp(
    `(?:^|\\s|\\(|\\[)(${raidCodes})(?![a-z0-9])(?:$|\\s|\\)|\\]|\\/|\\d|\\s*\\d*[NH])`,
    'i'
  );
  const hasAnyRaid = raidSearchPattern.test(trimmedNote);

  // Buscar específicamente patrones como 'icc10n' o 'voa25h'
  const raidWithNumberPattern = new RegExp(`(?:^|\\s|\\(|\\[)(${raidCodes})\\s*\\d+[NH]`, 'i');
  const hasAnyRaidWithNumber = raidWithNumberPattern.test(trimmedNote);

  if (!hasAnyRaid && !hasAnyRaidWithNumber) {
    orderedMissingFields.push('Raids que busca (ej: ICC 25H)');
  } else if (!result.raids || result.raids.length === 0) {
    // Si no se detectaron raids pero hay menciones de raids con números, asumir que el formato es correcto
    if (!hasAnyRaidWithNumber) {
      orderedMissingFields.push('Formato de raid (ej: ICC 25H)');
    }
  } else {
    // Verificar dificultad para cada raid
    const raidsWithoutDifficulty = result.raids.filter((raid) => !raid.difficultyCode);
    if (raidsWithoutDifficulty.length > 0 && !hasAnyRaidWithNumber) {
      orderedMissingFields.push('Dificultad (ej: 10N, 25H)');
    }
  }

  // 8. Raid Leader (opcional, solo si se especifica RL pero no está marcado)
  const hasRLNotation = /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl|\d*[xX]\s*rl)\b/i.test(
    trimmedNote
  );
  if (hasRLNotation && !result.isRaidLeader) {
    // Verificar si el formato es válido pero no se pudo marcar
    orderedMissingFields.push(
      'RaidLeader (RL) - Verificar formato (ej: RL, rl, RaidLeader, 18xrl)'
    );
  }

  // 2. Rol principal
  if (!result.role) {
    orderedMissingFields.push('Rol (T/H/D)');
  }

  // 3. Dual - Solo mostrar si no se ha detectado un rol dual
  if (!result.dualRole) {
    orderedMissingFields.push('Dual (T/H/D)');
  }

  // 4. Gear Score
  if (!result.gearScore) {
    orderedMissingFields.push('Gear Score (ej: 6.2)');
  }

  // 5. Profesiones
  if (!result.professions || result.professions.length === 0) {
    orderedMissingFields.push('Profesiones (ej: JC/BS)');
  }

  // 6. Horario de juego
  if (!result.schedules || result.schedules.length === 0) {
    orderedMissingFields.push('Horario de juego (ej: 18X, 21:30X)');
  }

  // 8. Raid Leader (opcional, solo si se especifica RL pero no está marcado)
  const hasRLNotationFlag =
    /(?:^|\s)(?:RL|Raid[\s-]?Leader|raid[\s-]?leader|rl|\d*[xX]\s*rl)\b/i.test(trimmedNote);
  if (hasRLNotationFlag && !result.isRaidLeader) {
    // Verificar si el formato es válido pero no se pudo marcar
    orderedMissingFields.push(
      'RaidLeader (RL) - Verificar formato (ej: RL, rl, RaidLeader, 18xrl)'
    );
  }

  // Agregar cualquier otro campo faltante que no esté en la lista ordenada
  const otherMissingFields = missingFields.filter(
    (field: string) =>
      !orderedMissingFields.some((omf: string) => field.includes(omf.split(' ')[0]))
  );

  // Combinar los campos ordenados con los demás campos faltantes
  const allMissingFields = [...orderedMissingFields, ...otherMissingFields];
  const missingFieldsSet = new Set(allMissingFields);

  // Actualizar el array de missingFields
  result.missingFields = Array.from(missingFieldsSet);

  // Determinar si la nota es válida
  // Verificar si es un formato simple (MT, MTH, MD, etc.)
  const isSimpleFormat =
    /^[MA]?[THD]+$/i.test(trimmedNote) ||
    /^[MA]$/i.test(trimmedNote) ||
    /^[MA][THD]$/i.test(trimmedNote) ||
    /^[THD][MA]$/i.test(trimmedNote) ||
    /^[THD]$/i.test(trimmedNote) ||
    /^[MA]\d+\.?\d*[THD]?$/i.test(trimmedNote) ||
    /^[MA]\d+\.?\d*[A-Za-z]+$/i.test(trimmedNote);

  // Debug: Log simple format detection
  console.group('Simple format detection');
  console.log('Note:', trimmedNote);
  console.log('Is simple format:', isSimpleFormat);
  if (isSimpleFormat) {
    console.log('Matched as simple format');
  } else {
    console.log('Did not match any simple format pattern');
  }
  console.groupEnd();
  // 4. Tiene profesiones
  // 5. Tiene raids
  // 6. Tiene un gear score
  // 7. Es solo 'A' o 'M' (main/alt sin rol)
  const hasAnyValidField =
    isSimpleFormat ||
    result.role !== undefined ||
    result.mainAlt !== undefined ||
    (result.professions && result.professions.length > 0) ||
    (result.raids && result.raids.length > 0) ||
    (result.schedules && result.schedules.length > 0) ||
    (result.gearScore !== undefined && result.gearScore !== null) ||
    /^[MA]$/i.test(trimmedNote);

  // Debug: Log validation criteria
  console.group('Validation criteria');
  console.log('isSimpleFormat:', isSimpleFormat);
  console.log('result.role:', result.role);
  console.log('result.mainAlt:', result.mainAlt);
  console.log('result.professions:', result.professions);
  console.log('result.raids:', result.raids);
  console.log('result.schedules:', result.schedules);
  console.log('result.gearScore:', result.gearScore);
  console.log("Matches 'A' or 'M':", /^[MA]$/i.test(trimmedNote));
  console.log('hasAnyValidField:', hasAnyValidField);
  console.groupEnd();

  // Establecer el estado de validación
  result.isValid = hasAnyValidField;

  // Si no es válido, agregar un mensaje de error
  if (!result.isValid) {
    errors.push('Formato inválido - No se detectaron campos válidos');
  } else {
    // Limpiar errores si la nota es válida
    errors.length = 0;
  }

  // Asegurarse de que los campos principales estén definidos para formatos simples
  if (isSimpleFormat) {
    // Extraer main/alt si está presente
    const mainAltMatch = trimmedNote.match(/^([MA])/i);
    if (mainAltMatch && !result.mainAlt) {
      result.mainAlt = mainAltMatch[1].toUpperCase() as MainAlt;
    }

    // Extraer rol si está presente
    const roleMatch = trimmedNote.match(/[THD]$/i) || trimmedNote.match(/^[THD]/i);
    if (roleMatch && !result.role) {
      result.role = roleMatch[0].toUpperCase() as Role;
    }

    // Extraer gear score si está presente (formato como AT5.9, ad5.5, etc.)
    const gsMatch = trimmedNote.match(/[MA](\d+(?:\.\d+)?)/i);
    if (gsMatch && !result.gearScore) {
      result.gearScore = parseFloat(gsMatch[1]);
    }

    // Extraer profesiones si están presentes (letras mayúsculas después del gear score)
    const profMatch = trimmedNote.match(/[MA]\d*(?:\.\d+)?([A-Z]{2,})/i);
    if (profMatch && (!result.professions || result.professions.length === 0)) {
      const profs = profMatch[1].match(/[A-Z]{2}/g) || [];
      result.professions = profs.map((p) => p.toUpperCase() as ProfessionCode);
    }
  }

  // Si hay errores, agregarlos al resultado
  if (errors.length > 0) {
    result.error = errors.join('; ');
  }

  // Si faltan campos, agregarlos al resultado
  if (missingFields.length > 0) {
    result.missingFields = [...new Set(missingFields)]; // Eliminar duplicados
  }

  // Procesar bloques de personaje
  if (result.mainAlt || result.role || result.gearScore) {
    result.blocks = result.blocks || [];

    // Asegurarnos de que los valores requeridos no sean undefined
    const mainAlt = result.mainAlt || 'M'; // Valor por defecto 'M' si no está definido
    const mainRole = result.role || 'D'; // Valor por defecto 'D' si no está definido
    const gearScore = result.gearScore ? Number(result.gearScore) : 0;

    // Crear bloque de personaje con tipos seguros
    const characterData = {
      type: 'character' as const,
      content: '',
      isValid: true,
      parsedData: {
        mainAlt: mainAlt as MainAlt,
        mainRole: mainRole as Role,
        dualRole: result.dualRole as Role | undefined,
        mainGearScore: gearScore,
        professions: (result.professions || []) as ProfessionCode[],
        dualGearScore: undefined,
      },
    };

    result.blocks.push(characterData);
  }

  // Procesar bloques de evento
  if (result.raids && result.raids.length > 0) {
    result.blocks = result.blocks || [];

    result.raids.forEach((raid) => {
      // Crear bloque de evento con valores por defecto
      const eventData = {
        type: 'event' as const,
        content: '',
        isValid: true,
        parsedData: {
          days: [] as string[],
          dayRange: '',
          time: '',
          raid: raid.code as RaidCode,
          difficulty: raid.difficultyCode as DifficultyCode,
          isRaidLeader: false,
          isLookingForGroup: false,
        },
      };

      // Si hay información de horario, intentar extraer días y hora
      if (result.schedules && result.schedules.length > 0) {
        const schedule = result.schedules[0];
        // Verificar si el horario incluye un rango de días (ej: L-V 20:00)
        const dayRangeMatch = String(schedule).match(
          /^([LMXJVS])-([LMXJVS])\s+(\d{1,2}:?\d{0,2})/i
        );
        const singleDayMatch = String(schedule).match(/^([LMXJVS])\s+(\d{1,2}:?\d{0,2})/i);

        if (dayRangeMatch) {
          // Formato: L-V 20:00
          const [, startDay, endDay, timePart] = dayRangeMatch;
          eventData.parsedData.dayRange = `${startDay}-${endDay}`;
          eventData.parsedData.time = timePart.includes(':') ? timePart : `${timePart}:00`;
        } else if (singleDayMatch) {
          // Formato: L 20:00
          const [, day, timePart] = singleDayMatch;
          eventData.parsedData.days = [day];
          eventData.parsedData.time = timePart.includes(':') ? timePart : `${timePart}:00`;
        } else if (schedule) {
          // Formato antiguo o diferente
          eventData.parsedData.time = String(schedule);
        }
      }

      // Verificar si es raid leader (RL al inicio del código de raid)
      if (raid.code && String(raid.code).startsWith('RL')) {
        eventData.parsedData.isRaidLeader = true;
        eventData.parsedData.raid = String(raid.code).substring(2) as RaidCode;
      }

      result.blocks.push(eventData);
    });
  }

  // Asegurar que los campos principales estén definidos
  const finalResult = {
    ...result,
    // Asegurar que mainRole esté definido para compatibilidad
    mainRole: result.role,
    // Asegurar que los campos principales tengan valores por defecto si faltan
    mainAlt: result.mainAlt || 'M',
    role: result.role || 'D',
    // Limpiar campos faltantes si es válido
    missingFields: result.isValid ? [] : result.missingFields,
    // Asegurar que los arrays estén definidos
    professions: result.professions || [],
    schedules: result.schedules || [],
    raids: result.raids || [],
    // Depuración
    _debug: {
      originalNote: note,
      trimmedNote,
      isValid: result.isValid,
    },
  };

  // Debug logging for validation results
  console.group(`Validation for note: "${note}"`);
  console.log('Trimmed note:', trimmedNote);
  console.log('Is simple format:', isSimpleFormat);
  console.log('Has any valid field:', hasAnyValidField);
  console.log('Main/Alt:', result.mainAlt);
  console.log('Role:', result.role);
  console.log('Gear Score:', result.gearScore);
  console.log('Professions:', result.professions);
  console.log('Raids:', result.raids);
  console.log('Schedules:', result.schedules);
  console.log('Is valid:', finalResult.isValid);
  console.log('Errors:', errors);
  console.log('Missing fields:', finalResult.missingFields);
  console.log('Full validation result:', finalResult);
  console.groupEnd();

  return finalResult;
}

// Mapa de colores y nombres de profesión
const PROFESSION_INFO = {
  JC: {
    name: 'Joyería',
    colors: { light: '#fde047', dark: '#d97706' },
  },
  BS: {
    name: 'Herrería',
    colors: { light: '#60a5fa', dark: '#1d4ed8' },
  },
  EN: {
    name: 'Encantamiento',
    colors: { light: '#c084fc', dark: '#7e22ce' },
  },
  EG: {
    name: 'Ingeniería',
    colors: { light: '#2dd4bf', dark: '#0d9488' },
  },
  AL: {
    name: 'Alquimia',
    colors: { light: '#4ade80', dark: '#15803d' },
  },
  TL: {
    name: 'Sastrería',
    colors: { light: '#f472b6', dark: '#db2777' },
  },
  IN: {
    name: 'Inscripción',
    colors: { light: '#818cf8', dark: '#4f46e5' },
  },
  HB: {
    name: 'Herboristería',
    colors: { light: '#84cc16', dark: '#65a30d' },
  },
  LW: {
    name: 'Peletería',
    colors: { light: '#f59e0b', dark: '#d97706' },
  },
  MN: {
    name: 'Minería',
    colors: { light: '#f97316', dark: '#c2410c' },
  },
  SK: {
    name: 'Desuello',
    colors: { light: '#f43f5e', dark: '#be123c' },
  },
} as const;

// Función para obtener el nombre del rol
const getRoleName = (role: string): string => {
  const roleNames: Record<string, string> = {
    T: 'Tanque',
    H: 'Sanador',
    D: 'DPS',
    M: 'Melee',
    R: 'Rango',
  };
  return roleNames[role] || role;
};

// Función para obtener la clase de color según el rol
const getRoleColorClass = (role: string): string => {
  const roleColors: Record<string, string> = {
    T: 'bg-blue-500/20 border-blue-500/50',
    H: 'bg-green-500/20 border-green-500/50',
    D: 'bg-red-500/20 border-red-500/50',
    M: 'bg-purple-500/20 border-purple-500/50',
    R: 'bg-yellow-500/20 border-yellow-500/50',
  };
  return roleColors[role] || 'bg-gray-500/20 border-gray-500/50';
};

// Mapeo de nombres de roles para el cliente
const roleNames = {
  T: { name: 'Tanque' },
  H: { name: 'Sanador' },
  D: { name: 'DPS' },
};

// Mapeo de nombres de profesiones para mostrar
const professionNames: Record<ProfessionCode, { name: string; color: string; bgColor: string }> = {
  AL: { name: 'Alquimia', color: 'text-blue-300', bgColor: 'bg-blue-500/20' },
  HB: { name: 'Herboristería', color: 'text-green-300', bgColor: 'bg-green-500/20' },
  TL: { name: 'Sastrería', color: 'text-amber-300', bgColor: 'bg-amber-500/20' },
  EN: { name: 'Encantamiento', color: 'text-purple-300', bgColor: 'bg-purple-500/20' },
  EG: { name: 'Ingeniería', color: 'text-orange-300', bgColor: 'bg-orange-500/20' },
  JC: { name: 'Joyería', color: 'text-yellow-300', bgColor: 'bg-yellow-500/20' },
  BS: { name: 'Herrería', color: 'text-gray-300', bgColor: 'bg-gray-500/20' },
  IN: { name: 'Inscripción', color: 'text-pink-300', bgColor: 'bg-pink-500/20' },
  MN: { name: 'Minería', color: 'text-gray-400', bgColor: 'bg-gray-600/20' },
  SK: { name: 'Desuello', color: 'text-red-200', bgColor: 'bg-red-700/20' },
  LW: { name: 'Peletería', color: 'text-amber-200', bgColor: 'bg-amber-700/20' },
};

// Mapeo de profesiones a nombres completos y colores
const professionInfo: Record<ProfessionCode, { name: string; color: string; bgColor: string }> = {
  JC: { name: 'Joyería', color: 'text-yellow-300', bgColor: 'bg-yellow-500/20' },
  BS: { name: 'Herrería', color: 'text-gray-300', bgColor: 'bg-gray-500/20' },
  EN: { name: 'Encantamiento', color: 'text-purple-300', bgColor: 'bg-purple-500/20' },
  EG: { name: 'Ingeniería', color: 'text-blue-200', bgColor: 'bg-blue-500/20' },
  AL: { name: 'Alquimia', color: 'text-green-200', bgColor: 'bg-green-500/20' },
  TL: { name: 'Trabajo del Cuero', color: 'text-amber-300', bgColor: 'bg-amber-500/20' },
  IN: { name: 'Sastrería', color: 'text-pink-300', bgColor: 'bg-pink-500/20' },
  HB: { name: 'Herboristería', color: 'text-lime-300', bgColor: 'bg-lime-500/20' },
  MN: { name: 'Minería', color: 'text-gray-400', bgColor: 'bg-gray-600/20' },
  SK: { name: 'Desuello', color: 'text-red-200', bgColor: 'bg-red-700/20' },
  LW: { name: 'Peletería', color: 'text-amber-200', bgColor: 'bg-amber-700/20' },
} as const;

// roleStats ya está definido más arriba en el código
// Usar roleDistribution para obtener los conteos de roles duales
// dualRoleStats ya está definido arriba en el código

// Variable para compatibilidad con código existente que espera un array
const sortedDualRoles = [
  {
    combo: 'TH',
    label: 'Tank / Heal',
    count: dualRoleStats.TH,
    color: 'bg-blue-400/20',
    textColor: 'text-blue-400',
  },
  {
    combo: 'TD',
    label: 'Tank / DPS',
    count: dualRoleStats.TD,
    color: 'bg-purple-400/20',
    textColor: 'text-purple-400',
  },
  {
    combo: 'HD',
    label: 'Heal / DPS',
    count: dualRoleStats.HD,
    color: 'bg-green-400/20',
    textColor: 'text-green-400',
  },
].sort((a, b) => b.count - a.count);

// Calcular estadísticas de mains/alts
const mainAltStats = rosterData.members.reduce(
  (acc, member) => {
    const validation = member.noteValidation;
    if (validation?.isValid) {
      // Usar 'A' (Alt) como valor predeterminado si no se especifica mainAlt
      const mainAlt = validation.mainAlt || 'A';
      acc[mainAlt] = (acc[mainAlt] || 0) + 1;
    } else {
      // Si la validación no es válida, contar como Alt
      acc['A'] = (acc['A'] || 0) + 1;
    }
    return acc;
  },
  { M: 0, A: 0 } as Record<MainAlt, number>
);

// Usamos gearScoreStats ya definido anteriormente

// Contar líderes de raid
const raidLeaderCount = rosterData.members.filter(
  (member) => member.noteValidation?.isRaidLeader
).length;

// Obtener lista de rangos únicos
const ranks = [...new Set(rosterData.members.map((member) => member.rank))].sort();

// Obtener lista de clases únicas
const rosterClassInfo = rosterData?.classInfo || {};
const classList = Object.keys(rosterClassInfo) as ClassName[];

// Función para determinar la prioridad del rango
const getRankPriority = (rank: string): number => {
  const rankLower = rank.toLowerCase();
  if (rankLower.includes('guild master')) return 0;
  if (rankLower.includes('alter')) return 1;
  if (rankLower.includes('oficial')) return 2;
  if (rankLower.includes('explorador')) return 3;
  if (rankLower.includes('iniciado')) return 4;
  if (rankLower.includes('aspirante')) return 5;
  return 6;
};

// Ordenar miembros
const sortedMembers = [...rosterData.members].sort((a, b) => {
  // Primero ordenar por prioridad de rango
  const priorityA = getRankPriority(a.rank);
  const priorityB = getRankPriority(b.rank);

  if (priorityA !== priorityB) {
    return priorityA - priorityB;
  }

  // Si tienen la misma prioridad, ordenar alfabéticamente
  return a.name.localeCompare(b.name);
});

// Datos para el cliente - Usamos los miembros ya ordenados
const rosterClientData: RosterData = {
  ...rosterData,
  members: sortedMembers as RosterMemberType[],
  classes: Object.keys(rosterData.classInfo || {}),
};

// Definir tipos para las distribuciones
interface DistributionItem {
  name: string;
  count: number;
  percentage?: number;
  color?: string;
}

interface RoleDistributionItem extends DistributionItem {
  role: string;
}

type MainAltType = 'M' | 'A';
interface MainAltDistribution {
  M: number;
  A: number;
}

interface ClassDistributionItem extends DistributionItem {
  color: string;
}

interface MainAltDistributionItem extends DistributionItem {
  type: 'M' | 'A';
}

// Función para calcular la distribución por rango
function calculateRankDistribution(
  members: any[] = []
): Array<{ name: string; count: number; percentage: number }> {
  if (!members || !Array.isArray(members)) {
    return [];
  }
  const totalMembers = members.length;
  if (totalMembers === 0) return [];
  const rankCounts = members.reduce((acc: Record<string, number>, member) => {
    acc[member.rank] = (acc[member.rank] || 0) + 1;
    return acc;
  }, {});

  // Definir el orden de los rangos
  const rankOrder = ['Aspirante', 'Iniciado', 'Explorador', 'Oficial', 'Alter', 'Guild Master'];

  // Calcular porcentajes y redondear a 1 decimal
  return Object.entries(rankCounts)
    .map(([name, count]) => ({
      name,
      count: count as number,
      percentage:
        totalMembers > 0 ? Math.round(((count as number) / totalMembers) * 100 * 10) / 10 : 0,
      order: rankOrder.indexOf(name) === -1 ? 999 : rankOrder.indexOf(name), // Asignar un orden alto si el rango no está en la lista
    }))
    .sort((a, b) => a.order - b.order) // Ordenar por el orden definido
    .map(({ name, count, percentage }) => ({
      name,
      count,
      percentage,
    }));
}

// Función para calcular la distribución por clase
function calculateClassDistribution(
  members: any[] = [],
  classInfo: any = {}
): ClassDistributionItem[] {
  if (!Array.isArray(members) || !classInfo) {
    return [];
  }

  const classCounts = members.reduce((acc: Record<string, number>, member) => {
    if (member && member.class) {
      acc[member.class] = (acc[member.class] || 0) + 1;
    }
    return acc;
  }, {});

  return Object.entries(classCounts)
    .filter(([className]) => className && classInfo[className])
    .map(([className, count]) => ({
      name: className,
      count: count as number,
      color: classInfo[className].color || 'FFFFFF',
    }));
}

// Calcular distribuciones
const rankDistribution = calculateRankDistribution(rosterData.members);
const classDistribution = calculateClassDistribution(rosterData.members, rosterData.classInfo);

// Calcular estadísticas del formato de notas
// Usando el stats ya definido anteriormente

// Calcular porcentajes para las distribuciones
const mainAltDistribution: MainAltDistributionItem[] = [
  { type: 'M', name: 'Main', count: mainAltStats.M, percentage: getRolePercentage(mainAltStats.M) },
  { type: 'A', name: 'Alt', count: mainAltStats.A, percentage: getRolePercentage(mainAltStats.A) },
];

// Usar gearScoreStats ya definido al inicio del archivo
const gearScorePercentage =
  gearScoreStats.avg > 0 ? Math.min(100, Math.max(0, (gearScoreStats.avg / 6.8) * 100)) : 0;

// Usar validNotesCount ya calculado anteriormente

// La función getRankPriority y sortedMembers han sido movidas arriba para la inicialización

// Use the sorted members as the base for filtered members
const filteredMembers = [...sortedMembers];
const totalRaiders = rosterData.members.filter(
  (m) =>
    m.rank.toLowerCase().includes('élite') ||
    m.rank.toLowerCase().includes('alter') ||
    m.rank.toLowerCase().includes('comandante') ||
    m.rank.toLowerCase().includes('guild master')
).length;

// rosterClientData is already defined above with the sorted members
---

<div class="space-y-6">
  <style>
    /* Estilos para los tooltips */
    .tooltip-container {
      position: relative;
      display: inline-block;
    }

    .tooltip-container:hover .tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .tooltip {
      transform: translateY(-5px);
      transition: all 0.2s ease-in-out;
      box-shadow:
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    /* Estilos para los dropdowns */
    select option {
      background-color: #1a202c; /* Fondo oscuro */
      color: #e2e8f0; /* Texto claro */
      padding: 0.5rem;
    }

    select:focus option:checked {
      background-color: #4a5568; /* Color de fondo para la opción seleccionada */
      color: white;
    }

    /* Estilo para el hover en las opciones */
    select option:hover {
      background-color: #4a5568 !important;
    }
  </style>
  <!-- Script del cliente con la lógica de JavaScript -->
  <script
    define:vars={{
      rosterData: JSON.stringify(rosterClientData),
      roleNames: JSON.stringify(roleNames),
      professionNames: JSON.stringify(professionNames),
    }}
  >
    // Analizar los datos del roster
    const rosterInfo = JSON.parse(rosterData);
    const roleNamesData = JSON.parse(roleNames);
    const professionNamesData = JSON.parse(professionNames);

    // Función para inicializar tooltips
    function initTooltips() {
      document.querySelectorAll('.tooltip-container').forEach((container) => {
        const tooltip = container.querySelector('.tooltip');
        if (!tooltip) return;

        // Posicionamiento del tooltip
        const updatePosition = () => {
          const rect = container.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();

          // Centrar horizontalmente
          const left = rect.left + rect.width / 2 - tooltipRect.width / 2;

          // Ajustar para que no se salga de la pantalla
          const adjustedLeft = Math.max(
            10,
            Math.min(window.innerWidth - tooltipRect.width - 10, left)
          );

          tooltip.style.left = `${adjustedLeft}px`;
        };

        // Actualizar posición al mostrar
        container.addEventListener('mouseenter', updatePosition);

        // Actualizar posición al redimensionar
        window.addEventListener('resize', updatePosition);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Inicializar tooltips después de cargar la tabla
      initTooltips();

      // Obtener elementos del DOM
      const searchInput = document.getElementById('search');
      const classFilter = document.getElementById('class-filter');
      const rankFilter = document.getElementById('rank-filter');
      const rosterGrid = document.getElementById('roster-grid');
      const prevButton = document.getElementById('prev-button');
      const nextButton = document.getElementById('next-button');
      const pageInfo = document.getElementById('page-info');
      const sortButtons = document.querySelectorAll('.sort-button');

      let currentPage = 1;
      let itemsPerPage = 6; // Will be updated based on screen size
      let allMembers = [];
      let filteredMembers = [];
      let sortConfig = { key: 'name', direction: 'asc' };
      
      // Function to update items per page based on screen size
      function updateItemsPerPage() {
        itemsPerPage = window.innerWidth < 768 ? 3 : 9; // 3 for mobile, 9 for desktop
        updateTable();
        updatePaginationInfo();
      }
      
      // Initial update and add resize listener
      updateItemsPerPage();
      window.addEventListener('resize', updateItemsPerPage);

      // Funciones de utilidad para formatear
      const formatTime = (timeStr) => {
        if (!timeStr) return '';
        return timeStr.includes(':') ? timeStr : `${timeStr}:00`;
      };

      // Inicializar la tabla con los datos
      function initTable() {
        if (!rosterGrid || !pageInfo) {
          return;
        }

        // Use the pre-sorted members from the server
        allMembers = [...rosterInfo.members];

        // Función de ordenamiento
        const sortMembers = () => {
          allMembers.sort((a, b) => {
            let valA, valB;

            if (sortConfig.key === 'name') {
              // Ordenar por nombre y prioridad de rango
              const getRankPriority = (rank) => {
                const rankLower = rank?.toLowerCase() || '';
                if (rankLower.includes('guild master')) return 0;
                if (rankLower.includes('alter')) return 1;
                if (rankLower.includes('oficial')) return 2;
                if (rankLower.includes('explorador')) return 3;
                if (rankLower.includes('iniciado')) return 4;
                if (rankLower.includes('aspirante')) return 5;
                return 6;
              };

              const priorityA = getRankPriority(a.rank);
              const priorityB = getRankPriority(b.rank);

              if (priorityA !== priorityB) {
                return sortConfig.direction === 'asc'
                  ? priorityA - priorityB
                  : priorityB - priorityA;
              }
              valA = (a.name || '').toLowerCase();
              valB = (b.name || '').toLowerCase();
            } else {
              // Ordenar por detalles (longitud de la nota o presencia de nota)
              valA = (a.publicNote || '').length;
              valB = (b.publicNote || '').length;
            }

            if (valA < valB) return sortConfig.direction === 'asc' ? -1 : 1;
            if (valA > valB) return sortConfig.direction === 'asc' ? 1 : -1;
            return 0;
          });

          // Aplicar filtros después de ordenar
          filterMembers();
        };

        // Event listeners para botones de ordenamiento
        sortButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const sortKey = button.dataset.sort;

            // Actualizar configuración de ordenamiento
            if (sortConfig.key === sortKey) {
              sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
            } else {
              sortConfig.key = sortKey;
              sortConfig.direction = 'asc';
            }

            // Actualizar estilos de botones
            sortButtons.forEach((btn) => {
              btn.classList.remove('bg-amber-900/50', 'border-amber-500/50');
              btn.classList.add('bg-gray-800/50', 'border-amber-900/30');
              const indicator = btn.querySelector('.sort-indicator');
              if (indicator) {
                indicator.textContent = '↕';
                indicator.classList.add('opacity-50');
              }
            });

            button.classList.remove('bg-gray-800/50', 'border-amber-900/30');
            button.classList.add('bg-amber-900/50', 'border-amber-500/50');
            const indicator = button.querySelector('.sort-indicator');
            if (indicator) {
              indicator.textContent = sortConfig.direction === 'asc' ? '↑' : '↓';
              indicator.classList.remove('opacity-50');
            }

            // Re-ordenar y actualizar
            sortMembers();
            updateTable();
            updatePaginationInfo();
          });
        });

        // Función para filtrar miembros
        const filterMembers = () => {
          const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
          const selectedClass = classFilter ? classFilter.value : '';
          const selectedRank = rankFilter ? rankFilter.value : '';

          filteredMembers = allMembers.filter((member) => {
            const matchesSearch = member.name.toLowerCase().includes(searchTerm);
            const matchesClass = selectedClass === '' || member.class === selectedClass;
            const matchesRank = selectedRank === '' || member.rank === selectedRank;
            return matchesSearch && matchesClass && matchesRank;
          });

          currentPage = 1; // Resetear a la primera página al filtrar
        };

        // Event listeners para filtros
        if (searchInput) {
          searchInput.addEventListener('input', () => {
            filterMembers();
            updateTable();
            updatePaginationInfo();
          });
        }
        if (classFilter) {
          classFilter.addEventListener('change', () => {
            filterMembers();
            updateTable();
            updatePaginationInfo();
          });
        }
        if (rankFilter) {
          rankFilter.addEventListener('change', () => {
            filterMembers();
            updateTable();
            updatePaginationInfo();
          });
        }

        // Inicializar
        sortMembers();
        updateTable();
        updatePaginationInfo();
      }

      // Actualizar la tabla (ahora grid) con los miembros filtrados y ordenados
      function updateTable() {
        if (!rosterGrid) return;

        const startIndex = (currentPage - 1) * itemsPerPage;
        const paginatedMembers = filteredMembers.slice(startIndex, startIndex + itemsPerPage);

        rosterGrid.innerHTML = paginatedMembers
          .map((member) => {
            const classData = rosterInfo.classInfo[member.class] || {
              color: 'FFFFFF',
              name: member.class,
            };
            const className = classData.name;
            const classColor = classData.color;

            // Procesar información de la nota
            let formattedInfo = [];

            if (member.publicNote) {
              const validation = member.noteValidation;
              if (validation?.isValid) {
                // 1. Procesar bloques de personaje
                const characterBlocks =
                  validation.blocks?.filter((b) => b.type === 'character') || [];
                let charData = {};

                // Usar datos del bloque de personaje si existe
                if (characterBlocks.length > 0 && characterBlocks[0]?.parsedData) {
                  charData = characterBlocks[0].parsedData;
                } else {
                  // Usar datos del nivel superior como respaldo
                  charData = {
                    mainAlt: validation.mainAlt,
                    mainRole: validation.role,
                    mainGearScore: parseFloat(validation.gearScore) || 0,
                    professions: validation.professions || [],
                    dualRole: validation.dualRole,
                  };
                }

                // Extraer todos los GS de la nota pública
                const gearScores = (member.publicNote?.match(/(\d+\.?\d*)/g) || [])
                  .map(Number)
                  .filter((gs) => gs > 0);

                // Main/Alt
                if (charData.mainAlt) {
                  formattedInfo.push({
                    label: charData.mainAlt === 'M' ? 'Main' : 'Alt',
                    class:
                      charData.mainAlt === 'M'
                        ? 'text-blue-300 font-medium'
                        : 'text-purple-300 font-medium',
                  });
                }

                // Rol principal con su GS
                if (charData.mainRole) {
                  const roleName = roleNamesData[charData.mainRole]?.name || charData.mainRole;
                  const mainGS = gearScores[0] || charData.mainGearScore;

                  formattedInfo.push({
                    label: roleName,
                    class:
                      charData.mainRole === 'T'
                        ? 'text-blue-300 font-medium'
                        : charData.mainRole === 'H'
                          ? 'text-green-300 font-medium'
                          : 'text-red-300 font-medium',
                  });

                  if (mainGS) {
                    formattedInfo.push({
                      label: `GS ${mainGS}k`,
                      class: 'border-amber-500/50 text-amber-200',
                    });
                  }
                }

                // Rol dual (solo si está explícitamente definido)
                if (charData.dualRole) {
                  const dualRoleName = roleNamesData[charData.dualRole]?.name || charData.dualRole;
                  const dualGS = gearScores[1];

                  // Solo mostrar el rol dual si es diferente al rol principal
                  if (charData.dualRole !== charData.mainRole) {
                    formattedInfo.push({
                      label: `Dual ${dualRoleName}`,
                      class: 'border-yellow-500/50 text-yellow-200',
                    });

                    if (dualGS) {
                      formattedInfo.push({
                        label: `GS ${dualGS}k`,
                        class: 'border-amber-500/50 text-amber-200',
                      });
                    }
                  }
                }

                // Profesiones
                const professionsToShow = (
                  charData.professions?.length ? charData.professions : validation.professions || []
                ).filter((prof) => prof && !/^\d+\.?\d*$/.test(prof));

                if (professionsToShow.length) {
                  const processedProfs = new Set();
                  professionsToShow.forEach((prof) => {
                    let profCode = prof.toUpperCase();
                    // Intentar normalizar si es nombre completo
                    const entry = Object.entries(professionNamesData).find(
                      ([_, data]) => data?.name?.toLowerCase() === prof.toLowerCase()
                    );
                    if (entry) profCode = entry[0];

                    if (processedProfs.has(profCode)) return;
                    processedProfs.add(profCode);

                    const profStyle = professionNamesData[profCode] || {
                      name: prof,
                      bgColor: 'bg-indigo-500/20',
                      borderColor: 'border-indigo-500/50',
                      color: 'text-indigo-300',
                    };

                    formattedInfo.push({
                      label: profStyle.name,
                      class: `${profStyle.borderColor} ${profStyle.color}`,
                    });
                  });
                }
              } else {
                // Nota inválida pero existente
                formattedInfo.push({
                  label: 'Nota inválida',
                  class: 'text-red-400 italic',
                });
              }
            }

            return `
            <div class="group bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm rounded-lg p-4 transition-all duration-300 overflow-hidden" 
                 style="border: 1px solid #${classColor}66;"
                 onmouseover="this.style.borderColor='#${classColor}99'; this.style.boxShadow='0 10px 15px -3px #${classColor}1a, 0 4px 6px -2px #${classColor}0a';"
                 onmouseout="this.style.borderColor='#${classColor}66'; this.style.boxShadow='none';">
                <!-- Class color accent -->
                <div class="absolute top-0 left-0 w-1 h-full transition-opacity" style="background-color: #${classColor}; opacity: 0.5;" onmouseover="this.style.opacity='1';" onmouseout="this.style.opacity='0.5';"></div>
                
                <div class="flex flex-col items-start gap-4 pl-2">
                  <div class="flex items-center gap-2">
                    <!-- Avatar -->
                    <div class="relative flex-shrink-0">
                        <img 
                            src="/images/avatars/class_${className}.jpg" 
                            alt="${className}" 
                            class="w-12 h-12 rounded-lg shadow-lg border border-gray-700/50 group-hover:border-[#${classColor}]/50 transition-colors object-cover"
                            onerror="this.src='/images/avatars/default.png'"
                        />
                        <div class="absolute -bottom-1 -right-1 w-4 h-4 rounded-full border-2 border-gray-900 bg-[#${classColor}]" title="${className}"></div>
                    </div>
                    
                    <!-- Info -->
                    <div class="flex-1 min-w-0">
                        <div class="">
                            <div class="font-bold text-gray-100 truncate group-hover:text-[#${classColor}] transition-colors text-lg">${member.name}</div>
                            <span class="text-xs px-2 py-0.5 rounded bg-gray-800 border border-gray-700 text-gray-400">${member.rank}</span>
                        </div>
                        
                        
                    </div>
                    </div>
                    <!-- Details/Tags -->
                        <div class="flex flex-wrap gap-1.5 mt-2">
                            ${
                              formattedInfo.length > 0
                                ? formattedInfo
                                    .map(
                                      (tag) => `
                                <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium border ${tag.class}">
                                    ${tag.label}
                                </span>
                            `
                                    )
                                    .join('')
                                : '<span class="text-xs text-gray-500 italic">Sin detalles</span>'
                            }
                        </div>
                </div>
            </div>
            `;
          })
          .join('');
      }

      // Función para actualizar la información de paginación
      function updatePaginationInfo() {
        if (!pageInfo) return;
        const totalPages = Math.ceil(filteredMembers.length / itemsPerPage);

        // Actualizar el contador de página
        pageInfo.textContent = `Página ${currentPage} de ${totalPages} (${filteredMembers.length} miembros)`;

        // Actualizar estado de los botones de paginación
        if (prevButton) {
          prevButton.disabled = currentPage <= 1;
          prevButton.onclick = () => {
            if (currentPage > 1) {
              currentPage--;
              updateTable();
              updatePaginationInfo();
            }
          };
        }
        if (nextButton) {
          nextButton.disabled = currentPage >= totalPages;
          nextButton.onclick = () => {
            if (currentPage < totalPages) {
              currentPage++;
              updateTable();
              updatePaginationInfo();
            }
          };
        }
      }

      // Inicializar la tabla
      initTable();
    });
  </script>

  <!-- Estadísticas del Roster -->
  <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6 mt-2">
    <!-- Total de Miembros y Mains/Alts -->
    <div
      class="bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-600/40 rounded-lg p-4 hover:border-amber-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-amber-500/10"
    >
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center space-x-2">
          <div class="w-10 h-10 bg-amber-500/20 rounded-lg flex items-center justify-center">
            <svg
              class="w-6 h-6 text-amber-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"
              ></path>
            </svg>
          </div>
          <h3 class="text-sm font-semibold text-amber-300 uppercase tracking-wide">Miembros</h3>
        </div>
        <p class="text-3xl font-bold text-amber-200">{stats.totalMembers || 0}</p>
      </div>
      <div class="grid grid-cols-2 gap-3 pt-3 border-t border-amber-900/30">
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{mainAltStats.M || 0}</p>
          <p class="text-xs text-amber-300/90 font-medium uppercase tracking-wide">Mains</p>
        </div>
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{mainAltStats.A || 0}</p>
          <p class="text-xs text-amber-300/90 font-medium uppercase tracking-wide">Alts</p>
        </div>
      </div>
    </div>

    <!-- Distribución de Roles -->
    <div
      class="bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-blue-600/40 rounded-lg p-4 hover:border-blue-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-blue-500/10"
    >
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center space-x-2">
          <div class="w-10 h-10 bg-blue-500/20 rounded-lg flex items-center justify-center">
            <svg
              class="w-6 h-6 text-blue-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
              ></path>
            </svg>
          </div>
          <h3 class="text-sm font-semibold text-blue-300 uppercase tracking-wide">Roles</h3>
        </div>
        <p class="text-3xl font-bold text-blue-200">
          {Object.values(roleStats).reduce((a, b) => a + b, 0) || 0}
        </p>
      </div>
      <div class="grid grid-cols-3 gap-2 pt-3 border-t border-blue-900/30">
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{roleStats.T || 0}</p>
          <p class="text-xs text-blue-300/90 font-medium uppercase tracking-wide">Tanks</p>
        </div>
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{roleStats.H || 0}</p>
          <p class="text-xs text-green-300/90 font-medium uppercase tracking-wide">Healers</p>
        </div>
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{roleStats.D || 0}</p>
          <p class="text-xs text-red-300/90 font-medium uppercase tracking-wide">DPS</p>
        </div>
      </div>
    </div>

    <!-- Combinaciones de Roles Duales -->
    <div
      class="bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-purple-600/40 rounded-lg p-4 hover:border-purple-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-purple-500/10"
    >
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center space-x-2">
          <div class="w-10 h-10 bg-purple-500/20 rounded-lg flex items-center justify-center">
            <svg
              class="w-6 h-6 text-purple-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path>
            </svg>
          </div>
          <h3 class="text-sm font-semibold text-purple-300 uppercase tracking-wide">Duales</h3>
        </div>
        <p class="text-3xl font-bold text-purple-200">
          {dualRoleStats.TH + dualRoleStats.TD + dualRoleStats.HD}
        </p>
      </div>
      <div class="grid grid-cols-3 gap-2 pt-3 border-t border-purple-900/30">
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{dualRoleStats.TH}</p>
          <p
            class="text-[10px] text-purple-300/90 font-medium uppercase tracking-wide leading-tight"
          >
            Tank<br />Heal
          </p>
        </div>
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{dualRoleStats.TD}</p>
          <p
            class="text-[10px] text-purple-300/90 font-medium uppercase tracking-wide leading-tight"
          >
            Tank<br />DPS
          </p>
        </div>
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">{dualRoleStats.HD}</p>
          <p
            class="text-[10px] text-purple-300/90 font-medium uppercase tracking-wide leading-tight"
          >
            Heal<br />DPS
          </p>
        </div>
      </div>
    </div>

    <!-- Gear Score -->
    <div
      class="bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-green-600/40 rounded-lg p-4 hover:border-green-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-green-500/10"
    >
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center space-x-2">
          <div class="w-10 h-10 bg-green-500/20 rounded-lg flex items-center justify-center">
            <svg
              class="w-6 h-6 text-green-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
              ></path>
            </svg>
          </div>
          <h3 class="text-sm font-semibold text-green-300 uppercase tracking-wide">GS Promedio</h3>
        </div>
        <p class="text-3xl font-bold text-green-200">
          {averageGearScore !== 'N/A' ? averageGearScore : 'N/A'}
        </p>
      </div>
      <div class="grid grid-cols-2 gap-3 pt-3 border-t border-green-900/30">
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">
            {minGearScore !== 'N/A' ? minGearScore : 'N/A'}
          </p>
          <p class="text-xs text-green-300/90 font-medium uppercase tracking-wide">Mínimo</p>
        </div>
        <div class="text-center bg-gray-800/40 rounded-lg p-2">
          <p class="text-2xl font-bold text-white mb-1">
            {maxGearScore !== 'N/A' ? maxGearScore : 'N/A'}
          </p>
          <p class="text-xs text-green-300/90 font-medium uppercase tracking-wide">Máximo</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Filtros y Ordenamiento - Diseño Compacto -->
  <div class="bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-600/40 rounded-lg p-4 hover:border-amber-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-amber-500/10">
    <div class="flex flex-col sm:flex-row flex-wrap gap-4 items-start sm:items-end">
      <!-- Buscador -->
      <div class="flex-1 min-w-[200px]">
        <label for="search" class="block text-xs font-medium text-text-muted/80 mb-1">
          Buscar nombre
        </label>
        <div class="relative">
          <input
            type="text"
            id="search"
            placeholder="Nombre..."
            class="w-full bg-transparent border border-accent/50 rounded-lg px-3 py-1.5 text-sm text-white focus:outline-none focus:ring-1 focus:ring-accent/50 focus:border-accent/70 placeholder-text-muted/50 transition-all duration-200"
          />
          <svg class="w-4 h-4 absolute right-3 top-1/2 transform -translate-y-1/2 text-amber-500/60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
        </div>
      </div>

      <!-- Filtro de Clase -->
      <div class="flex-1 min-w-[180px]">
        <label for="class-filter" class="block text-xs font-medium text-text-muted/80 mb-1">
          Clase
        </label>
        <div class="relative">
          <select
            id="class-filter"
            class="w-full bg-gray-900/50 border border-accent/50 rounded-lg px-3 py-1.5 text-sm text-white focus:outline-none focus:ring-1 focus:ring-accent/50 focus:border-accent/70 appearance-none transition-all duration-200 cursor-pointer hover:border-accent/70 pr-8"
          >
            <option value="">Todas las clases</option>
            {
              Object.entries(rosterData.classInfo).map(([key, info]) => (
                <option value={key} style={`color: #${info.color}`}>
                  {info.name}
                </option>
              ))
            }
          </select>
          <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-amber-500/70">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>

      <!-- Filtro de Rango -->
      <div class="flex-1 min-w-[150px]">
        <label for="rank-filter" class="block text-xs font-medium text-text-muted/80 mb-1">
          Rango
        </label>
        <div class="relative">
          <select
            id="rank-filter"
            class="w-full bg-gray-900/50 border border-accent/50 rounded-lg px-3 py-1.5 text-sm text-white focus:outline-none focus:ring-1 focus:ring-accent/50 focus:border-accent/70 appearance-none transition-all duration-200 cursor-pointer hover:border-accent/70 pr-8"
          >
            <option value="">Todos los rangos</option>
            {
              ranks.map((rank) => (
                <option value={rank} class="text-white">
                  {rank}
                </option>
              ))
            }
          </select>
          <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-amber-500/70">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
          </div>
        </div>
      </div>

      <!-- Botones de Ordenamiento -->
      <div class="flex-1 min-w-full sm:min-w-0 mt-2 sm:mt-0">
        <div class="flex flex-wrap gap-2">
          <button
            id="sort-name"
            class="sort-button px-3 py-1.5 text-xs rounded-lg bg-amber-900/30 border border-amber-700/50 text-amber-100 hover:bg-amber-800/40 hover:border-amber-500/60 transition-all duration-200 flex items-center gap-1.5"
            data-sort="name"
            data-direction="asc"
          >
            <span>Personaje</span>
            <span class="sort-indicator text-amber-400">↕</span>
          </button>
          <button
            id="sort-details"
            class="sort-button px-3 py-1.5 text-xs rounded-lg bg-amber-900/30 border border-amber-700/50 text-amber-100 hover:bg-amber-800/40 hover:border-amber-500/60 transition-all duration-200 flex items-center gap-1.5"
            data-sort="publicNote"
            data-direction="none"
          >
            <span>Detalles</span>
            <span class="sort-indicator text-amber-400">↕</span>
          </button>

        </div>
      </div>
    </div>
  </div>

  <!-- Grid de miembros -->
  <div id="roster-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    <!-- Los miembros se cargarán aquí dinámicamente -->
  </div>

  <div id="pagination-container" class="mt-8">
    <div class="flex flex-col sm:flex-row items-center justify-between gap-4 p-4 bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-600/40 rounded-lg p-4 hover:border-amber-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-amber-500/10">
      <!-- Mobile: Stacked layout -->
      <div class="w-full flex flex-col sm:flex-row items-center justify-between sm:justify-start gap-4 sm:gap-6">
        <!-- Page info - more compact on mobile -->
        <div id="page-info" class="text-sm text-amber-200/70 whitespace-nowrap">
          <span class="font-medium text-amber-300">Página</span> 
          <span id="current-page" class="font-bold text-white">1</span> 
          <span class="text-gray-400">de</span> 
          <span id="total-pages" class="font-medium">1</span>
          <span class="hidden sm:inline text-gray-400">•</span>
          <span class="hidden sm:inline text-gray-300"><span id="total-members">0</span> miembros</span>
        </div>

        <!-- Pagination controls -->
        <div class="flex items-center gap-2">
          <!-- Previous page button -->
          <button 
            id="prev-button" 
            class="w-9 h-9 flex items-center justify-center rounded-md border border-amber-700/50 bg-amber-900/20 text-amber-200 hover:bg-amber-800/40 hover:border-amber-500/60 disabled:opacity-40 disabled:cursor-not-allowed transition-all duration-200" 
            title="Página anterior" 
            disabled
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
          </button>

          <!-- Page numbers -->
          <div id="page-buttons" class="flex items-center gap-1">
            <!-- Page buttons will be inserted here by JavaScript -->
          </div>

          <!-- Next page button -->
          <button 
            id="next-button" 
            class="w-9 h-9 flex items-center justify-center rounded-md border border-amber-700/50 bg-amber-900/20 text-amber-200 hover:bg-amber-800/40 hover:border-amber-500/60 transition-all duration-200" 
            title="Página siguiente"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>


  

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Pagination elements
      const prevButton = document.getElementById('prev-button');
      const nextButton = document.getElementById('next-button');
      const pageButtonsContainer = document.getElementById('page-buttons');
      const currentPageElement = document.getElementById('current-page');
      const totalPagesElement = document.getElementById('total-pages');
      const totalMembersElement = document.getElementById('total-members');
      const rosterGrid = document.getElementById('roster-grid');
      const searchInput = document.getElementById('search');
      const classFilter = document.getElementById('class-filter');
      const rankFilter = document.getElementById('rank-filter');
      const sortButtons = document.querySelectorAll('.sort-button');
      const itemsPerPage = 6;
      
      // Current sort state
      let currentSort = {
        field: 'name',
        direction: 'asc' // 'asc' or 'desc'
      };
      
      let currentPage = 1;
      let totalPages = 1;
      let filteredMembers = [];
      let allMembers = [];

      // Initialize the roster
      function initRoster() {
        try {
          // Get roster data from the hidden element
          const rosterDataElement = document.getElementById('roster-data');
          if (!rosterDataElement) {
            console.error('No se encontró el elemento de datos del roster');
            return;
          }
          
          const rosterData = JSON.parse(rosterDataElement.textContent);
          allMembers = rosterData.members || [];
          filteredMembers = [...allMembers];
          
          // Update total members count
          totalMembersElement.textContent = allMembers.length;
          
          // Calculate total pages
          updatePagination();
          
          // Render first page
          renderMembers();
          
          // Add event listeners
          setupEventListeners();
        } catch (error) {
          console.error('Error al inicializar el roster:', error);
        }
      }

      // Update pagination controls
      function updatePagination() {
        // Calculate total pages
        totalPages = Math.ceil(filteredMembers.length / itemsPerPage);
        totalPages = Math.max(1, totalPages); // At least 1 page
        
        // Update page info
        currentPage = Math.min(currentPage, totalPages); // Ensure current page is within bounds
        currentPageElement.textContent = currentPage;
        totalPagesElement.textContent = totalPages;
        totalMembersElement.textContent = filteredMembers.length;
        
        // Update button states
        prevButton.disabled = currentPage === 1;
        nextButton.disabled = currentPage === totalPages;
        
        // Generate page buttons
        generatePageButtons();
      }

      // Generate page number buttons
      function generatePageButtons() {
        pageButtonsContainer.innerHTML = '';
        
        // Always show first page
        addPageButton(1);
        
        // Calculate range of pages to show
        let startPage = Math.max(2, currentPage - 1);
        let endPage = Math.min(totalPages - 1, currentPage + 1);
        
        // Add ellipsis if needed
        if (startPage > 2) {
          addEllipsis();
        }
        
        // Add middle pages
        for (let i = startPage; i <= endPage; i++) {
          addPageButton(i);
        }
        
        // Add ellipsis if needed
        if (endPage < totalPages - 1) {
          addEllipsis();
        }
        
        // Always show last page if there's more than one page
        if (totalPages > 1) {
          addPageButton(totalPages);
        }
      }
      
      function addPageButton(pageNumber) {
        if (pageNumber < 1 || pageNumber > totalPages) return;
        
        const button = document.createElement('button');
        button.className = `px-3 py-1 rounded-md transition-colors page-button ${
          pageNumber === currentPage 
            ? 'bg-amber-600 text-white' 
            : 'hover:bg-amber-500/20 hover:text-amber-300 text-text-muted'
        }`;
        button.textContent = pageNumber;
        button.title = `Ir a la página ${pageNumber}`;
        button.dataset.page = pageNumber;
        
        button.addEventListener('click', () => {
          currentPage = pageNumber;
          updatePagination();
          renderMembers();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        
        pageButtonsContainer.appendChild(button);
      }
      
      function addEllipsis() {
        const span = document.createElement('span');
        span.className = 'px-2 text-text-muted';
        span.textContent = '...';
        pageButtonsContainer.appendChild(span);
      }

      // Render members for current page
      function renderMembers() {
        if (!rosterGrid) return;
        
        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;
        const membersToShow = filteredMembers.slice(startIndex, endIndex);
        
        // Clear existing content
        rosterGrid.innerHTML = '';
        
        if (membersToShow.length === 0) {
          rosterGrid.innerHTML = `
            <div class="col-span-full text-center py-12 text-amber-200/70">
              <p class="text-lg font-medium">No se encontraron miembros</p>
              <p class="text-sm mt-2">Intenta con otros filtros de búsqueda</p>
            </div>
          `;
          return;
        }
        
        // Render each member
        membersToShow.forEach(member => {
          const memberElement = createMemberCard(member);
          if (memberElement) {
            rosterGrid.appendChild(memberElement);
          }
        });
      }
      
      // Create member card element
      function createMemberCard(member) {
        // This is a simplified version - you should adapt it to match your member card structure
        const div = document.createElement('div');
        div.className = 'bg-gray-900/50 rounded-lg p-4 border border-amber-900/30 hover:border-amber-500/50 transition-colors';
        
        div.innerHTML = `
          <div class="flex items-center space-x-4">
            <div class="w-12 h-12 rounded-full bg-amber-900/30 flex items-center justify-center">
              <span class="text-amber-400 text-xl font-bold">${member.name.charAt(0)}</span>
            </div>
            <div>
              <h3 class="font-medium text-amber-200">${member.name}</h3>
              <p class="text-sm text-amber-100/70">${member.class || 'No especificada'}</p>
              ${member.rank ? `<span class="text-xs px-2 py-0.5 bg-amber-900/30 text-amber-300 rounded">${member.rank}</span>` : ''}
            </div>
          </div>
        `;
        
        return div;
      }
      
      // Sort members based on current sort settings
      function sortMembers() {
        if (currentSort.field) {
          filteredMembers.sort((a, b) => {
            let valueA, valueB;
            
            // Get the values to compare
            if (currentSort.field === 'name') {
              valueA = a.name?.toLowerCase() || '';
              valueB = b.name?.toLowerCase() || '';
            } else if (currentSort.field === 'publicNote') {
              valueA = a.publicNote?.toLowerCase() || '';
              valueB = b.publicNote?.toLowerCase() || '';
              
              // If both are empty, consider them equal
              if (!valueA && !valueB) return 0;
              // Empty values go to the end
              if (!valueA) return 1;
              if (!valueB) return -1;
            }
            
            // Compare the values
            if (valueA < valueB) {
              return currentSort.direction === 'asc' ? -1 : 1;
            }
            if (valueA > valueB) {
              return currentSort.direction === 'asc' ? 1 : -1;
            }
            return 0;
          });
        }
      }
      
      // Update sort indicators
      function updateSortIndicators() {
        sortButtons.forEach(button => {
          const indicator = button.querySelector('.sort-indicator');
          const sortField = button.dataset.sort;
          
          if (sortField === currentSort.field) {
            indicator.textContent = currentSort.direction === 'asc' ? '↑' : '↓';
            button.classList.add('bg-amber-800/40', 'border-amber-500/60');
            button.classList.remove('bg-amber-900/30', 'border-amber-700/50');
          } else {
            indicator.textContent = '↕';
            button.classList.remove('bg-amber-800/40', 'border-amber-500/60');
            button.classList.add('bg-amber-900/30', 'border-amber-700/50');
          }
        });
      }
      
      // Handle sort button click
      function handleSortClick(sortField) {
        if (currentSort.field === sortField) {
          // Toggle direction if clicking the same field
          currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
          // Set new sort field and default to ascending
          currentSort.field = sortField;
          currentSort.direction = 'asc';
        }
        
        // Update the UI
        updateSortIndicators();
        
        // Apply the sort
        sortMembers();
        
        // Reset to first page and render
        currentPage = 1;
        updatePagination();
        renderMembers();
      }
      
      // Filter members based on search and filters
      function filterMembers() {
        const searchTerm = searchInput.value.toLowerCase();
        const selectedClass = classFilter.value;
        const selectedRank = rankFilter.value;
        
        filteredMembers = allMembers.filter(member => {
          // Filter by search term
          const matchesSearch = member.name.toLowerCase().includes(searchTerm) || 
                              (member.publicNote && member.publicNote.toLowerCase().includes(searchTerm));
          
          // Filter by class
          const matchesClass = !selectedClass || member.class === selectedClass;
          
          // Filter by rank
          const matchesRank = !selectedRank || member.rank === selectedRank;
          
          return matchesSearch && matchesClass && matchesRank;
        });
        
        // Apply current sort after filtering
        sortMembers();
        
        // Reset to first page when filters change
        currentPage = 1;
        updatePagination();
        renderMembers();
      }
      
      // Set up event listeners
      function setupEventListeners() {
        // Pagination buttons
        prevButton.addEventListener('click', () => {
          if (currentPage > 1) {
            currentPage--;
            updatePagination();
            renderMembers();
            window.scrollTo({ top: 0, behavior: 'smooth' });
          }
        });
        
        nextButton.addEventListener('click', () => {
          if (currentPage < totalPages) {
            currentPage++;
            updatePagination();
            renderMembers();
            window.scrollTo({ top: 0, behavior: 'smooth' });
          }
        });
        
        // Sort buttons
        sortButtons.forEach(button => {
          button.addEventListener('click', () => {
            const sortField = button.dataset.sort;
            handleSortClick(sortField);
          });
        });
        
        // Search and filter inputs
        searchInput.addEventListener('input', filterMembers);
        classFilter.addEventListener('change', filterMembers);
        rankFilter.addEventListener('change', filterMembers);
      }
      
      // Initialize the roster when the page loads
      initRoster();
      
      // Set initial sort indicators
      updateSortIndicators();
    });
  </script>


<div class="mt-6"> <div class="bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-600/40 rounded-lg p-4 hover:border-amber-500/60 transition-all duration-300 hover:shadow-lg hover:shadow-amber-500/10"> <div class="flex items-center justify-center mb-4"> <div class="flex items-center space-x-2"> <div class="w-8 h-8 bg-amber-600 rounded-lg flex items-center justify-center"> <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path> </svg> </div> <h2 class="text-xl font-bold text-amber-200 uppercase">
  Reglas de Hermandad
  </h2> </div> </div> <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3"> <!-- Norma 1 --> <div class="bg-gray-800/50 border border-amber-700/30 rounded-lg p-3"> <div class="flex items-start space-x-3"> <div class="w-8 h-8 bg-amber-600 rounded-lg flex-shrink-0 flex items-center justify-center"> <span class="text-white text-sm font-bold">1</span> </div> <div class="flex-1 min-w-0"> <div class="flex items-center space-x-1 mb-1"> <svg class="w-4 h-4 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path> </svg> <h4 class="font-bold text-amber-300 text-sm">Código de Nota</h4> </div> <p class="text-gray-300 text-xs leading-snug mb-1">
  WISP función y gear score al GM/Alter u Oficial en línea por wisp para subir de rango.
  </p> <p class="text-gray-400 text-xs leading-snug">
  Asi garantizan su participación en raids y sorteos.
  </p> </div> </div> </div> <!-- Norma 2 --> <div class="bg-gray-800/50 border border-amber-700/30 rounded-lg p-3"> <div class="flex items-start space-x-3"> <div class="w-8 h-8 bg-amber-600 rounded-lg flex-shrink-0 flex items-center justify-center"> <span class="text-white text-sm font-bold">2</span> </div> <div class="flex-1 min-w-0"> <div class="flex items-center space-x-1 mb-1"> <svg class="w-4 h-4 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"></path> </svg> <h4 class="font-bold text-amber-300 text-sm">Baul de Sorteos</h4> </div> <p class="text-gray-300 text-xs leading-snug mb-1">
  BOEs en venta con 30% de descuento. Se acepta oro o farm lvl74+ como pago.
  </p> <p class="text-gray-400 text-xs leading-snug">
  Se reciben donaciones para mantener el baul funcionando.
  </p> </div> </div> </div> <!-- Norma 3 --> <div class="bg-gray-800/50 border border-amber-700/30 rounded-lg p-3"> <div class="flex items-start space-x-3"> <div class="w-8 h-8 bg-amber-600 rounded-lg flex-shrink-0 flex items-center justify-center"> <span class="text-white text-sm font-bold">3</span> </div> <div class="flex-1 min-w-0"> <div class="flex items-center space-x-1 mb-1"> <svg class="w-4 h-4 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path> </svg> <h4 class="font-bold text-amber-300 text-sm">Farm lvl 74+</h4> </div> <p class="text-gray-300 text-xs leading-snug mb-1">
  Materiales e items lvl 74+ como orbes congelados, fragmento onirico, consumibles,
                    etc. Para compartir con quienes esten subiendo profesiones.
  </p> <p class="text-gray-400 text-xs leading-snug">
  Se reciben donaciones para mantener el baul funcionando.
  </p> </div> </div> </div> <!-- Norma 4 --> <div class="bg-gray-800/50 border border-amber-700/30 rounded-lg p-3"> <div class="flex items-start space-x-3"> <div class="w-8 h-8 bg-amber-600 rounded-lg flex-shrink-0 flex items-center justify-center"> <span class="text-white text-sm font-bold">4</span> </div> <div class="flex-1 min-w-0"> <div class="flex items-center space-x-1 mb-1"> <svg class="w-4 h-4 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"></path> </svg> <h4 class="font-bold text-amber-300 text-sm">Reconocimientos</h4> </div> <p class="text-gray-300 text-xs leading-snug mb-1">
  Los jugadores que contribuyen activamente al flujo de la hermandad son reconocidos
                    mensualmente.
  </p> <p class="text-gray-400 text-xs leading-snug">
  Se anima a todos los miembros a liderar actividades y eventos para que todos
                    puedan participar.
  </p> </div> </div> </div> <!-- Norma 5 - Trabajo en Equipo --> <div class="bg-gray-800/50 border border-amber-700/30 rounded-lg p-3"> <div class="flex items-start space-x-3"> <div class="w-8 h-8 bg-amber-600 rounded-lg flex-shrink-0 flex items-center justify-center"> <span class="text-white text-sm font-bold">5</span> </div> <div class="flex-1 min-w-0"> <div class="flex items-center space-x-1 mb-1"> <svg class="w-4 h-4 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path> </svg> <h4 class="font-bold text-amber-300 text-sm">Trabajo en Equipo</h4> </div> <p class="text-gray-300 text-xs leading-snug mb-1">
  Respeto y colaboración con todos los miembros de la hermandad.
  </p> <p class="text-gray-400 text-xs leading-snug">
  Fomento del trabajo en equipo y la ayuda mutua en todas las actividades.
  </p> </div> </div> </div> <!-- Norma 6 - Respeto --> <div class="bg-gray-800/50 border border-amber-700/30 rounded-lg p-3"> <div class="flex items-start space-x-3"> <div class="w-8 h-8 bg-amber-600 rounded-lg flex-shrink-0 flex items-center justify-center"> <span class="text-white text-sm font-bold">6</span> </div> <div class="flex-1 min-w-0"> <div class="flex items-center space-x-1 mb-1"> <svg class="w-4 h-4 text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path> </svg> <h4 class="font-bold text-amber-300 text-sm">Respeto</h4> </div> <p class="text-gray-300 text-xs leading-snug mb-1">
  Respeto entre todos los miembros. No se tolerará el racismo, discriminación o
                    acoso de ningún tipo.
  </p> <p class="text-gray-400 text-xs leading-snug">
  Mantener un ambiente sano y de respeto mutuo.
  </p> </div> </div> </div></div></div></div>

<!-- Sección de estadísticas -->
<details class="group bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-700/30 rounded-lg overflow-hidden transition-all duration-300 hover:border-amber-500/50">
  <summary class="px-4 py-3 flex items-center justify-between cursor-pointer select-none">
    <div class="flex items-center space-x-3">
      <div class="w-8 h-8 bg-amber-600/20 rounded-lg flex items-center justify-center group-hover:bg-amber-500/30 transition-colors">
        <svg class="w-4 h-4 text-amber-400 transform group-open:rotate-90 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
      </div>
      <h3 class="text-sm font-semibold text-amber-300 uppercase tracking-wider">Estadísticas del Roster</h3>
    </div>
    <span class="text-xs text-amber-400/70 group-hover:text-amber-300 transition-colors">
      <span class="hidden group-open:inline">Ocultar</span>
      <span class="group-open:hidden">Mostrar</span> estadísticas
    </span>
  </summary>
  
  <div class="border-t border-amber-900/30 p-4">
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <!-- Columna 1: Distribución por Rango -->
      <div
        class="group bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-700/30 rounded-lg p-5 hover:border-amber-500/60 transition-all duration-300 hover:shadow-xl hover:shadow-amber-500/10"
      >
        <div class="flex items-center space-x-3 mb-5 pb-4 border-b border-amber-900/30">
          <div class="w-10 h-10 bg-purple-500/20 rounded-lg flex items-center justify-center">
            <svg
              class="w-6 h-6 text-purple-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z"
              ></path>
            </svg>
          </div>
          <h3 class="text-lg font-bold text-amber-300 uppercase tracking-wide">Por Rango</h3>
        </div>
        <div class="space-y-3.5">
          {
            rankDistribution.map(({ name, count, percentage }) => {
              // Asignar colores según el rango
              let colorClass = 'from-accent to-accent-light';
              if (name === 'Guild Master') colorClass = 'from-yellow-400 to-yellow-600';
              else if (name === 'Alter') colorClass = 'from-purple-400 to-purple-600';
              else if (name === 'Explorador') colorClass = 'from-blue-400 to-blue-600';
              else if (name === 'Iniciado') colorClass = 'from-green-400 to-green-600';
              else if (name === 'Aspirante') colorClass = 'from-gray-400 to-gray-600';

              return (
                <div class="space-y-2">
                  <div class="flex items-center justify-between text-sm">
                    <span class="text-amber-100 font-medium">{name}</span>
                    <div class="flex items-center space-x-2">
                      <span class="text-white font-bold">{count}</span>
                      <span class="text-amber-300/70 text-xs">({percentage}%)</span>
                    </div>
                  </div>
                  <div class="relative w-full bg-gray-800/50 rounded-full h-2 overflow-hidden shadow-inner">
                    <div
                      class="h-full rounded-full bg-gradient-to-r transition-all duration-700 ease-out shadow-lg"
                      class:list={[colorClass]}
                      style={{ width: `${percentage}%` }}
                    />
                  </div>
                </div>
              );
            })
          }
        </div>
      </div>

      <!-- Columna 2: Distribución por Clase -->
      <div
        class="group bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-700/30 rounded-lg p-5 hover:border-amber-500/60 transition-all duration-300 hover:shadow-xl hover:shadow-amber-500/10"
      >
        <div class="flex items-center space-x-3 mb-5 pb-4 border-b border-amber-900/30">
          <div class="w-10 h-10 bg-blue-500/20 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
              ></path>
            </svg>
          </div>
          <h3 class="text-lg font-bold text-amber-300 uppercase tracking-wide">Por Clase</h3>
        </div>
        <div class="space-y-3.5">
          {
            classDistribution.map(({ name, count, color: classColor }) => {
              const percentage = Math.round((count / rosterData.members.length) * 100);
              return (
                <div class="space-y-2">
                  <div class="flex items-center justify-between text-sm">
                    <div class="flex items-center space-x-2">
                      <span
                        class="w-3 h-3 rounded-full border-2 border-gray-700 shadow-sm"
                        style={`background-color: #${classColor}`}
                      />
                      <span class="text-amber-100 font-medium">{name}</span>
                    </div>
                    <div class="flex items-center space-x-2">
                      <span class="text-white font-bold">{count}</span>
                      <span class="text-amber-300/70 text-xs">({percentage}%)</span>
                    </div>
                  </div>
                  <div class="relative w-full bg-gray-800/50 rounded-full h-2 overflow-hidden shadow-inner">
                    <div
                      class="h-full rounded-full transition-all duration-700 ease-out shadow-lg"
                      style={{
                        width: `${percentage}%`,
                        background: `linear-gradient(to right, #${classColor}cc, #${classColor}ff)`,
                      }}
                    />
                  </div>
                </div>
              );
            })
          }
        </div>
      </div>

      <!-- Columna 3: Distribución por Profesión -->
      <div
        class="group bg-gradient-to-br from-gray-900/80 to-gray-800/60 backdrop-blur-sm border border-amber-700/30 rounded-lg p-5 hover:border-amber-500/60 transition-all duration-300 hover:shadow-xl hover:shadow-amber-500/10"
      >
        <div class="flex items-center space-x-3 mb-5 pb-4 border-b border-amber-900/30">
          <div class="w-10 h-10 bg-green-500/20 rounded-lg flex items-center justify-center">
            <svg class="w-6 h-6 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
              ></path>
            </svg>
          </div>
          <h3 class="text-lg font-bold text-amber-300 uppercase tracking-wide">Por Profesión</h3>
        </div>
        <div class="space-y-3.5">
          {
            (() => {
              // Verificar si hay estadísticas de profesiones
              if (!stats.professions || Object.keys(stats.professions).length === 0) {
                return (
                  <div class="text-center text-amber-100/60 text-sm py-8">
                    <svg
                      class="w-12 h-12 mx-auto mb-3 text-amber-400/40"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"
                      />
                    </svg>
                    <p>No hay datos de profesiones disponibles</p>
                  </div>
                );
              }

              // Obtener el total de miembros con profesiones válidas
              const totalWithProfessions = Object.values(stats.professions).reduce(
                (sum, count) => sum + count,
                0
              );

              // Mostrar todas las profesiones ordenadas por conteo (de mayor a menor)
              return Object.entries(PROFESSION_INFO)
                .map(([code, info]) => {
                  const count = stats.professions[code] || 0;
                  const percentage =
                    totalWithProfessions > 0
                      ? Math.min(100, Math.round((count / totalWithProfessions) * 100))
                      : 0;

                  return {
                    code,
                    name: info.name,
                    count,
                    percentage,
                    colors: info.colors,
                    hasData: count > 0,
                  };
                })
                .sort((a, b) => b.count - a.count)
                .map(({ code, name, count, percentage, colors, hasData }) => (
                  <div class="space-y-2">
                    <div class="flex items-center justify-between text-sm">
                      <div class="flex items-center space-x-2">
                        <span
                          class="w-3 h-3 rounded-full border-2 border-gray-700 shadow-sm"
                          style={`background-color: ${colors.dark}`}
                        />
                        <span class="text-amber-100 font-medium">{name}</span>
                      </div>
                      <div class="flex items-center space-x-2">
                        <span class="text-white font-bold">{count}</span>
                        <span class="text-amber-300/70 text-xs">({percentage}%)</span>
                      </div>
                    </div>
                    <div class="relative w-full bg-gray-800/50 rounded-full h-2 overflow-hidden shadow-inner">
                      <div
                        class="h-full rounded-full transition-all duration-700 ease-out shadow-lg"
                        style={{
                          width: `${percentage}%`,
                          background: `linear-gradient(to right, ${colors.light}, ${colors.dark})`,
                          opacity: hasData ? 1 : 0.5,
                        }}
                      />
                    </div>
                  </div>
                ));
            })()
          }
        </div>
      </div>
    </div>
  </div>
</details>

  <!-- Script para el manejo de pestañas -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const tabButtons = document.querySelectorAll<HTMLButtonElement>('.tab-button');
      const tabPanes = document.querySelectorAll<HTMLElement>('.tab-pane');
      const defaultTab = document.getElementById('legend-tab');

      // Activar la pestaña por defecto
      if (defaultTab) {
        defaultTab.classList.remove('hidden');
      }

      tabButtons.forEach((button) => {
        button.addEventListener('click', () => {
          // Remover clases activas
          tabButtons.forEach((btn) => {
            btn.classList.remove('active', 'border-accent', 'text-white');
            btn.classList.add('text-text-muted');
          });

          tabPanes.forEach((pane) => pane.classList.add('hidden'));

          // Activar pestaña clickeada
          button.classList.remove('text-text-muted');
          button.classList.add('active', 'border-accent', 'text-white');

          const tabId = button.getAttribute('data-tab');
          if (tabId) {
            const tabPane = document.getElementById(`${tabId}-tab`);
            if (tabPane) {
              tabPane.classList.remove('hidden');

              // Forzar reflow para activar la animación
              void tabPane.offsetWidth;
              tabPane.style.animation = 'fadeIn 0.3s ease';

              // Remover la animación después de que termine
              setTimeout(() => {
                tabPane.style.animation = '';
              }, 300);
            }
          }
        });
      });
    });
  </script>

  <style>
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .tab-pane {
      animation: fadeIn 0.3s ease-out;
    }
  </style>

  <!-- Estilos para las pestañas -->
  <style>
    .tab-button {
      transition: all 0.2s ease;
      margin-bottom: -1px;
    }
    .tab-button:hover {
      color: white;
    }
    .tab-button.active {
      border-bottom-color: #3b82f6;
      color: white;
    }
    .tab-pane {
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</div>
